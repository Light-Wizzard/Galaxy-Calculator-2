<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GalaxyCalculator2: nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo32.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GalaxyCalculator2
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">GalaxyCalculator2 is a Galaxy Calculator.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classnlohmann_1_1basic__json.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classnlohmann_1_1basic__json-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a class to store JSON values  
 <a href="classnlohmann_1_1basic__json.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="json_8hpp_source.html">json.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac68cb65a7f3517f0c5b1d3a4967406ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac68cb65a7f3517f0c5b1d3a4967406ad">value_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">detail::value_t</a></td></tr>
<tr class="separator:ac68cb65a7f3517f0c5b1d3a4967406ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f1f93b32da01b42413643be32b2c27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> = ::<a class="el" href="classnlohmann_1_1json__pointer.html">nlohmann::json_pointer</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:aa8f1f93b32da01b42413643be32b2c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Pointer, see <a class="el" href="classnlohmann_1_1json__pointer.html">nlohmann::json_pointer</a>.  <a href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">More...</a><br /></td></tr>
<tr class="separator:aa8f1f93b32da01b42413643be32b2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ebc5da7ced975bb184133750e7d49f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SFINAE &gt; </td></tr>
<tr class="memitem:ad6ebc5da7ced975bb184133750e7d49f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer</a> = JSONSerializer&lt; T, SFINAE &gt;</td></tr>
<tr class="separator:ad6ebc5da7ced975bb184133750e7d49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7ca76cc3f62626b380be5e18a002d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a1e7ca76cc3f62626b380be5e18a002d5">error_handler_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967df">detail::error_handler_t</a></td></tr>
<tr class="memdesc:a1e7ca76cc3f62626b380be5e18a002d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors  <a href="classnlohmann_1_1basic__json.html#a1e7ca76cc3f62626b380be5e18a002d5">More...</a><br /></td></tr>
<tr class="separator:a1e7ca76cc3f62626b380be5e18a002d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54951d14f0dd10cc3cfdaa24f8bfd15c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a54951d14f0dd10cc3cfdaa24f8bfd15c">cbor_tag_handler_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">detail::cbor_tag_handler_t</a></td></tr>
<tr class="memdesc:a54951d14f0dd10cc3cfdaa24f8bfd15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags  <a href="classnlohmann_1_1basic__json.html#a54951d14f0dd10cc3cfdaa24f8bfd15c">More...</a><br /></td></tr>
<tr class="separator:a54951d14f0dd10cc3cfdaa24f8bfd15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac569f292a070dfd2f6b69c16e746095a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> = std::initializer_list&lt; <a class="el" href="classnlohmann_1_1detail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:ac569f292a070dfd2f6b69c16e746095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type for initializer lists of <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> values  <a href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">More...</a><br /></td></tr>
<tr class="separator:ac569f292a070dfd2f6b69c16e746095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211cf53702226ad9fb3c939a3a3d3689"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a211cf53702226ad9fb3c939a3a3d3689">input_format_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">detail::input_format_t</a></td></tr>
<tr class="separator:a211cf53702226ad9fb3c939a3a3d3689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b1094a1a9feb54e400d8510bb0b12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a164b1094a1a9feb54e400d8510bb0b12">json_sax_t</a> = <a class="el" href="structnlohmann_1_1json__sax.html">json_sax</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a164b1094a1a9feb54e400d8510bb0b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX interface type, see <a class="el" href="structnlohmann_1_1json__sax.html">nlohmann::json_sax</a>.  <a href="classnlohmann_1_1basic__json.html#a164b1094a1a9feb54e400d8510bb0b12">More...</a><br /></td></tr>
<tr class="separator:a164b1094a1a9feb54e400d8510bb0b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24086b03c5c063849df0307f78c41c54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a24086b03c5c063849df0307f78c41c54">parse_event_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1a">detail::parse_event_t</a></td></tr>
<tr class="memdesc:a24086b03c5c063849df0307f78c41c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser event types  <a href="classnlohmann_1_1basic__json.html#a24086b03c5c063849df0307f78c41c54">More...</a><br /></td></tr>
<tr class="separator:a24086b03c5c063849df0307f78c41c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0273d074462644e5d5a7ff313ad0d742"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> = <a class="el" href="namespacenlohmann_1_1detail.html#a9980144ad77e50ae944d1fe797ceec08">detail::parser_callback_t</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a0273d074462644e5d5a7ff313ad0d742"><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element parser callback type  <a href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">More...</a><br /></td></tr>
<tr class="separator:a0273d074462644e5d5a7ff313ad0d742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a459dbfcd47bd632ca82ca8ff8db278c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a> () const noexcept</td></tr>
<tr class="separator:a459dbfcd47bd632ca82ca8ff8db278c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc55e7dca1a243b0d5011564824c0267"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#afc55e7dca1a243b0d5011564824c0267">get_allocator</a> ()</td></tr>
<tr class="memdesc:afc55e7dca1a243b0d5011564824c0267"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the allocator associated with the container  <a href="classnlohmann_1_1basic__json.html#afc55e7dca1a243b0d5011564824c0267">More...</a><br /></td></tr>
<tr class="separator:afc55e7dca1a243b0d5011564824c0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b4f65014f6c2b8b2832847d44bbd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a351b4f65014f6c2b8b2832847d44bbd7">meta</a> ()</td></tr>
<tr class="separator:a351b4f65014f6c2b8b2832847d44bbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplParams" colspan="2">template&lt;detail::value_t &gt; </td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6275ed57bae6866cdf5db5370a7ad47c">detail::external_constructor</a></td></tr>
<tr class="separator:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType &gt; </td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac8f3125911eb018ef4ab00d879487baf">::nlohmann::detail::parser</a></td></tr>
<tr class="separator:ac8f3125911eb018ef4ab00d879487baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a842e5c7ca096025c18b11e715d3401f4">::nlohmann::detail::iter_impl</a></td></tr>
<tr class="separator:a842e5c7ca096025c18b11e715d3401f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CharType &gt; </td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a69d491bbda88ade6d3c7a2b11309e8bf">::nlohmann::detail::binary_writer</a></td></tr>
<tr class="separator:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa226ed5103dfd10e27e562d35a3a106b">::nlohmann::detail::binary_reader</a></td></tr>
<tr class="separator:aa226ed5103dfd10e27e562d35a3a106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a47aabb1eceae32e8a6e8e7f0ff34be60">::nlohmann::detail::json_sax_dom_parser</a></td></tr>
<tr class="separator:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a95574da8d12905ea99dc348934c837da">::nlohmann::detail::json_sax_dom_callback_parser</a></td></tr>
<tr class="separator:a95574da8d12905ea99dc348934c837da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">exceptions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp19ad27801b95bd1f2c6c2bf83dbb7515"></a>Classes to implement user-defined exceptions. </p>
</td></tr>
<tr class="memitem:a14824c27188d2fee4861806cd5f23d22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a14824c27188d2fee4861806cd5f23d22">exception</a> = <a class="el" href="classnlohmann_1_1detail_1_1exception.html">detail::exception</a></td></tr>
<tr class="separator:a14824c27188d2fee4861806cd5f23d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555b05e9da63d486126759922685a37a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a555b05e9da63d486126759922685a37a">parse_error</a> = <a class="el" href="classnlohmann_1_1detail_1_1parse__error.html">detail::parse_error</a></td></tr>
<tr class="separator:a555b05e9da63d486126759922685a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccc9788413fd58de998fe92743cb4aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6ccc9788413fd58de998fe92743cb4aa">invalid_iterator</a> = <a class="el" href="classnlohmann_1_1detail_1_1invalid__iterator.html">detail::invalid_iterator</a></td></tr>
<tr class="separator:a6ccc9788413fd58de998fe92743cb4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5bf851eafe85bd6332f978991bc11c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ace5bf851eafe85bd6332f978991bc11c">type_error</a> = <a class="el" href="classnlohmann_1_1detail_1_1type__error.html">detail::type_error</a></td></tr>
<tr class="separator:ace5bf851eafe85bd6332f978991bc11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2251d8523fa6d16c0fba6388ffa2ef8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a2251d8523fa6d16c0fba6388ffa2ef8c">out_of_range</a> = <a class="el" href="classnlohmann_1_1detail_1_1out__of__range.html">detail::out_of_range</a></td></tr>
<tr class="separator:a2251d8523fa6d16c0fba6388ffa2ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc373c99facc37aadbc5651b3d6631d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6fc373c99facc37aadbc5651b3d6631d">other_error</a> = <a class="el" href="classnlohmann_1_1detail_1_1other__error.html">detail::other_error</a></td></tr>
<tr class="separator:a6fc373c99facc37aadbc5651b3d6631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">container types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6618fa684bc6d5a05e2c88bfff1c0d66"></a>The canonic container types to use <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> like any other STL container. </p>
</td></tr>
<tr class="memitem:a57c816a20c1d3ccc9bbc2972829da847"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a> = <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
<tr class="memdesc:a57c816a20c1d3ccc9bbc2972829da847"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of elements in a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container  <a href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">More...</a><br /></td></tr>
<tr class="separator:a57c816a20c1d3ccc9bbc2972829da847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ae98554a76205fb7f8822d36b2d5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> = <a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a> &amp;</td></tr>
<tr class="memdesc:a220ae98554a76205fb7f8822d36b2d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element reference  <a href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">More...</a><br /></td></tr>
<tr class="separator:a220ae98554a76205fb7f8822d36b2d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a1c33ee7b154fc41ca2545aa9724e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> = const <a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a> &amp;</td></tr>
<tr class="memdesc:ab8a1c33ee7b154fc41ca2545aa9724e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const reference  <a href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">More...</a><br /></td></tr>
<tr class="separator:ab8a1c33ee7b154fc41ca2545aa9724e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d20d11e5dfe95084a76f62eca54fadd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a3d20d11e5dfe95084a76f62eca54fadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent differences between iterators  <a href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">More...</a><br /></td></tr>
<tr class="separator:a3d20d11e5dfe95084a76f62eca54fadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ada29bca70b4965f6fd37ec1c8f85f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a3ada29bca70b4965f6fd37ec1c8f85f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent container sizes  <a href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">More...</a><br /></td></tr>
<tr class="separator:a3ada29bca70b4965f6fd37ec1c8f85f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38ae80f1e99d4b1f33c99fea4611457"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a> = AllocatorType&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:ad38ae80f1e99d4b1f33c99fea4611457"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type  <a href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">More...</a><br /></td></tr>
<tr class="separator:ad38ae80f1e99d4b1f33c99fea4611457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e5c23402f4c2e1df487e1d102bc5fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a42e5c23402f4c2e1df487e1d102bc5fa">pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a42e5c23402f4c2e1df487e1d102bc5fa">pointer</a></td></tr>
<tr class="memdesc:a42e5c23402f4c2e1df487e1d102bc5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element pointer  <a href="classnlohmann_1_1basic__json.html#a42e5c23402f4c2e1df487e1d102bc5fa">More...</a><br /></td></tr>
<tr class="separator:a42e5c23402f4c2e1df487e1d102bc5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4108c5148f1d7cf13c2681e22f141a10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4108c5148f1d7cf13c2681e22f141a10">const_pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a4108c5148f1d7cf13c2681e22f141a10">const_pointer</a></td></tr>
<tr class="memdesc:a4108c5148f1d7cf13c2681e22f141a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const pointer  <a href="classnlohmann_1_1basic__json.html#a4108c5148f1d7cf13c2681e22f141a10">More...</a><br /></td></tr>
<tr class="separator:a4108c5148f1d7cf13c2681e22f141a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa549b2b382916b3baafb526e5cb410bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> = <a class="el" href="classnlohmann_1_1detail_1_1iter__impl.html">iter_impl</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:aa549b2b382916b3baafb526e5cb410bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container  <a href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">More...</a><br /></td></tr>
<tr class="separator:aa549b2b382916b3baafb526e5cb410bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd2cfa7e4ded4e97cde9269bfeeea38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> = <a class="el" href="classnlohmann_1_1detail_1_1iter__impl.html">iter_impl</a>&lt; const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:aebd2cfa7e4ded4e97cde9269bfeeea38"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container  <a href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">More...</a><br /></td></tr>
<tr class="separator:aebd2cfa7e4ded4e97cde9269bfeeea38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8c0ebedd920b507f4f7ff4e19bf3c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a> = <a class="el" href="classnlohmann_1_1detail_1_1json__reverse__iterator.html">json_reverse_iterator</a>&lt; typename <a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">basic_json::iterator</a> &gt;</td></tr>
<tr class="memdesc:a5b8c0ebedd920b507f4f7ff4e19bf3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reverse iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container  <a href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">More...</a><br /></td></tr>
<tr class="separator:a5b8c0ebedd920b507f4f7ff4e19bf3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dba16ed9ee97380aeb17a207dd919a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> = <a class="el" href="classnlohmann_1_1detail_1_1json__reverse__iterator.html">json_reverse_iterator</a>&lt; typename <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">basic_json::const_iterator</a> &gt;</td></tr>
<tr class="memdesc:aa7dba16ed9ee97380aeb17a207dd919a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const reverse iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container  <a href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">More...</a><br /></td></tr>
<tr class="separator:aa7dba16ed9ee97380aeb17a207dd919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON value data types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbddfba6d49869d59bfd397e65b8cba87"></a>The data types to store a JSON value. These types are derived from the template arguments passed to class <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>. </p>
</td></tr>
<tr class="memitem:ac26c2e8d6bcaccde372ceedd81851200"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac26c2e8d6bcaccde372ceedd81851200">object_comparator_t</a> = std::less&lt; StringType &gt;</td></tr>
<tr class="memdesc:ac26c2e8d6bcaccde372ceedd81851200"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <a href="classnlohmann_1_1basic__json.html#ac26c2e8d6bcaccde372ceedd81851200">More...</a><br /></td></tr>
<tr class="separator:ac26c2e8d6bcaccde372ceedd81851200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3ff5a73597850597d1d40db9edd376"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a> = ObjectType&lt; StringType, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>, <a class="el" href="classnlohmann_1_1basic__json.html#ac26c2e8d6bcaccde372ceedd81851200">object_comparator_t</a>, AllocatorType&lt; std::pair&lt; const StringType, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:aef3ff5a73597850597d1d40db9edd376"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <a href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">More...</a><br /></td></tr>
<tr class="separator:aef3ff5a73597850597d1d40db9edd376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858c1cf8407bc06494e3a1114a3b73e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> = ArrayType&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>, AllocatorType&lt; <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a858c1cf8407bc06494e3a1114a3b73e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an array  <a href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">More...</a><br /></td></tr>
<tr class="separator:a858c1cf8407bc06494e3a1114a3b73e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33593865ffb1860323dcbd52425b90c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> = StringType</td></tr>
<tr class="memdesc:a33593865ffb1860323dcbd52425b90c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a string  <a href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">More...</a><br /></td></tr>
<tr class="separator:a33593865ffb1860323dcbd52425b90c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fd1a12c9c54623c942b430e7a72937"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a44fd1a12c9c54623c942b430e7a72937">boolean_t</a> = BooleanType</td></tr>
<tr class="memdesc:a44fd1a12c9c54623c942b430e7a72937"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a boolean  <a href="classnlohmann_1_1basic__json.html#a44fd1a12c9c54623c942b430e7a72937">More...</a><br /></td></tr>
<tr class="separator:a44fd1a12c9c54623c942b430e7a72937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e390944da90db83089eb2426a749d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a> = NumberIntegerType</td></tr>
<tr class="memdesc:a11e390944da90db83089eb2426a749d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (integer)  <a href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">More...</a><br /></td></tr>
<tr class="separator:a11e390944da90db83089eb2426a749d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09af9c23351b7245d9be4d1b2035fef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> = NumberUnsignedType</td></tr>
<tr class="memdesc:ae09af9c23351b7245d9be4d1b2035fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (unsigned)  <a href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">More...</a><br /></td></tr>
<tr class="separator:ae09af9c23351b7245d9be4d1b2035fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8abaebd922d82d69756327c0c347e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> = NumberFloatType</td></tr>
<tr class="memdesc:a5b8abaebd922d82d69756327c0c347e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (floating-point)  <a href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">More...</a><br /></td></tr>
<tr class="separator:a5b8abaebd922d82d69756327c0c347e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c955145bebde84d93991ffed7cd389"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> = <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html">nlohmann::byte_container_with_subtype</a>&lt; BinaryType &gt;</td></tr>
<tr class="memdesc:ad6c955145bebde84d93991ffed7cd389"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a packed binary type  <a href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">More...</a><br /></td></tr>
<tr class="separator:ad6c955145bebde84d93991ffed7cd389"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">modifiers</h2></td></tr>
<tr class="memitem:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> left, <a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> right) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a>)</td></tr>
<tr class="memdesc:aee0ae36cbfb0336832ebc0374c3c7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">More...</a><br /></td></tr>
<tr class="separator:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946cc8f30d8b1d6609b57387b647fe53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a946cc8f30d8b1d6609b57387b647fe53">clear</a> () noexcept</td></tr>
<tr class="memdesc:a946cc8f30d8b1d6609b57387b647fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a946cc8f30d8b1d6609b57387b647fe53">More...</a><br /></td></tr>
<tr class="separator:a946cc8f30d8b1d6609b57387b647fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0253c92736db021840105d374c4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ab9e0253c92736db021840105d374c4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">More...</a><br /></td></tr>
<tr class="separator:ab9e0253c92736db021840105d374c4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40226d9c84fcb9cb948ae0c27b842c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a40226d9c84fcb9cb948ae0c27b842c57">operator+=</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a40226d9c84fcb9cb948ae0c27b842c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a40226d9c84fcb9cb948ae0c27b842c57">More...</a><br /></td></tr>
<tr class="separator:a40226d9c84fcb9cb948ae0c27b842c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405d38087e13994a5a4556065b0be6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3405d38087e13994a5a4556065b0be6d">push_back</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a3405d38087e13994a5a4556065b0be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a3405d38087e13994a5a4556065b0be6d">More...</a><br /></td></tr>
<tr class="separator:a3405d38087e13994a5a4556065b0be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643a4baa91f484b11af0e4437183115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#af643a4baa91f484b11af0e4437183115">operator+=</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:af643a4baa91f484b11af0e4437183115"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#af643a4baa91f484b11af0e4437183115">More...</a><br /></td></tr>
<tr class="separator:af643a4baa91f484b11af0e4437183115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad704839e6a5195e3b76f22e2b9aa63ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad704839e6a5195e3b76f22e2b9aa63ee">push_back</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:ad704839e6a5195e3b76f22e2b9aa63ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#ad704839e6a5195e3b76f22e2b9aa63ee">More...</a><br /></td></tr>
<tr class="separator:ad704839e6a5195e3b76f22e2b9aa63ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae300819781bce2193369609457f70f30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ae300819781bce2193369609457f70f30">operator+=</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:ae300819781bce2193369609457f70f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classnlohmann_1_1basic__json.html#ae300819781bce2193369609457f70f30">More...</a><br /></td></tr>
<tr class="separator:ae300819781bce2193369609457f70f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4567cf75f19b1efca090f75d7a8a350a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4567cf75f19b1efca090f75d7a8a350a">push_back</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:a4567cf75f19b1efca090f75d7a8a350a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a4567cf75f19b1efca090f75d7a8a350a">More...</a><br /></td></tr>
<tr class="separator:a4567cf75f19b1efca090f75d7a8a350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48302a8b4f8c2a6e30c2a7bff6abc49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac48302a8b4f8c2a6e30c2a7bff6abc49">operator+=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:ac48302a8b4f8c2a6e30c2a7bff6abc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classnlohmann_1_1basic__json.html#ac48302a8b4f8c2a6e30c2a7bff6abc49">More...</a><br /></td></tr>
<tr class="separator:ac48302a8b4f8c2a6e30c2a7bff6abc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c0a5db4fb12d49433801bbe6436bfb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a15c0a5db4fb12d49433801bbe6436bfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a15c0a5db4fb12d49433801bbe6436bfb">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a15c0a5db4fb12d49433801bbe6436bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a15c0a5db4fb12d49433801bbe6436bfb">More...</a><br /></td></tr>
<tr class="separator:a15c0a5db4fb12d49433801bbe6436bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac479e609cbd03948bd3e85fb441b66e5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac479e609cbd03948bd3e85fb441b66e5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac479e609cbd03948bd3e85fb441b66e5">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac479e609cbd03948bd3e85fb441b66e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#ac479e609cbd03948bd3e85fb441b66e5">More...</a><br /></td></tr>
<tr class="separator:ac479e609cbd03948bd3e85fb441b66e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c8034e997c5b852b92bdc6a3f70994"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab5c8034e997c5b852b92bdc6a3f70994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">insert_iterator</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab5c8034e997c5b852b92bdc6a3f70994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb86e8478e20d95970a8b61ff01dce3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aeb86e8478e20d95970a8b61ff01dce3b">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:aeb86e8478e20d95970a8b61ff01dce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#aeb86e8478e20d95970a8b61ff01dce3b">More...</a><br /></td></tr>
<tr class="separator:aeb86e8478e20d95970a8b61ff01dce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5b9de8a4a759861cb600b38a6c81b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9c5b9de8a4a759861cb600b38a6c81b1">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a9c5b9de8a4a759861cb600b38a6c81b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element  <a href="classnlohmann_1_1basic__json.html#a9c5b9de8a4a759861cb600b38a6c81b1">More...</a><br /></td></tr>
<tr class="separator:a9c5b9de8a4a759861cb600b38a6c81b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e197e6cc78c3960011f68a75f8ef22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a71e197e6cc78c3960011f68a75f8ef22">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, <a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> cnt, const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a71e197e6cc78c3960011f68a75f8ef22"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a71e197e6cc78c3960011f68a75f8ef22">More...</a><br /></td></tr>
<tr class="separator:a71e197e6cc78c3960011f68a75f8ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8137d5471edcd71606e42155ed9c23e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a8137d5471edcd71606e42155ed9c23e2">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> first, <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> last)</td></tr>
<tr class="memdesc:a8137d5471edcd71606e42155ed9c23e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a8137d5471edcd71606e42155ed9c23e2">More...</a><br /></td></tr>
<tr class="separator:a8137d5471edcd71606e42155ed9c23e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b8764efd21dac4205a00fec82e09a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a856b8764efd21dac4205a00fec82e09a">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> pos, <a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> ilist)</td></tr>
<tr class="memdesc:a856b8764efd21dac4205a00fec82e09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a856b8764efd21dac4205a00fec82e09a">More...</a><br /></td></tr>
<tr class="separator:a856b8764efd21dac4205a00fec82e09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0181d03c6314bedcbad2e92d3676223c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0181d03c6314bedcbad2e92d3676223c">insert</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> first, <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> last)</td></tr>
<tr class="memdesc:a0181d03c6314bedcbad2e92d3676223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a0181d03c6314bedcbad2e92d3676223c">More...</a><br /></td></tr>
<tr class="separator:a0181d03c6314bedcbad2e92d3676223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377819905d567f6f523dcbc592cb6356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a377819905d567f6f523dcbc592cb6356">update</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> j)</td></tr>
<tr class="memdesc:a377819905d567f6f523dcbc592cb6356"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a377819905d567f6f523dcbc592cb6356">More...</a><br /></td></tr>
<tr class="separator:a377819905d567f6f523dcbc592cb6356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e5f668474280acc9bd7f5410b9392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9f9e5f668474280acc9bd7f5410b9392">update</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> first, <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> last)</td></tr>
<tr class="memdesc:a9f9e5f668474280acc9bd7f5410b9392"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a9f9e5f668474280acc9bd7f5410b9392">More...</a><br /></td></tr>
<tr class="separator:a9f9e5f668474280acc9bd7f5410b9392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94295a06e0e7b3867fe83afbee4cb202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a>)</td></tr>
<tr class="memdesc:a94295a06e0e7b3867fe83afbee4cb202"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">More...</a><br /></td></tr>
<tr class="separator:a94295a06e0e7b3867fe83afbee4cb202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76126242de262f6d38cadda19e0d13e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a76126242de262f6d38cadda19e0d13e1">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> &amp;other)</td></tr>
<tr class="memdesc:a76126242de262f6d38cadda19e0d13e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a76126242de262f6d38cadda19e0d13e1">More...</a><br /></td></tr>
<tr class="separator:a76126242de262f6d38cadda19e0d13e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b86bdcfc55557dacc36969adb0417e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a57b86bdcfc55557dacc36969adb0417e">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a> &amp;other)</td></tr>
<tr class="memdesc:a57b86bdcfc55557dacc36969adb0417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#a57b86bdcfc55557dacc36969adb0417e">More...</a><br /></td></tr>
<tr class="separator:a57b86bdcfc55557dacc36969adb0417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac916df9561daf4eaf2372119fe91899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aac916df9561daf4eaf2372119fe91899">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> &amp;other)</td></tr>
<tr class="memdesc:aac916df9561daf4eaf2372119fe91899"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#aac916df9561daf4eaf2372119fe91899">More...</a><br /></td></tr>
<tr class="separator:aac916df9561daf4eaf2372119fe91899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa242e339ebc7583e114f2167a83f8c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa242e339ebc7583e114f2167a83f8c90">swap</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> &amp;other)</td></tr>
<tr class="memdesc:aa242e339ebc7583e114f2167a83f8c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classnlohmann_1_1basic__json.html#aa242e339ebc7583e114f2167a83f8c90">More...</a><br /></td></tr>
<tr class="separator:aa242e339ebc7583e114f2167a83f8c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749a1f5091a5e63ccfe919e0aef986af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a749a1f5091a5e63ccfe919e0aef986af">swap</a> (typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;other)</td></tr>
<tr class="separator:a749a1f5091a5e63ccfe919e0aef986af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lexicographical comparison operators</h2></td></tr>
<tr class="memitem:a122640e7e2db1814fc7bbb3c122ec76e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a122640e7e2db1814fc7bbb3c122ec76e">operator==</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a122640e7e2db1814fc7bbb3c122ec76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#a122640e7e2db1814fc7bbb3c122ec76e">More...</a><br /></td></tr>
<tr class="separator:a122640e7e2db1814fc7bbb3c122ec76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba21440ea1aff44f718285ed7d6d20d9"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aba21440ea1aff44f718285ed7d6d20d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aba21440ea1aff44f718285ed7d6d20d9">operator==</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:aba21440ea1aff44f718285ed7d6d20d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#aba21440ea1aff44f718285ed7d6d20d9">More...</a><br /></td></tr>
<tr class="separator:aba21440ea1aff44f718285ed7d6d20d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef302e3ae215e46e5035d0e4fdf47235"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aef302e3ae215e46e5035d0e4fdf47235"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aef302e3ae215e46e5035d0e4fdf47235">operator==</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:aef302e3ae215e46e5035d0e4fdf47235"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#aef302e3ae215e46e5035d0e4fdf47235">More...</a><br /></td></tr>
<tr class="separator:aef302e3ae215e46e5035d0e4fdf47235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2e21da48f5d9471716cd868a068327"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6e2e21da48f5d9471716cd868a068327">operator!=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a6e2e21da48f5d9471716cd868a068327"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#a6e2e21da48f5d9471716cd868a068327">More...</a><br /></td></tr>
<tr class="separator:a6e2e21da48f5d9471716cd868a068327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefc38fc08bdb7a9a7474b5ab4a1140f"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:afefc38fc08bdb7a9a7474b5ab4a1140f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#afefc38fc08bdb7a9a7474b5ab4a1140f">operator!=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:afefc38fc08bdb7a9a7474b5ab4a1140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: not equal  <a href="classnlohmann_1_1basic__json.html#afefc38fc08bdb7a9a7474b5ab4a1140f">More...</a><br /></td></tr>
<tr class="separator:afefc38fc08bdb7a9a7474b5ab4a1140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e886db6e9fa91ff9fd853333fed05b"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab0e886db6e9fa91ff9fd853333fed05b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab0e886db6e9fa91ff9fd853333fed05b">operator!=</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:ab0e886db6e9fa91ff9fd853333fed05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: not equal  <a href="classnlohmann_1_1basic__json.html#ab0e886db6e9fa91ff9fd853333fed05b">More...</a><br /></td></tr>
<tr class="separator:ab0e886db6e9fa91ff9fd853333fed05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd442b66140c764c594ac8ad7dfd5b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aacd442b66140c764c594ac8ad7dfd5b3">operator&lt;</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:aacd442b66140c764c594ac8ad7dfd5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#aacd442b66140c764c594ac8ad7dfd5b3">More...</a><br /></td></tr>
<tr class="separator:aacd442b66140c764c594ac8ad7dfd5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7999ee3a69a4979d92e98ab1e88c8759"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7999ee3a69a4979d92e98ab1e88c8759"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a7999ee3a69a4979d92e98ab1e88c8759">operator&lt;</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:a7999ee3a69a4979d92e98ab1e88c8759"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: less than  <a href="classnlohmann_1_1basic__json.html#a7999ee3a69a4979d92e98ab1e88c8759">More...</a><br /></td></tr>
<tr class="separator:a7999ee3a69a4979d92e98ab1e88c8759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed3e9b4ab75f5bcbd3cd20f5af5cdab"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:abed3e9b4ab75f5bcbd3cd20f5af5cdab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#abed3e9b4ab75f5bcbd3cd20f5af5cdab">operator&lt;</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:abed3e9b4ab75f5bcbd3cd20f5af5cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: less than  <a href="classnlohmann_1_1basic__json.html#abed3e9b4ab75f5bcbd3cd20f5af5cdab">More...</a><br /></td></tr>
<tr class="separator:abed3e9b4ab75f5bcbd3cd20f5af5cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8bb5200f5eac10d31e26be46e5b1ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5c8bb5200f5eac10d31e26be46e5b1ac">operator&lt;=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a5c8bb5200f5eac10d31e26be46e5b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#a5c8bb5200f5eac10d31e26be46e5b1ac">More...</a><br /></td></tr>
<tr class="separator:a5c8bb5200f5eac10d31e26be46e5b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e368211047f725f333696aefdf39ffd"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7e368211047f725f333696aefdf39ffd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a7e368211047f725f333696aefdf39ffd">operator&lt;=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:a7e368211047f725f333696aefdf39ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: less than or equal  <a href="classnlohmann_1_1basic__json.html#a7e368211047f725f333696aefdf39ffd">More...</a><br /></td></tr>
<tr class="separator:a7e368211047f725f333696aefdf39ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73f88f70fe5acfa521750a8cd710026"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ad73f88f70fe5acfa521750a8cd710026"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad73f88f70fe5acfa521750a8cd710026">operator&lt;=</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:ad73f88f70fe5acfa521750a8cd710026"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: less than or equal  <a href="classnlohmann_1_1basic__json.html#ad73f88f70fe5acfa521750a8cd710026">More...</a><br /></td></tr>
<tr class="separator:ad73f88f70fe5acfa521750a8cd710026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87db51b6b936fb2ea293cdbc8702dcb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a87db51b6b936fb2ea293cdbc8702dcb8">operator&gt;</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a87db51b6b936fb2ea293cdbc8702dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#a87db51b6b936fb2ea293cdbc8702dcb8">More...</a><br /></td></tr>
<tr class="separator:a87db51b6b936fb2ea293cdbc8702dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412895af9a582869a4d369a64fb1b6d6"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a412895af9a582869a4d369a64fb1b6d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a412895af9a582869a4d369a64fb1b6d6">operator&gt;</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:a412895af9a582869a4d369a64fb1b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: greater than  <a href="classnlohmann_1_1basic__json.html#a412895af9a582869a4d369a64fb1b6d6">More...</a><br /></td></tr>
<tr class="separator:a412895af9a582869a4d369a64fb1b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124c319566198d9f092c5bebea46ce77"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a124c319566198d9f092c5bebea46ce77"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a124c319566198d9f092c5bebea46ce77">operator&gt;</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a124c319566198d9f092c5bebea46ce77"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: greater than  <a href="classnlohmann_1_1basic__json.html#a124c319566198d9f092c5bebea46ce77">More...</a><br /></td></tr>
<tr class="separator:a124c319566198d9f092c5bebea46ce77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a943800c7f103d0990d7eef82c6453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a74a943800c7f103d0990d7eef82c6453">operator&gt;=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a74a943800c7f103d0990d7eef82c6453"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: equal  <a href="classnlohmann_1_1basic__json.html#a74a943800c7f103d0990d7eef82c6453">More...</a><br /></td></tr>
<tr class="separator:a74a943800c7f103d0990d7eef82c6453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e3a92b3d9be1faa05c92d096299189"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a68e3a92b3d9be1faa05c92d096299189"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a68e3a92b3d9be1faa05c92d096299189">operator&gt;=</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> lhs, const ScalarType rhs) noexcept</td></tr>
<tr class="memdesc:a68e3a92b3d9be1faa05c92d096299189"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: greater than or equal  <a href="classnlohmann_1_1basic__json.html#a68e3a92b3d9be1faa05c92d096299189">More...</a><br /></td></tr>
<tr class="separator:a68e3a92b3d9be1faa05c92d096299189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee0e3e8afc7cbd932d6ed66418fa80a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a5ee0e3e8afc7cbd932d6ed66418fa80a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5ee0e3e8afc7cbd932d6ed66418fa80a">operator&gt;=</a> (const ScalarType lhs, <a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> rhs) noexcept</td></tr>
<tr class="memdesc:a5ee0e3e8afc7cbd932d6ed66418fa80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison: greater than or equal  <a href="classnlohmann_1_1basic__json.html#a5ee0e3e8afc7cbd932d6ed66418fa80a">More...</a><br /></td></tr>
<tr class="separator:a5ee0e3e8afc7cbd932d6ed66418fa80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">serialization</h2></td></tr>
<tr class="memitem:a5e34c5435e557d0bf666bd7311211405"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5e34c5435e557d0bf666bd7311211405">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a5e34c5435e557d0bf666bd7311211405"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize to stream  <a href="classnlohmann_1_1basic__json.html#a5e34c5435e557d0bf666bd7311211405">More...</a><br /></td></tr>
<tr class="separator:a5e34c5435e557d0bf666bd7311211405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d6a60dd99e9f33b8273a1c8db5669b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a34d6a60dd99e9f33b8273a1c8db5669b">operator&gt;&gt;</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, std::ostream &amp;o)</td></tr>
<tr class="memdesc:a34d6a60dd99e9f33b8273a1c8db5669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize to stream  <a href="classnlohmann_1_1basic__json.html#a34d6a60dd99e9f33b8273a1c8db5669b">More...</a><br /></td></tr>
<tr class="separator:a34d6a60dd99e9f33b8273a1c8db5669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">deserialization</h2></td></tr>
<tr class="memitem:a60ca396028b8d9714c6e10efbf475af6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a60ca396028b8d9714c6e10efbf475af6">operator&lt;&lt;</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, std::istream &amp;i)</td></tr>
<tr class="memdesc:a60ca396028b8d9714c6e10efbf475af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a60ca396028b8d9714c6e10efbf475af6">More...</a><br /></td></tr>
<tr class="separator:a60ca396028b8d9714c6e10efbf475af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf363408931d76472ded14017e59c9e8"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aaf363408931d76472ded14017e59c9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">More...</a><br /></td></tr>
<tr class="separator:aaf363408931d76472ded14017e59c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15018ade392a844ea32d5188d1a0b9c6"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a15018ade392a844ea32d5188d1a0b9c6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a15018ade392a844ea32d5188d1a0b9c6">parse</a> (InputType &amp;&amp;i, const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a15018ade392a844ea32d5188d1a0b9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a15018ade392a844ea32d5188d1a0b9c6">More...</a><br /></td></tr>
<tr class="separator:a15018ade392a844ea32d5188d1a0b9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad832c70af0989389a9a104c21d2d1c5c"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:ad832c70af0989389a9a104c21d2d1c5c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad832c70af0989389a9a104c21d2d1c5c">parse</a> (IteratorType first, IteratorType last, const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:ad832c70af0989389a9a104c21d2d1c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from a pair of character iterators  <a href="classnlohmann_1_1basic__json.html#ad832c70af0989389a9a104c21d2d1c5c">More...</a><br /></td></tr>
<tr class="separator:ad832c70af0989389a9a104c21d2d1c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cf15644f04fa569f50291049d1bafd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a73cf15644f04fa569f50291049d1bafd">parse</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a73cf15644f04fa569f50291049d1bafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a73cf15644f04fa569f50291049d1bafd">More...</a><br /></td></tr>
<tr class="separator:a73cf15644f04fa569f50291049d1bafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32872afe5bfd040777e3e2bb85f0ca55"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a32872afe5bfd040777e3e2bb85f0ca55"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a32872afe5bfd040777e3e2bb85f0ca55">accept</a> (InputType &amp;&amp;i, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a32872afe5bfd040777e3e2bb85f0ca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a32872afe5bfd040777e3e2bb85f0ca55">More...</a><br /></td></tr>
<tr class="separator:a32872afe5bfd040777e3e2bb85f0ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fb596473649332185aedb0a8a6ccc5"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a47fb596473649332185aedb0a8a6ccc5"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a47fb596473649332185aedb0a8a6ccc5">accept</a> (IteratorType first, IteratorType last, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a47fb596473649332185aedb0a8a6ccc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a47fb596473649332185aedb0a8a6ccc5">More...</a><br /></td></tr>
<tr class="separator:a47fb596473649332185aedb0a8a6ccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e85910b91d02f6807b69b61690a4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6d9e85910b91d02f6807b69b61690a4b">accept</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a6d9e85910b91d02f6807b69b61690a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a6d9e85910b91d02f6807b69b61690a4b">More...</a><br /></td></tr>
<tr class="separator:a6d9e85910b91d02f6807b69b61690a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b382c6407da5543827ce4b24bb5008"><td class="memTemplParams" colspan="2">template&lt;typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:a12b382c6407da5543827ce4b24bb5008"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a12b382c6407da5543827ce4b24bb5008">sax_parse</a> (InputType &amp;&amp;i, SAX *sax, <a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a12b382c6407da5543827ce4b24bb5008"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#a12b382c6407da5543827ce4b24bb5008">More...</a><br /></td></tr>
<tr class="separator:a12b382c6407da5543827ce4b24bb5008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62241c2694a054818edf2f66d72f113"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , class SAX &gt; </td></tr>
<tr class="memitem:ab62241c2694a054818edf2f66d72f113"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab62241c2694a054818edf2f66d72f113">sax_parse</a> (IteratorType first, IteratorType last, SAX *sax, <a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:ab62241c2694a054818edf2f66d72f113"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#ab62241c2694a054818edf2f66d72f113">More...</a><br /></td></tr>
<tr class="separator:ab62241c2694a054818edf2f66d72f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ef0a817ecde8bf270653e8706c150"><td class="memTemplParams" colspan="2">template&lt;typename SAX &gt; </td></tr>
<tr class="memitem:aef9ef0a817ecde8bf270653e8706c150"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aef9ef0a817ecde8bf270653e8706c150">sax_parse</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, SAX *sax, <a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:aef9ef0a817ecde8bf270653e8706c150"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classnlohmann_1_1basic__json.html#aef9ef0a817ecde8bf270653e8706c150">More...</a><br /></td></tr>
<tr class="separator:aef9ef0a817ecde8bf270653e8706c150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">constructors and destructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd94b4d3d0135946bb7bdf25e48755337"></a>Constructors of class <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>, copy/move constructor, copy assignment, static functions creating objects, and the destructor. </p>
</td></tr>
<tr class="memitem:a3d255dbe024ce2d0fdfb1b4837629091"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091">binary</a> (const typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;init)</td></tr>
<tr class="memdesc:a3d255dbe024ce2d0fdfb1b4837629091"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091">More...</a><br /></td></tr>
<tr class="separator:a3d255dbe024ce2d0fdfb1b4837629091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2c506b279049f7d92ad7ae10a2f12b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#acd2c506b279049f7d92ad7ae10a2f12b">binary</a> (const typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;init, std::uint8_t subtype)</td></tr>
<tr class="memdesc:acd2c506b279049f7d92ad7ae10a2f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classnlohmann_1_1basic__json.html#acd2c506b279049f7d92ad7ae10a2f12b">More...</a><br /></td></tr>
<tr class="separator:acd2c506b279049f7d92ad7ae10a2f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab085777bbfbfac5a472120b991ef5cf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab085777bbfbfac5a472120b991ef5cf3">binary</a> (typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&amp;init)</td></tr>
<tr class="memdesc:ab085777bbfbfac5a472120b991ef5cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#ab085777bbfbfac5a472120b991ef5cf3">More...</a><br /></td></tr>
<tr class="separator:ab085777bbfbfac5a472120b991ef5cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012e375f4016b89444c528ed46cce3af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a012e375f4016b89444c528ed46cce3af">binary</a> (typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&amp;init, std::uint8_t subtype)</td></tr>
<tr class="memdesc:a012e375f4016b89444c528ed46cce3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classnlohmann_1_1basic__json.html#a012e375f4016b89444c528ed46cce3af">More...</a><br /></td></tr>
<tr class="separator:a012e375f4016b89444c528ed46cce3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8d8f5741aedadac8f3bffd8f2ce13e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a2c8d8f5741aedadac8f3bffd8f2ce13e">array</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a2c8d8f5741aedadac8f3bffd8f2ce13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a2c8d8f5741aedadac8f3bffd8f2ce13e">More...</a><br /></td></tr>
<tr class="separator:a2c8d8f5741aedadac8f3bffd8f2ce13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4df356e05415438fadf8a15e583903"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903">object</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a9a4df356e05415438fadf8a15e583903"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903">More...</a><br /></td></tr>
<tr class="separator:a9a4df356e05415438fadf8a15e583903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19734fbc9c97d536832892ddacd6b62a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> (const <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> v)</td></tr>
<tr class="memdesc:a19734fbc9c97d536832892ddacd6b62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">More...</a><br /></td></tr>
<tr class="separator:a19734fbc9c97d536832892ddacd6b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6fbaf6c64f60b61922b5c9d3e61aa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ace6fbaf6c64f60b61922b5c9d3e61aa6">basic_json</a> (std::nullptr_t=nullptr) noexcept</td></tr>
<tr class="memdesc:ace6fbaf6c64f60b61922b5c9d3e61aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#ace6fbaf6c64f60b61922b5c9d3e61aa6">More...</a><br /></td></tr>
<tr class="separator:ace6fbaf6c64f60b61922b5c9d3e61aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5d76a1546257689ad260ed34ec20b5"><td class="memTemplParams" colspan="2">template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1b5d76a1546257689ad260ed34ec20b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a1b5d76a1546257689ad260ed34ec20b5">basic_json</a> (CompatibleType &amp;&amp;val) noexcept(noexcept(JSONSerializer&lt; U &gt;::to_json(std::declval&lt; basic_json_t &amp; &gt;(), std::forward&lt; CompatibleType &gt;(val))))</td></tr>
<tr class="memdesc:a1b5d76a1546257689ad260ed34ec20b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a1b5d76a1546257689ad260ed34ec20b5">More...</a><br /></td></tr>
<tr class="separator:a1b5d76a1546257689ad260ed34ec20b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40738eb9cb8c5a9ca14ae4b697c29f8e"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a40738eb9cb8c5a9ca14ae4b697c29f8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a40738eb9cb8c5a9ca14ae4b697c29f8e">basic_json</a> (const BasicJsonType &amp;val)</td></tr>
<tr class="memdesc:a40738eb9cb8c5a9ca14ae4b697c29f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an existing one  <a href="classnlohmann_1_1basic__json.html#a40738eb9cb8c5a9ca14ae4b697c29f8e">More...</a><br /></td></tr>
<tr class="separator:a40738eb9cb8c5a9ca14ae4b697c29f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac617faf3448d6d2cb33a020be01d37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aeac617faf3448d6d2cb33a020be01d37">basic_json</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> init, bool type_deduction=true, <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> manual_type=<a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</td></tr>
<tr class="memdesc:aeac617faf3448d6d2cb33a020be01d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#aeac617faf3448d6d2cb33a020be01d37">More...</a><br /></td></tr>
<tr class="separator:aeac617faf3448d6d2cb33a020be01d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbccea367512a87b5d76e2bd92c5cc85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#afbccea367512a87b5d76e2bd92c5cc85">basic_json</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> cnt, const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:afbccea367512a87b5d76e2bd92c5cc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#afbccea367512a87b5d76e2bd92c5cc85">More...</a><br /></td></tr>
<tr class="separator:afbccea367512a87b5d76e2bd92c5cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e540f473d32f1cf5d3243ea3ad495e"><td class="memTemplParams" colspan="2">template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a23e540f473d32f1cf5d3243ea3ad495e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a23e540f473d32f1cf5d3243ea3ad495e">basic_json</a> (InputIT first, InputIT last)</td></tr>
<tr class="memdesc:a23e540f473d32f1cf5d3243ea3ad495e"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a23e540f473d32f1cf5d3243ea3ad495e">More...</a><br /></td></tr>
<tr class="separator:a23e540f473d32f1cf5d3243ea3ad495e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28524e9c443076ea6dccff8e391354ed"><td class="memTemplParams" colspan="2">template&lt;typename JsonRef , detail::enable_if_t&lt; detail::conjunction&lt; detail::is_json_ref&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, basic_json &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a28524e9c443076ea6dccff8e391354ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a28524e9c443076ea6dccff8e391354ed">basic_json</a> (const JsonRef &amp;ref)</td></tr>
<tr class="memdesc:a28524e9c443076ea6dccff8e391354ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a28524e9c443076ea6dccff8e391354ed">More...</a><br /></td></tr>
<tr class="separator:a28524e9c443076ea6dccff8e391354ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603be713183ad63dd8c9e1052c606004"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a603be713183ad63dd8c9e1052c606004">basic_json</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;other)</td></tr>
<tr class="memdesc:a603be713183ad63dd8c9e1052c606004"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a603be713183ad63dd8c9e1052c606004">More...</a><br /></td></tr>
<tr class="separator:a603be713183ad63dd8c9e1052c606004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642afd9d8886e0dedfc0d5cee2baf57f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a642afd9d8886e0dedfc0d5cee2baf57f">basic_json</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a642afd9d8886e0dedfc0d5cee2baf57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a642afd9d8886e0dedfc0d5cee2baf57f">More...</a><br /></td></tr>
<tr class="separator:a642afd9d8886e0dedfc0d5cee2baf57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae937c299f347a9dcb7f31a8e57762b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a1ae937c299f347a9dcb7f31a8e57762b">operator=</a> (<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a>)</td></tr>
<tr class="memdesc:a1ae937c299f347a9dcb7f31a8e57762b"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classnlohmann_1_1basic__json.html#a1ae937c299f347a9dcb7f31a8e57762b">More...</a><br /></td></tr>
<tr class="separator:a1ae937c299f347a9dcb7f31a8e57762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b643c02a19fa52f99db8215ff58e0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a60b643c02a19fa52f99db8215ff58e0f">~basic_json</a> () noexcept</td></tr>
<tr class="memdesc:a60b643c02a19fa52f99db8215ff58e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classnlohmann_1_1basic__json.html#a60b643c02a19fa52f99db8215ff58e0f">More...</a><br /></td></tr>
<tr class="separator:a60b643c02a19fa52f99db8215ff58e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">iterators</h2></td></tr>
<tr class="memitem:a22e2e5b0e68d9d7c63be2cada5187259"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a22e2e5b0e68d9d7c63be2cada5187259">iterator_wrapper</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> ref) noexcept</td></tr>
<tr class="separator:a22e2e5b0e68d9d7c63be2cada5187259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3710ff8c5a1cbedb4f75b700a8962d5c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3710ff8c5a1cbedb4f75b700a8962d5c">iterator_wrapper</a> (<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> ref) noexcept</td></tr>
<tr class="separator:a3710ff8c5a1cbedb4f75b700a8962d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b495b4c282e4afacf382f5b49af7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a23b495b4c282e4afacf382f5b49af7c7">begin</a> () noexcept</td></tr>
<tr class="separator:a23b495b4c282e4afacf382f5b49af7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f147be16fcde9f510c4aac89ab511c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4f147be16fcde9f510c4aac89ab511c9">begin</a> () const noexcept</td></tr>
<tr class="separator:a4f147be16fcde9f510c4aac89ab511c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae508c13e3ad6ce445bcaf24a2bc7d039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ae508c13e3ad6ce445bcaf24a2bc7d039">cbegin</a> () const noexcept</td></tr>
<tr class="separator:ae508c13e3ad6ce445bcaf24a2bc7d039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931267ec3f09eb67e4382f321b2c52bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a> () noexcept</td></tr>
<tr class="separator:a931267ec3f09eb67e4382f321b2c52bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b5b96f86879a3bac0c713d33178551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a82b5b96f86879a3bac0c713d33178551">end</a> () const noexcept</td></tr>
<tr class="separator:a82b5b96f86879a3bac0c713d33178551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3017cf0f1a4673e904e34cfef62e7758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">cend</a> () const noexcept</td></tr>
<tr class="separator:a3017cf0f1a4673e904e34cfef62e7758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e38cd973bc94557fa8d36433c0e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aff8e38cd973bc94557fa8d36433c0e4c">rbegin</a> () noexcept</td></tr>
<tr class="separator:aff8e38cd973bc94557fa8d36433c0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1329f44c8301b7679962726a043549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aab1329f44c8301b7679962726a043549">rbegin</a> () const noexcept</td></tr>
<tr class="separator:aab1329f44c8301b7679962726a043549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a328b29b290cc300345376c54f618cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a7a328b29b290cc300345376c54f618cb">rend</a> () noexcept</td></tr>
<tr class="separator:a7a328b29b290cc300345376c54f618cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4cbf41d593d41847b90aea55e5e84d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a2e4cbf41d593d41847b90aea55e5e84d">rend</a> () const noexcept</td></tr>
<tr class="separator:a2e4cbf41d593d41847b90aea55e5e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044298d189bdf7e4b36492de9811ddd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a044298d189bdf7e4b36492de9811ddd6">crbegin</a> () const noexcept</td></tr>
<tr class="separator:a044298d189bdf7e4b36492de9811ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223480466a0922267d680ec8f0722d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a223480466a0922267d680ec8f0722d58">crend</a> () const noexcept</td></tr>
<tr class="separator:a223480466a0922267d680ec8f0722d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916a6ba75ec7624e9c6c977a52d6fd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a916a6ba75ec7624e9c6c977a52d6fd17">items</a> () noexcept</td></tr>
<tr class="separator:a916a6ba75ec7624e9c6c977a52d6fd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faaed730a81347f2f01e93f37c73823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt; <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4faaed730a81347f2f01e93f37c73823">items</a> () const noexcept</td></tr>
<tr class="separator:a4faaed730a81347f2f01e93f37c73823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">binary serialization/deserialization support</h2></td></tr>
<tr class="memitem:adabcf74c9c868da3e04a5546b7705af4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adabcf74c9c868da3e04a5546b7705af4">to_cbor</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:adabcf74c9c868da3e04a5546b7705af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#adabcf74c9c868da3e04a5546b7705af4">More...</a><br /></td></tr>
<tr class="separator:adabcf74c9c868da3e04a5546b7705af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2becf604016783e5644eaa7782a08683"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a2becf604016783e5644eaa7782a08683">to_cbor</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt; o)</td></tr>
<tr class="memdesc:a2becf604016783e5644eaa7782a08683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a2becf604016783e5644eaa7782a08683">More...</a><br /></td></tr>
<tr class="separator:a2becf604016783e5644eaa7782a08683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5689672954fd3bc38f2f17e5607064c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5689672954fd3bc38f2f17e5607064c6">to_cbor</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a5689672954fd3bc38f2f17e5607064c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a5689672954fd3bc38f2f17e5607064c6">More...</a><br /></td></tr>
<tr class="separator:a5689672954fd3bc38f2f17e5607064c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b15bcaee410426b937eacc6e47d771"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a99b15bcaee410426b937eacc6e47d771">to_msgpack</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a99b15bcaee410426b937eacc6e47d771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a99b15bcaee410426b937eacc6e47d771">More...</a><br /></td></tr>
<tr class="separator:a99b15bcaee410426b937eacc6e47d771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fe46eda86f6f92c5599c20b6c81819"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa8fe46eda86f6f92c5599c20b6c81819">to_msgpack</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt; o)</td></tr>
<tr class="memdesc:aa8fe46eda86f6f92c5599c20b6c81819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#aa8fe46eda86f6f92c5599c20b6c81819">More...</a><br /></td></tr>
<tr class="separator:aa8fe46eda86f6f92c5599c20b6c81819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5dc0fca52131f3a634372120abfbe7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aca5dc0fca52131f3a634372120abfbe7">to_msgpack</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:aca5dc0fca52131f3a634372120abfbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#aca5dc0fca52131f3a634372120abfbe7">More...</a><br /></td></tr>
<tr class="separator:aca5dc0fca52131f3a634372120abfbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25355b9719db23b189fb5f6a8f4f16c4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a25355b9719db23b189fb5f6a8f4f16c4">to_ubjson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a25355b9719db23b189fb5f6a8f4f16c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a25355b9719db23b189fb5f6a8f4f16c4">More...</a><br /></td></tr>
<tr class="separator:a25355b9719db23b189fb5f6a8f4f16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dad92c4fe9e6a289a93195e1230e97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a19dad92c4fe9e6a289a93195e1230e97">to_ubjson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a19dad92c4fe9e6a289a93195e1230e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a19dad92c4fe9e6a289a93195e1230e97">More...</a><br /></td></tr>
<tr class="separator:a19dad92c4fe9e6a289a93195e1230e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d133cf7b2e729e9e215edeba5726116"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6d133cf7b2e729e9e215edeba5726116">to_ubjson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a6d133cf7b2e729e9e215edeba5726116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a6d133cf7b2e729e9e215edeba5726116">More...</a><br /></td></tr>
<tr class="separator:a6d133cf7b2e729e9e215edeba5726116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62d64781b217372225a0652047d8cf3"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aa62d64781b217372225a0652047d8cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">More...</a><br /></td></tr>
<tr class="separator:aa62d64781b217372225a0652047d8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e4c2ad9808218a25879700f4aef2b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a668e4c2ad9808218a25879700f4aef2b">to_bson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt; o)</td></tr>
<tr class="memdesc:a668e4c2ad9808218a25879700f4aef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a668e4c2ad9808218a25879700f4aef2b">More...</a><br /></td></tr>
<tr class="separator:a668e4c2ad9808218a25879700f4aef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebed178fb7dad1a574bcb7c361fb1b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9ebed178fb7dad1a574bcb7c361fb1b8">to_bson</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;j, <a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a9ebed178fb7dad1a574bcb7c361fb1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a9ebed178fb7dad1a574bcb7c361fb1b8">More...</a><br /></td></tr>
<tr class="separator:a9ebed178fb7dad1a574bcb7c361fb1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dd5635fb2da4710f6cd6e42b72773f"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a44dd5635fb2da4710f6cd6e42b72773f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a44dd5635fb2da4710f6cd6e42b72773f">from_cbor</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a44dd5635fb2da4710f6cd6e42b72773f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a44dd5635fb2da4710f6cd6e42b72773f">More...</a><br /></td></tr>
<tr class="separator:a44dd5635fb2da4710f6cd6e42b72773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4f6fc79cc405fb212ea3d992334e71"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:aba4f6fc79cc405fb212ea3d992334e71"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aba4f6fc79cc405fb212ea3d992334e71">from_cbor</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:aba4f6fc79cc405fb212ea3d992334e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188755c8cda27e2afb03c016c14125d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a188755c8cda27e2afb03c016c14125d8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a188755c8cda27e2afb03c016c14125d8">from_cbor</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a188755c8cda27e2afb03c016c14125d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a188755c8cda27e2afb03c016c14125d8">More...</a><br /></td></tr>
<tr class="separator:a188755c8cda27e2afb03c016c14125d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a67e47f4bcde55214475f47f8314c1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4a67e47f4bcde55214475f47f8314c1f">from_cbor</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a4a67e47f4bcde55214475f47f8314c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a4a67e47f4bcde55214475f47f8314c1f">More...</a><br /></td></tr>
<tr class="separator:a4a67e47f4bcde55214475f47f8314c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcab52fca1e25b3311ef14e71a57590"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:adbcab52fca1e25b3311ef14e71a57590"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adbcab52fca1e25b3311ef14e71a57590">from_msgpack</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:adbcab52fca1e25b3311ef14e71a57590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#adbcab52fca1e25b3311ef14e71a57590">More...</a><br /></td></tr>
<tr class="separator:adbcab52fca1e25b3311ef14e71a57590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dbeb08bcd13821512957dcbf3f00bd"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a94dbeb08bcd13821512957dcbf3f00bd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a94dbeb08bcd13821512957dcbf3f00bd">from_msgpack</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a94dbeb08bcd13821512957dcbf3f00bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d69d3102639759d5202a6f764760d23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d69d3102639759d5202a6f764760d23"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0d69d3102639759d5202a6f764760d23">from_msgpack</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a0d69d3102639759d5202a6f764760d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a0d69d3102639759d5202a6f764760d23">More...</a><br /></td></tr>
<tr class="separator:a0d69d3102639759d5202a6f764760d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b3d89de8e774a2609dc4c0a1273f62"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a84b3d89de8e774a2609dc4c0a1273f62">from_msgpack</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a84b3d89de8e774a2609dc4c0a1273f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a84b3d89de8e774a2609dc4c0a1273f62">More...</a><br /></td></tr>
<tr class="separator:a84b3d89de8e774a2609dc4c0a1273f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81f62db69978b90ff701f05c72e03a7"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:aa81f62db69978b90ff701f05c72e03a7"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa81f62db69978b90ff701f05c72e03a7">from_ubjson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:aa81f62db69978b90ff701f05c72e03a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#aa81f62db69978b90ff701f05c72e03a7">More...</a><br /></td></tr>
<tr class="separator:aa81f62db69978b90ff701f05c72e03a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb422350fed520ce8c1ca8762c0251"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a9dbb422350fed520ce8c1ca8762c0251"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9dbb422350fed520ce8c1ca8762c0251">from_ubjson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a9dbb422350fed520ce8c1ca8762c0251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eeda23c34cee79d8d72f1a8691a8de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6eeda23c34cee79d8d72f1a8691a8de"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab6eeda23c34cee79d8d72f1a8691a8de">from_ubjson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ab6eeda23c34cee79d8d72f1a8691a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#ab6eeda23c34cee79d8d72f1a8691a8de">More...</a><br /></td></tr>
<tr class="separator:ab6eeda23c34cee79d8d72f1a8691a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47201396899371881a46562bffb922da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a47201396899371881a46562bffb922da">from_ubjson</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a47201396899371881a46562bffb922da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a47201396899371881a46562bffb922da">More...</a><br /></td></tr>
<tr class="separator:a47201396899371881a46562bffb922da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e02793f2691aa29ab7cb69fddafbf5c"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a4e02793f2691aa29ab7cb69fddafbf5c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4e02793f2691aa29ab7cb69fddafbf5c">from_bson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a4e02793f2691aa29ab7cb69fddafbf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a4e02793f2691aa29ab7cb69fddafbf5c">More...</a><br /></td></tr>
<tr class="separator:a4e02793f2691aa29ab7cb69fddafbf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4118d0ec23d9eeafc236b9524d220e94"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a4118d0ec23d9eeafc236b9524d220e94"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4118d0ec23d9eeafc236b9524d220e94">from_bson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a4118d0ec23d9eeafc236b9524d220e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2612581e4788ddffc2f45d5e4cc04fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2612581e4788ddffc2f45d5e4cc04fc"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ae2612581e4788ddffc2f45d5e4cc04fc">from_bson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ae2612581e4788ddffc2f45d5e4cc04fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#ae2612581e4788ddffc2f45d5e4cc04fc">More...</a><br /></td></tr>
<tr class="separator:ae2612581e4788ddffc2f45d5e4cc04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afe89884edf72412a0624982324755d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a2afe89884edf72412a0624982324755d">from_bson</a> (<a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a2afe89884edf72412a0624982324755d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>.  <a href="classnlohmann_1_1basic__json.html#a2afe89884edf72412a0624982324755d">More...</a><br /></td></tr>
<tr class="separator:a2afe89884edf72412a0624982324755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Patch functions</h2></td></tr>
<tr class="memitem:a1c1f21327df91a4dd6c5f5a107240385"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a1c1f21327df91a4dd6c5f5a107240385">diff</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;source, const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;target, const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="separator:a1c1f21327df91a4dd6c5f5a107240385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc786998f220a5b3083ee8a37c4553e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adcc786998f220a5b3083ee8a37c4553e">patch</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;json_patch) const</td></tr>
<tr class="separator:adcc786998f220a5b3083ee8a37c4553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">object inspection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbbb01a37b8f261ae5b5799058dcac1a0"></a>Functions to inspect the type of a JSON value. </p>
</td></tr>
<tr class="memitem:a476756fb08e7f2416aad116d137977f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a476756fb08e7f2416aad116d137977f4">dump</a> (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967df">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="separator:a476756fb08e7f2416aad116d137977f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7c4b35a0ad9f97474912a08965d7ad"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> () const noexcept</td></tr>
<tr class="separator:a5b7c4b35a0ad9f97474912a08965d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548d2d4013da24e7d7510d90febc80c4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a548d2d4013da24e7d7510d90febc80c4">is_primitive</a> () const noexcept</td></tr>
<tr class="separator:a548d2d4013da24e7d7510d90febc80c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05a7d5deec758f1d830741b68b4249"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4e05a7d5deec758f1d830741b68b4249">is_structured</a> () const noexcept</td></tr>
<tr class="separator:a4e05a7d5deec758f1d830741b68b4249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7afad96292b5ab61a2e0ad3067f5f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a> () const noexcept</td></tr>
<tr class="separator:aedc7afad96292b5ab61a2e0ad3067f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911b11e855e685fa59ea1d111490b36b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a911b11e855e685fa59ea1d111490b36b">is_boolean</a> () const noexcept</td></tr>
<tr class="separator:a911b11e855e685fa59ea1d111490b36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd47ac8eba63833152795280f75b5851"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#abd47ac8eba63833152795280f75b5851">is_number</a> () const noexcept</td></tr>
<tr class="separator:abd47ac8eba63833152795280f75b5851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b4acf2c0ad075c0dc125a65c102362"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac4b4acf2c0ad075c0dc125a65c102362">is_number_integer</a> () const noexcept</td></tr>
<tr class="separator:ac4b4acf2c0ad075c0dc125a65c102362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5493f2ed1e07b0ece428bd5a47e2fb95"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5493f2ed1e07b0ece428bd5a47e2fb95">is_number_unsigned</a> () const noexcept</td></tr>
<tr class="separator:a5493f2ed1e07b0ece428bd5a47e2fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116cdb9300b56519fc9cf756609296cb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a116cdb9300b56519fc9cf756609296cb">is_number_float</a> () const noexcept</td></tr>
<tr class="separator:a116cdb9300b56519fc9cf756609296cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e8411a770a6263d6d8f2116c37f3aa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a> () const noexcept</td></tr>
<tr class="separator:a57e8411a770a6263d6d8f2116c37f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b70d60a636b9c5e10f6c8caac60b9e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a> () const noexcept</td></tr>
<tr class="separator:ab5b70d60a636b9c5e10f6c8caac60b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab303d17366c26fca12242c7f8def1bb7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">is_string</a> () const noexcept</td></tr>
<tr class="separator:ab303d17366c26fca12242c7f8def1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9576224f7b3ff812a308e7c1e784ea80"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a> () const noexcept</td></tr>
<tr class="separator:a9576224f7b3ff812a308e7c1e784ea80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaaa0613d3f3a5b49b34b02afc5f85d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aecaaa0613d3f3a5b49b34b02afc5f85d">is_discarded</a> () const noexcept</td></tr>
<tr class="separator:aecaaa0613d3f3a5b49b34b02afc5f85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4b8df10ecc533a50823e8805f4a873"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a6d4b8df10ecc533a50823e8805f4a873">operator value_t</a> () const noexcept</td></tr>
<tr class="separator:a6d4b8df10ecc533a50823e8805f4a873"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">value access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd8f53c9caf18314e5b3f758245606995"></a>Direct access to the stored value of a JSON value. </p>
</td></tr>
<tr class="memitem:a0c42bdda2432e4027f4b63ef20ae74e6"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; std::is_same&lt; typename std::remove_const&lt; BasicJsonType &gt;::type, basic_json_t &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0c42bdda2432e4027f4b63ef20ae74e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0c42bdda2432e4027f4b63ef20ae74e6">get</a> () const</td></tr>
<tr class="memdesc:a0c42bdda2432e4027f4b63ef20ae74e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a0c42bdda2432e4027f4b63ef20ae74e6">More...</a><br /></td></tr>
<tr class="separator:a0c42bdda2432e4027f4b63ef20ae74e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642213bf5f206f13d2447098b737bee7"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; !std::is_same&lt; BasicJsonType, basic_json &gt;::value &amp;&amp;detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a642213bf5f206f13d2447098b737bee7"><td class="memTemplItemLeft" align="right" valign="top">BasicJsonType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a642213bf5f206f13d2447098b737bee7">get</a> () const</td></tr>
<tr class="memdesc:a642213bf5f206f13d2447098b737bee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a642213bf5f206f13d2447098b737bee7">More...</a><br /></td></tr>
<tr class="separator:a642213bf5f206f13d2447098b737bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91198163e5ffd34d361d2db77cb1f112"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a91198163e5ffd34d361d2db77cb1f112"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a91198163e5ffd34d361d2db77cb1f112">get</a> () const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), std::declval&lt; ValueType &amp; &gt;())))</td></tr>
<tr class="memdesc:a91198163e5ffd34d361d2db77cb1f112"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a91198163e5ffd34d361d2db77cb1f112">More...</a><br /></td></tr>
<tr class="separator:a91198163e5ffd34d361d2db77cb1f112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c84027412c32e6dac101de144abf91"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;, detail::enable_if_t&lt; !std::is_same&lt; basic_json_t, ValueType &gt;::value &amp;&amp;detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad7c84027412c32e6dac101de144abf91"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad7c84027412c32e6dac101de144abf91">get</a> () const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;())))</td></tr>
<tr class="memdesc:ad7c84027412c32e6dac101de144abf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit); special case  <a href="classnlohmann_1_1basic__json.html#ad7c84027412c32e6dac101de144abf91">More...</a><br /></td></tr>
<tr class="separator:ad7c84027412c32e6dac101de144abf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cbe06eb6b15f76e41c7c85081d2638"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa1cbe06eb6b15f76e41c7c85081d2638"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa1cbe06eb6b15f76e41c7c85081d2638">get_to</a> (ValueType &amp;v) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="memdesc:aa1cbe06eb6b15f76e41c7c85081d2638"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#aa1cbe06eb6b15f76e41c7c85081d2638">More...</a><br /></td></tr>
<tr class="separator:aa1cbe06eb6b15f76e41c7c85081d2638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd6c12364425e4007ee4d7ecf9fefd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_basic_json&lt; ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac6fd6c12364425e4007ee4d7ecf9fefd"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ac6fd6c12364425e4007ee4d7ecf9fefd">get_to</a> (ValueType &amp;v) const</td></tr>
<tr class="memdesc:ac6fd6c12364425e4007ee4d7ecf9fefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#ac6fd6c12364425e4007ee4d7ecf9fefd">More...</a><br /></td></tr>
<tr class="separator:ac6fd6c12364425e4007ee4d7ecf9fefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dd41000e4e7751928fffb44ff4aed4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; detail::has_from_json&lt; basic_json_t, Array &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a85dd41000e4e7751928fffb44ff4aed4"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a85dd41000e4e7751928fffb44ff4aed4">get_to</a> (T(&amp;v)[N]) const noexcept(noexcept(JSONSerializer&lt; Array &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="memdesc:a85dd41000e4e7751928fffb44ff4aed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a85dd41000e4e7751928fffb44ff4aed4">More...</a><br /></td></tr>
<tr class="separator:a85dd41000e4e7751928fffb44ff4aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85222410e03d8f5c8ff9c78cf9f6b1b6"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a85222410e03d8f5c8ff9c78cf9f6b1b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">get_ptr</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a85222410e03d8f5c8ff9c78cf9f6b1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">More...</a><br /></td></tr>
<tr class="separator:a85222410e03d8f5c8ff9c78cf9f6b1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd99a3902a2bb09a306fb854540ae1dd"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:afd99a3902a2bb09a306fb854540ae1dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#afd99a3902a2bb09a306fb854540ae1dd">get_ptr</a> () const noexcept -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:afd99a3902a2bb09a306fb854540ae1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="classnlohmann_1_1basic__json.html#afd99a3902a2bb09a306fb854540ae1dd">More...</a><br /></td></tr>
<tr class="separator:afd99a3902a2bb09a306fb854540ae1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826e180d2457d114ed4c51f4b0737df8"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a826e180d2457d114ed4c51f4b0737df8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a826e180d2457d114ed4c51f4b0737df8">get</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().template <a class="el" href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:a826e180d2457d114ed4c51f4b0737df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a826e180d2457d114ed4c51f4b0737df8">More...</a><br /></td></tr>
<tr class="separator:a826e180d2457d114ed4c51f4b0737df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014a9be80fef74c22b54d92c2cbd90c6"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a014a9be80fef74c22b54d92c2cbd90c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a014a9be80fef74c22b54d92c2cbd90c6">get</a> () const noexcept -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().template <a class="el" href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:a014a9be80fef74c22b54d92c2cbd90c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <a href="classnlohmann_1_1basic__json.html#a014a9be80fef74c22b54d92c2cbd90c6">More...</a><br /></td></tr>
<tr class="separator:a014a9be80fef74c22b54d92c2cbd90c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ddc6e0f6d70296bc81f810254076c5"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a14ddc6e0f6d70296bc81f810254076c5"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a14ddc6e0f6d70296bc81f810254076c5">get_ref</a> ()</td></tr>
<tr class="memdesc:a14ddc6e0f6d70296bc81f810254076c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#a14ddc6e0f6d70296bc81f810254076c5">More...</a><br /></td></tr>
<tr class="separator:a14ddc6e0f6d70296bc81f810254076c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0889072c54f1b899689ed6246238e7"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a7f0889072c54f1b899689ed6246238e7"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a7f0889072c54f1b899689ed6246238e7">get_ref</a> () const</td></tr>
<tr class="memdesc:a7f0889072c54f1b899689ed6246238e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="classnlohmann_1_1basic__json.html#a7f0889072c54f1b899689ed6246238e7">More...</a><br /></td></tr>
<tr class="separator:a7f0889072c54f1b899689ed6246238e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1463d8d7ba77865f28f5e83dec7f33"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename std::enable_if&lt; !std::is_pointer&lt; ValueType &gt;::value &amp;&amp;!std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;::value &amp;&amp;!std::is_same&lt; ValueType, typename string_t::value_type &gt;::value &amp;&amp;!detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;!std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;::value &amp;&amp;detail::is_detected&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ada1463d8d7ba77865f28f5e83dec7f33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="json_8hpp.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ada1463d8d7ba77865f28f5e83dec7f33">operator ValueType</a> () const</td></tr>
<tr class="memdesc:ada1463d8d7ba77865f28f5e83dec7f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">get special-case overload  <a href="classnlohmann_1_1basic__json.html#ada1463d8d7ba77865f28f5e83dec7f33">More...</a><br /></td></tr>
<tr class="separator:ada1463d8d7ba77865f28f5e83dec7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab19a246f6bcd27c195bed376cf5e138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aab19a246f6bcd27c195bed376cf5e138">get_binary</a> ()</td></tr>
<tr class="separator:aab19a246f6bcd27c195bed376cf5e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfa5532931abd2d9040cbf4d18a2ca7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#abbfa5532931abd2d9040cbf4d18a2ca7">get_binary</a> () const</td></tr>
<tr class="separator:abbfa5532931abd2d9040cbf4d18a2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">element access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf68418821a90b03a001117a613b131dd"></a>Access to the JSON value. </p>
</td></tr>
<tr class="memitem:a52b18a5b7e68652c65b070900c438c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a52b18a5b7e68652c65b070900c438c6e">at</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> idx)</td></tr>
<tr class="memdesc:a52b18a5b7e68652c65b070900c438c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a52b18a5b7e68652c65b070900c438c6e">More...</a><br /></td></tr>
<tr class="separator:a52b18a5b7e68652c65b070900c438c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb18fe2b8a5dbff4ccf2848de854c3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aeb18fe2b8a5dbff4ccf2848de854c3ac">at</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> idx) const</td></tr>
<tr class="memdesc:aeb18fe2b8a5dbff4ccf2848de854c3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#aeb18fe2b8a5dbff4ccf2848de854c3ac">More...</a><br /></td></tr>
<tr class="separator:aeb18fe2b8a5dbff4ccf2848de854c3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239e942da82f2597d0cf5ec806f5bc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a239e942da82f2597d0cf5ec806f5bc0d">at</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a239e942da82f2597d0cf5ec806f5bc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a239e942da82f2597d0cf5ec806f5bc0d">More...</a><br /></td></tr>
<tr class="separator:a239e942da82f2597d0cf5ec806f5bc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229964ee10c92ba89ae4fba786fe6b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a229964ee10c92ba89ae4fba786fe6b50">at</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a229964ee10c92ba89ae4fba786fe6b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a229964ee10c92ba89ae4fba786fe6b50">More...</a><br /></td></tr>
<tr class="separator:a229964ee10c92ba89ae4fba786fe6b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea67fc1ef0ccc42e1d5388fe0416ae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a9ea67fc1ef0ccc42e1d5388fe0416ae5">operator[]</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> idx)</td></tr>
<tr class="memdesc:a9ea67fc1ef0ccc42e1d5388fe0416ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a9ea67fc1ef0ccc42e1d5388fe0416ae5">More...</a><br /></td></tr>
<tr class="separator:a9ea67fc1ef0ccc42e1d5388fe0416ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21d96f490fa1aa8605fba8dadcce319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ad21d96f490fa1aa8605fba8dadcce319">operator[]</a> (<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> idx) const</td></tr>
<tr class="memdesc:ad21d96f490fa1aa8605fba8dadcce319"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#ad21d96f490fa1aa8605fba8dadcce319">More...</a><br /></td></tr>
<tr class="separator:ad21d96f490fa1aa8605fba8dadcce319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45f3820c456ad2e3f3df2926564151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a3f45f3820c456ad2e3f3df2926564151">operator[]</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a3f45f3820c456ad2e3f3df2926564151"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a3f45f3820c456ad2e3f3df2926564151">More...</a><br /></td></tr>
<tr class="separator:a3f45f3820c456ad2e3f3df2926564151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5b489310f4e0ce2d5fb29b73fb59d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#acb5b489310f4e0ce2d5fb29b73fb59d3">operator[]</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:acb5b489310f4e0ce2d5fb29b73fb59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#acb5b489310f4e0ce2d5fb29b73fb59d3">More...</a><br /></td></tr>
<tr class="separator:acb5b489310f4e0ce2d5fb29b73fb59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc94831476f7b4d3efe6f2e9036c7188"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc94831476f7b4d3efe6f2e9036c7188"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#abc94831476f7b4d3efe6f2e9036c7188">operator[]</a> (T *key)</td></tr>
<tr class="memdesc:abc94831476f7b4d3efe6f2e9036c7188"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#abc94831476f7b4d3efe6f2e9036c7188">More...</a><br /></td></tr>
<tr class="separator:abc94831476f7b4d3efe6f2e9036c7188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bbe874496eb7b29a5549e0637de59e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11bbe874496eb7b29a5549e0637de59e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a11bbe874496eb7b29a5549e0637de59e">operator[]</a> (T *key) const</td></tr>
<tr class="memdesc:a11bbe874496eb7b29a5549e0637de59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a11bbe874496eb7b29a5549e0637de59e">More...</a><br /></td></tr>
<tr class="separator:a11bbe874496eb7b29a5549e0637de59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11641b35219676b225d9bd15c7677659"><td class="memTemplParams" colspan="2">template&lt;class ValueType , typename std::enable_if&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, ValueType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a11641b35219676b225d9bd15c7677659"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a> (const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a11641b35219676b225d9bd15c7677659"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">More...</a><br /></td></tr>
<tr class="separator:a11641b35219676b225d9bd15c7677659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfdefe95d5c2471a5c97e911d46ee88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adcfdefe95d5c2471a5c97e911d46ee88">value</a> (const typename object_t::key_type &amp;key, const char *default_value) const</td></tr>
<tr class="memdesc:adcfdefe95d5c2471a5c97e911d46ee88"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#adcfdefe95d5c2471a5c97e911d46ee88">More...</a><br /></td></tr>
<tr class="separator:adcfdefe95d5c2471a5c97e911d46ee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bd6765ccd8aeeeb4e49a766ba639df"><td class="memTemplParams" colspan="2">template&lt;class ValueType , typename std::enable_if&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a36bd6765ccd8aeeeb4e49a766ba639df"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a36bd6765ccd8aeeeb4e49a766ba639df">value</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a36bd6765ccd8aeeeb4e49a766ba639df"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a36bd6765ccd8aeeeb4e49a766ba639df">More...</a><br /></td></tr>
<tr class="separator:a36bd6765ccd8aeeeb4e49a766ba639df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4658a584571c4180656f5268969ed0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a4658a584571c4180656f5268969ed0a1">value</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr, const char *default_value) const</td></tr>
<tr class="memdesc:a4658a584571c4180656f5268969ed0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a4658a584571c4180656f5268969ed0a1">More...</a><br /></td></tr>
<tr class="separator:a4658a584571c4180656f5268969ed0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5417ca43ae5e7a3a2f82eee2d915c6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5417ca43ae5e7a3a2f82eee2d915c6ed">front</a> ()</td></tr>
<tr class="memdesc:a5417ca43ae5e7a3a2f82eee2d915c6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a5417ca43ae5e7a3a2f82eee2d915c6ed">More...</a><br /></td></tr>
<tr class="separator:a5417ca43ae5e7a3a2f82eee2d915c6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8f974c178cf9326b6765e22f50eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5ac8f974c178cf9326b6765e22f50eb6">front</a> () const</td></tr>
<tr class="memdesc:a5ac8f974c178cf9326b6765e22f50eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a5ac8f974c178cf9326b6765e22f50eb6">More...</a><br /></td></tr>
<tr class="separator:a5ac8f974c178cf9326b6765e22f50eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30914ad0767ccdc3633f88a906ed7dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a30914ad0767ccdc3633f88a906ed7dfa">back</a> ()</td></tr>
<tr class="memdesc:a30914ad0767ccdc3633f88a906ed7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a30914ad0767ccdc3633f88a906ed7dfa">More...</a><br /></td></tr>
<tr class="separator:a30914ad0767ccdc3633f88a906ed7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac965b84ea43ccd8aef9caefef02794a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aac965b84ea43ccd8aef9caefef02794a">back</a> () const</td></tr>
<tr class="memdesc:aac965b84ea43ccd8aef9caefef02794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#aac965b84ea43ccd8aef9caefef02794a">More...</a><br /></td></tr>
<tr class="separator:aac965b84ea43ccd8aef9caefef02794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494632b69bbe1d0153d3bedad0901b8e"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , typename std::enable_if&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a494632b69bbe1d0153d3bedad0901b8e"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a494632b69bbe1d0153d3bedad0901b8e">erase</a> (IteratorType pos)</td></tr>
<tr class="memdesc:a494632b69bbe1d0153d3bedad0901b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a494632b69bbe1d0153d3bedad0901b8e">More...</a><br /></td></tr>
<tr class="separator:a494632b69bbe1d0153d3bedad0901b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac83750e267e37d5d47591eb44cce42"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , typename std::enable_if&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8ac83750e267e37d5d47591eb44cce42"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a8ac83750e267e37d5d47591eb44cce42">erase</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a8ac83750e267e37d5d47591eb44cce42"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a8ac83750e267e37d5d47591eb44cce42">More...</a><br /></td></tr>
<tr class="separator:a8ac83750e267e37d5d47591eb44cce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72b1c9d1502b02a49a0cb9db9f980ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#af72b1c9d1502b02a49a0cb9db9f980ea">erase</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:af72b1c9d1502b02a49a0cb9db9f980ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#af72b1c9d1502b02a49a0cb9db9f980ea">More...</a><br /></td></tr>
<tr class="separator:af72b1c9d1502b02a49a0cb9db9f980ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b943d3228488c14225e55f726cc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a221b943d3228488c14225e55f726cc26">erase</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> idx)</td></tr>
<tr class="memdesc:a221b943d3228488c14225e55f726cc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload for a default value of type const char*  <a href="classnlohmann_1_1basic__json.html#a221b943d3228488c14225e55f726cc26">More...</a><br /></td></tr>
<tr class="separator:a221b943d3228488c14225e55f726cc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lookup</h2></td></tr>
<tr class="memitem:acdf9b3aab82dcf443dd91ca5ec06b80c"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:acdf9b3aab82dcf443dd91ca5ec06b80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#acdf9b3aab82dcf443dd91ca5ec06b80c">find</a> (KeyT &amp;&amp;key)</td></tr>
<tr class="memdesc:acdf9b3aab82dcf443dd91ca5ec06b80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classnlohmann_1_1basic__json.html#acdf9b3aab82dcf443dd91ca5ec06b80c">More...</a><br /></td></tr>
<tr class="separator:acdf9b3aab82dcf443dd91ca5ec06b80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a516671c29a69bb2e11ca12030316b"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:a17a516671c29a69bb2e11ca12030316b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a17a516671c29a69bb2e11ca12030316b">find</a> (KeyT &amp;&amp;key) const</td></tr>
<tr class="memdesc:a17a516671c29a69bb2e11ca12030316b"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classnlohmann_1_1basic__json.html#a17a516671c29a69bb2e11ca12030316b">More...</a><br /></td></tr>
<tr class="separator:a17a516671c29a69bb2e11ca12030316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ec6d1e37eda6b11eba491a1e5237e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:aba5ec6d1e37eda6b11eba491a1e5237e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aba5ec6d1e37eda6b11eba491a1e5237e">count</a> (KeyT &amp;&amp;key) const</td></tr>
<tr class="memdesc:aba5ec6d1e37eda6b11eba491a1e5237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classnlohmann_1_1basic__json.html#aba5ec6d1e37eda6b11eba491a1e5237e">More...</a><br /></td></tr>
<tr class="separator:aba5ec6d1e37eda6b11eba491a1e5237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c9bc4d0f33b7dec20b2798301d6971"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename std::enable_if&lt; !std::is_same&lt; typename std::decay&lt; KeyT &gt;::type, json_pointer &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a02c9bc4d0f33b7dec20b2798301d6971"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a02c9bc4d0f33b7dec20b2798301d6971">contains</a> (KeyT &amp;&amp;key) const</td></tr>
<tr class="memdesc:a02c9bc4d0f33b7dec20b2798301d6971"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classnlohmann_1_1basic__json.html#a02c9bc4d0f33b7dec20b2798301d6971">More...</a><br /></td></tr>
<tr class="separator:a02c9bc4d0f33b7dec20b2798301d6971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb82c1f34c73486e013da71ae369e597"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adb82c1f34c73486e013da71ae369e597">contains</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:adb82c1f34c73486e013da71ae369e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classnlohmann_1_1basic__json.html#adb82c1f34c73486e013da71ae369e597">More...</a><br /></td></tr>
<tr class="separator:adb82c1f34c73486e013da71ae369e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">capacity</h2></td></tr>
<tr class="memitem:a5c99855f3e35ff35558cb46139b785f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a5c99855f3e35ff35558cb46139b785f8">empty</a> () const noexcept</td></tr>
<tr class="separator:a5c99855f3e35ff35558cb46139b785f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c7c8638bb0b12e6d1b69d8106dd2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a33c7c8638bb0b12e6d1b69d8106dd2e0">size</a> () const noexcept</td></tr>
<tr class="separator:a33c7c8638bb0b12e6d1b69d8106dd2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b46c6631e30b8394e89bd1546d69736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a1b46c6631e30b8394e89bd1546d69736">max_size</a> () const noexcept</td></tr>
<tr class="separator:a1b46c6631e30b8394e89bd1546d69736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Pointer functions</h2></td></tr>
<tr class="memitem:a0d3deaa73b3644b4da3f8ef3172cd8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0d3deaa73b3644b4da3f8ef3172cd8d2">operator[]</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr)</td></tr>
<tr class="separator:a0d3deaa73b3644b4da3f8ef3172cd8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a691c29eb7c4acd91ccb498a79cd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a0a691c29eb7c4acd91ccb498a79cd3ee">operator[]</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="separator:a0a691c29eb7c4acd91ccb498a79cd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa014a978f8b6c085db8825faa8dad320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#aa014a978f8b6c085db8825faa8dad320">at</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr)</td></tr>
<tr class="separator:aa014a978f8b6c085db8825faa8dad320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8284b9c1d4d0830151eaa000f907b2e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a8284b9c1d4d0830151eaa000f907b2e6">at</a> (const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="separator:a8284b9c1d4d0830151eaa000f907b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aa6e048e659481a036f2d872c7cba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#ab7aa6e048e659481a036f2d872c7cba6">flatten</a> () const</td></tr>
<tr class="separator:ab7aa6e048e659481a036f2d872c7cba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea158bff8642202420898f6322da479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#adea158bff8642202420898f6322da479">unflatten</a> () const</td></tr>
<tr class="separator:adea158bff8642202420898f6322da479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Merge Patch functions</h2></td></tr>
<tr class="memitem:a844a77cb154752d12118f10af26d54cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlohmann_1_1basic__json.html#a844a77cb154752d12118f10af26d54cb">merge_patch</a> (const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> &amp;apply_patch)</td></tr>
<tr class="separator:a844a77cb154752d12118f10af26d54cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType = std::vector&lt;std::uint8_t&gt;&gt;<br />
class nlohmann::basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;</h3>

<p>a class to store JSON values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>type for JSON objects (<code>std::map</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a>) </td></tr>
    <tr><td class="paramname">ArrayType</td><td>type for JSON arrays (<code>std::vector</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a>) </td></tr>
    <tr><td class="paramname">StringType</td><td>type for JSON strings and object keys (<code>std::string</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>) </td></tr>
    <tr><td class="paramname">BooleanType</td><td>type for JSON booleans (<code>bool</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#a44fd1a12c9c54623c942b430e7a72937">boolean_t</a>) </td></tr>
    <tr><td class="paramname">NumberIntegerType</td><td>type for JSON integer numbers (<code>int64_t</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a>) </td></tr>
    <tr><td class="paramname">NumberUnsignedType</td><td>type for JSON unsigned integer numbers (<code><code>uint64_t</code></code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a>) </td></tr>
    <tr><td class="paramname">NumberFloatType</td><td>type for JSON floating-point numbers (<code>double</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a>) </td></tr>
    <tr><td class="paramname">BinaryType</td><td>type for packed binary data for compatibility with binary serialization formats (<code>std::vector&lt;std::uint8_t&gt;</code> by default; will be used in <a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a>) </td></tr>
    <tr><td class="paramname">AllocatorType</td><td>type of the allocator to use (<code>std::allocator</code> by default) </td></tr>
    <tr><td class="paramname">JSONSerializer</td><td>the serializer to resolve internal calls to <code><a class="el" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">to_json()</a></code> and <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code> (<a class="el" href="structnlohmann_1_1adl__serializer.html">adl_serializer</a> by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The class satisfies the following concept requirements:<ul>
<li>Basic<ul>
<li><a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a>: JSON values can be default constructed. The result will be a JSON null value.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible">MoveConstructible</a>: A JSON value can be constructed from an rvalue argument.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a>: A JSON value can be copy-constructed from an lvalue expression.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/MoveAssignable">MoveAssignable</a>: A JSON value van be assigned from an rvalue argument.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">CopyAssignable</a>: A JSON value can be copy-assigned from an lvalue expression.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/Destructible">Destructible</a>: JSON values can be destructed.</li>
</ul>
</li>
<li>Layout<ul>
<li><a href="https://en.cppreference.com/w/cpp/named_req/StandardLayoutType">StandardLayoutType</a>: JSON values have <a href="https://en.cppreference.com/w/cpp/language/data_members#Standard_layout">standard layout</a>: All non-static data members are private and standard layout types, the class has no virtual functions or (virtual) base classes.</li>
</ul>
</li>
<li>Library-wide<ul>
<li><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">EqualityComparable</a>: JSON values can be compared with <code>==</code>, see <a class="el" href="classnlohmann_1_1basic__json.html#a122640e7e2db1814fc7bbb3c122ec76e">operator==(const_reference,const_reference)</a>.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>: JSON values can be compared with <code>&lt;</code>, see <a class="el" href="classnlohmann_1_1basic__json.html#aacd442b66140c764c594ac8ad7dfd5b3">operator&lt;(const_reference,const_reference)</a>.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/Swappable">Swappable</a>: Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of other compatible types, using unqualified function call <a class="el" href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">swap()</a>.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/NullablePointer">NullablePointer</a>: JSON values can be compared against <code>std::nullptr_t</code> objects which are used to model the <code>null</code> value.</li>
</ul>
</li>
<li>Container<ul>
<li><a href="https://en.cppreference.com/w/cpp/named_req/Container">Container</a>: JSON values can be used like STL containers and provide iterator access.</li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/ReversibleContainer">ReversibleContainer</a>; JSON values can be used like STL containers and provide reverse iterator access.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>The member variables <em>m_value</em> and <em>m_type</em> have the following relationship:<ul>
<li>If <code>m_type == <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666" title="object (unordered set of name/value pairs)">value_t::object</a></code>, then <code>m_value.object != nullptr</code>.</li>
<li>If <code>m_type == <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5" title="array (ordered collection of values)">value_t::array</a></code>, then <code>m_value.array != nullptr</code>.</li>
<li>If <code>m_type == <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21" title="string value">value_t::string</a></code>, then <code>m_value.string != nullptr</code>. The invariants are checked by member function assert_invariant().</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://rfc7159.net/rfc7159">RFC 7159: The JavaScript Object Notation (JSON) Data Interchange Format</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16664">16664</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad38ae80f1e99d4b1f33c99fea4611457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38ae80f1e99d4b1f33c99fea4611457">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a> =  AllocatorType&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the allocator type </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16784">16784</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a858c1cf8407bc06494e3a1114a3b73e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858c1cf8407bc06494e3a1114a3b73e7">&#9670;&nbsp;</a></span>array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> =  ArrayType&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>, AllocatorType&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an array </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes JSON arrays as follows: </p><blockquote class="doxtable">
<p>An array is an ordered sequence of zero or more values. </p>
</blockquote>
<p>To store objects in C++, a type is defined by the template parameters explained below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayType</td><td>container type to store arrays (e.g., <code>std::vector</code> or <code>std::list</code>) </td></tr>
    <tr><td class="paramname">AllocatorType</td><td>allocator to use for arrays (e.g., <code>std::allocator</code>)</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md4"></a>
Default type</h4>
<p>With the default values for <em>ArrayType</em> (<code>std::vector</code>) and <em>AllocatorType</em> (<code>std::allocator</code>), the default value for <em>array_t</em> is:</p>
<div class="fragment"><div class="line">std::vector&lt;</div>
<div class="line">  <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>, <span class="comment">// value_type</span></div>
<div class="line">  std::allocator&lt;basic_json&gt; <span class="comment">// allocator_type</span></div>
<div class="line">&gt;</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a19734fbc9c97d536832892ddacd6b62a"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">nlohmann::basic_json::basic_json</a></div><div class="ttdeci">basic_json(const value_t v)</div><div class="ttdoc">explicitly create a binary array (without subtype)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l17837">json.hpp:17837</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md5"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> specifies: </p><blockquote class="doxtable">
<p>An implementation may set limits on the maximum depth of nesting. </p>
</blockquote>
<p>In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <a class="el" href="classnlohmann_1_1basic__json.html#a1b46c6631e30b8394e89bd1546d69736">max_size</a> function of a JSON array.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Storage</h4>
<p>Arrays are stored as pointers in a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type. That is, for any access to array values, a pointer of type <code>array_t*</code> must be dereferenced.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for an <a class="el" href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903" title="explicitly create a binary array (without subtype)">object</a> <a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659" title="overload for a default value of type const char*">value</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17044">17044</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad6c955145bebde84d93991ffed7cd389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c955145bebde84d93991ffed7cd389">&#9670;&nbsp;</a></span>binary_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> =  <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html">nlohmann::byte_container_with_subtype</a>&lt;BinaryType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a packed binary type </p>
<p>This type is a type designed to carry binary data that appears in various serialized formats, such as CBOR's Major Type 2, MessagePack's bin, and BSON's generic binary subtype. This type is NOT a part of standard JSON and exists solely for compatibility with these binary types. As such, it is simply defined as an ordered sequence of zero or more byte values.</p>
<p>Additionally, as an implementation detail, the subtype of the binary data is carried around as a <code>std::uint8_t</code>, which is compatible with both of the binary data formats that use binary subtyping, (though the specific numbering is incompatible with each other, and it is up to the user to translate between them).</p>
<p><a href="https://tools.ietf.org/html/rfc7049">CBOR's RFC 7049</a> describes this type as: </p><blockquote class="doxtable">
<p>Major type 2: a byte string. The string's length in bytes is represented following the rules for positive integers (major type 0). </p>
</blockquote>
<p><a href="https://github.com/msgpack/msgpack/blob/master/spec.md#bin-format-family">MessagePack's documentation on the bin type family</a> describes this type as: </p><blockquote class="doxtable">
<p>Bin format family stores an byte array in 2, 3, or 5 bytes of extra bytes in addition to the size of the byte array. </p>
</blockquote>
<p><a href="http://bsonspec.org/spec.html">BSON's specifications</a> describe several binary types; however, this type is intended to represent the generic binary type which has the description: </p><blockquote class="doxtable">
<p>Generic binary subtype - This is the most commonly used binary subtype and should be the 'default' for drivers and tools. </p>
</blockquote>
<p>None of these impose any limitations on the internal representation other than the basic unit of storage be some type of array whose parts are decomposable into bytes.</p>
<p>The default representation of this binary format is a <code>std::vector&lt;std::uint8_t&gt;</code>, which is a very common way to represent a byte array in modern C++.</p>
<h4><a class="anchor" id="autotoc_md25"></a>
Default type</h4>
<p>The default values for <em>BinaryType</em> is <code>std::vector&lt;std::uint8_t&gt;</code></p>
<h4><a class="anchor" id="autotoc_md26"></a>
Storage</h4>
<p>Binary Arrays are stored as pointers in a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type. That is, for any access to array values, a pointer of the type <code>binary_t*</code> must be dereferenced.</p>
<h4><a class="anchor" id="autotoc_md27"></a>
Notes on subtypes</h4>
<ul>
<li>CBOR<ul>
<li>Binary values are represented as byte strings. No subtypes are supported and will be ignored when CBOR is written.</li>
</ul>
</li>
<li>MessagePack<ul>
<li>If a subtype is given and the binary array contains exactly 1, 2, 4, 8, or 16 elements, the fixext family (fixext1, fixext2, fixext4, fixext8) is used. For other sizes, the ext family (ext8, ext16, ext32) is used. The subtype is then added as singed 8-bit integer.</li>
<li>If no subtype is given, the bin family (bin8, bin16, bin32) is used.</li>
</ul>
</li>
<li>BSON<ul>
<li>If a subtype is given, it is used and added as unsigned 8-bit integer.</li>
<li>If no subtype is given, the generic binary subtype 0x00 is used.</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091">binary</a> &ndash; create a <a class="el" href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091" title="explicitly create a binary array (without subtype)">binary</a> <a class="el" href="classnlohmann_1_1basic__json.html#a2c8d8f5741aedadac8f3bffd8f2ce13e" title="explicitly create a binary array (without subtype)">array</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17405">17405</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a44fd1a12c9c54623c942b430e7a72937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fd1a12c9c54623c942b430e7a72937">&#9670;&nbsp;</a></span>boolean_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a44fd1a12c9c54623c942b430e7a72937">boolean_t</a> =  BooleanType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a boolean </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> implicitly describes a boolean as a type which differentiates the two literals <code>true</code> and <code>false</code>.</p>
<p>To store objects in C++, a type is defined by the template parameter <em>BooleanType</em> which chooses the type to use.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
Default type</h4>
<p>With the default values for <em>BooleanType</em> (<code>bool</code>), the default value for <em>boolean_t</em> is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md12"></a>
Storage</h4>
<p>Boolean values are stored directly inside a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type.</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17123">17123</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a54951d14f0dd10cc3cfdaa24f8bfd15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54951d14f0dd10cc3cfdaa24f8bfd15c">&#9670;&nbsp;</a></span>cbor_tag_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">detail::cbor_tag_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat CBOR tags </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16729">16729</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aebd2cfa7e4ded4e97cde9269bfeeea38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd2cfa7e4ded4e97cde9269bfeeea38">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> =  <a class="el" href="classnlohmann_1_1detail_1_1iter__impl.html">iter_impl</a>&lt;const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16794">16794</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a4108c5148f1d7cf13c2681e22f141a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4108c5148f1d7cf13c2681e22f141a10">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a4108c5148f1d7cf13c2681e22f141a10">const_pointer</a> =  typename std::allocator_traits&lt;<a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a>&gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a4108c5148f1d7cf13c2681e22f141a10">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16789">16789</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab8a1c33ee7b154fc41ca2545aa9724e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a1c33ee7b154fc41ca2545aa9724e6">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> =  const <a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16776">16776</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa7dba16ed9ee97380aeb17a207dd919a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dba16ed9ee97380aeb17a207dd919a">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> =  <a class="el" href="classnlohmann_1_1detail_1_1json__reverse__iterator.html">json_reverse_iterator</a>&lt;typename <a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">basic_json::const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const reverse iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16798">16798</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3d20d11e5dfe95084a76f62eca54fadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d20d11e5dfe95084a76f62eca54fadd">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">difference_type</a> =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent differences between iterators </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16779">16779</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1e7ca76cc3f62626b380be5e18a002d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7ca76cc3f62626b380be5e18a002d5">&#9670;&nbsp;</a></span>error_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967df">error_handler_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967df">detail::error_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat decoding errors </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16727">16727</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a14824c27188d2fee4861806cd5f23d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14824c27188d2fee4861806cd5f23d22">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a14824c27188d2fee4861806cd5f23d22">exception</a> =  <a class="el" href="classnlohmann_1_1detail_1_1exception.html">detail::exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16746">16746</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac569f292a070dfd2f6b69c16e746095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac569f292a070dfd2f6b69c16e746095a">&#9670;&nbsp;</a></span>initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a> =  std::initializer_list&lt;<a class="el" href="classnlohmann_1_1detail_1_1json__ref.html">detail::json_ref</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper type for initializer lists of <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> values </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16731">16731</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a211cf53702226ad9fb3c939a3a3d3689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211cf53702226ad9fb3c939a3a3d3689">&#9670;&nbsp;</a></span>input_format_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">detail::input_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16733">16733</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6ccc9788413fd58de998fe92743cb4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccc9788413fd58de998fe92743cb4aa">&#9670;&nbsp;</a></span>invalid_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a6ccc9788413fd58de998fe92743cb4aa">invalid_iterator</a> =  <a class="el" href="classnlohmann_1_1detail_1_1invalid__iterator.html">detail::invalid_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16750">16750</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa549b2b382916b3baafb526e5cb410bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa549b2b382916b3baafb526e5cb410bd">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> =  <a class="el" href="classnlohmann_1_1detail_1_1iter__impl.html">iter_impl</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16792">16792</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa8f1f93b32da01b42413643be32b2c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f1f93b32da01b42413643be32b2c27">&#9670;&nbsp;</a></span>json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> =  ::<a class="el" href="classnlohmann_1_1json__pointer.html">nlohmann::json_pointer</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JSON Pointer, see <a class="el" href="classnlohmann_1_1json__pointer.html">nlohmann::json_pointer</a>. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16723">16723</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a164b1094a1a9feb54e400d8510bb0b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164b1094a1a9feb54e400d8510bb0b12">&#9670;&nbsp;</a></span>json_sax_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a164b1094a1a9feb54e400d8510bb0b12">json_sax_t</a> =  <a class="el" href="structnlohmann_1_1json__sax.html">json_sax</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAX interface type, see <a class="el" href="structnlohmann_1_1json__sax.html">nlohmann::json_sax</a>. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16735">16735</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad6ebc5da7ced975bb184133750e7d49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ebc5da7ced975bb184133750e7d49f">&#9670;&nbsp;</a></span>json_serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename SFINAE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer</a> =  JSONSerializer&lt;T, SFINAE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16725">16725</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5b8abaebd922d82d69756327c0c347e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8abaebd922d82d69756327c0c347e6">&#9670;&nbsp;</a></span>number_float_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> =  NumberFloatType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (floating-point) </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes numbers as follows: </p><blockquote class="doxtable">
<p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. </p>
</blockquote>
<p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, <a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a>, <a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> and <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> are used.</p>
<p>To store floating-point numbers in C++, a type is defined by the template parameter <em>NumberFloatType</em> which chooses the type to use.</p>
<h4><a class="anchor" id="autotoc_md21"></a>
Default type</h4>
<p>With the default values for <em>NumberFloatType</em> (<code>double</code>), the default value for <em>number_float_t</em> is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md22"></a>
Default behavior</h4>
<ul>
<li>The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in floating-point literals will be ignored. Internally, the value will be stored as decimal number. For instance, the C++ floating-point literal <code>01.2</code> will be serialized to <code>1.2</code>. During deserialization, leading zeros yield an error.</li>
<li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md23"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> states: </p><blockquote class="doxtable">
<p>This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. </p>
</blockquote>
<p>This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than <code>-1.79769313486232e+308</code> and values greater than <code>1.79769313486232e+308</code> will be stored as NaN internally and be serialized to <code>null</code>.</p>
<h4><a class="anchor" id="autotoc_md24"></a>
Storage</h4>
<p>Floating-point number values are stored directly inside a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (integer)</dd>
<dd>
<a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (unsigned integer)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17334">17334</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a11e390944da90db83089eb2426a749d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e390944da90db83089eb2426a749d3">&#9670;&nbsp;</a></span>number_integer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a> =  NumberIntegerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (integer) </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes numbers as follows: </p><blockquote class="doxtable">
<p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. </p>
</blockquote>
<p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, <a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a>, <a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> and <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> are used.</p>
<p>To store integer numbers in C++, a type is defined by the template parameter <em>NumberIntegerType</em> which chooses the type to use.</p>
<h4><a class="anchor" id="autotoc_md13"></a>
Default type</h4>
<p>With the default values for <em>NumberIntegerType</em> (<code>int64_t</code>), the default value for <em>number_integer_t</em> is:</p>
<div class="fragment"><div class="line">int64_t</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md14"></a>
Default behavior</h4>
<ul>
<li>The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal <code>010</code> will be serialized to <code>8</code>. During deserialization, leading zeros yield an error.</li>
<li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md15"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> specifies: </p><blockquote class="doxtable">
<p>An implementation may set limits on the range and precision of numbers. </p>
</blockquote>
<p>When the default type is used, the maximal integer number that can be stored is <code>9223372036854775807</code> (INT64_MAX) and the minimal integer number that can be stored is <code>-9223372036854775808</code> (INT64_MIN). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as <a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> or <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a>.</p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> further states: </p><blockquote class="doxtable">
<p>Note that when such software is used, numbers that are integers and are in the range <img class="formulaInl" alt="$[-2^{53}+1, 2^{53}-1]$" src="form_0.png"/> are interoperable in the sense that implementations will agree exactly on their numeric values. </p>
</blockquote>
<p>As this range is a subrange of the exactly supported range [INT64_MIN, INT64_MAX], this class's integer type is interoperable.</p>
<h4><a class="anchor" id="autotoc_md16"></a>
Storage</h4>
<p>Integer number values are stored directly inside a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (floating-point)</dd>
<dd>
<a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (unsigned integer)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17195">17195</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ae09af9c23351b7245d9be4d1b2035fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09af9c23351b7245d9be4d1b2035fef">&#9670;&nbsp;</a></span>number_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> =  NumberUnsignedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (unsigned) </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes numbers as follows: </p><blockquote class="doxtable">
<p>The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. </p>
</blockquote>
<p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, <a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a>, <a class="el" href="classnlohmann_1_1basic__json.html#ae09af9c23351b7245d9be4d1b2035fef">number_unsigned_t</a> and <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> are used.</p>
<p>To store unsigned integer numbers in C++, a type is defined by the template parameter <em>NumberUnsignedType</em> which chooses the type to use.</p>
<h4><a class="anchor" id="autotoc_md17"></a>
Default type</h4>
<p>With the default values for <em>NumberUnsignedType</em> (<code>uint64_t</code>), the default value for <em>number_unsigned_t</em> is:</p>
<div class="fragment"><div class="line">uint64_t</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18"></a>
Default behavior</h4>
<ul>
<li>The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal <code>010</code> will be serialized to <code>8</code>. During deserialization, leading zeros yield an error.</li>
<li>Not-a-number (NaN) values will be serialized to <code>null</code>.</li>
</ul>
<h4><a class="anchor" id="autotoc_md19"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> specifies: </p><blockquote class="doxtable">
<p>An implementation may set limits on the range and precision of numbers. </p>
</blockquote>
<p>When the default type is used, the maximal integer number that can be stored is <code>18446744073709551615</code> (UINT64_MAX) and the minimal integer number that can be stored is <code>0</code>. Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as <a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a> or <a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a>.</p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> further states: </p><blockquote class="doxtable">
<p>Note that when such software is used, numbers that are integers and are in the range <img class="formulaInl" alt="$[-2^{53}+1, 2^{53}-1]$" src="form_0.png"/> are interoperable in the sense that implementations will agree exactly on their numeric values. </p>
</blockquote>
<p>As this range is a subrange (when considered in conjunction with the number_integer_t type) of the exactly supported range [0, UINT64_MAX], this class's integer type is interoperable.</p>
<h4><a class="anchor" id="autotoc_md20"></a>
Storage</h4>
<p>Integer number values are stored directly inside a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (floating-point) </dd>
<dd>
<a class="el" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for number values (integer)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17266">17266</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac26c2e8d6bcaccde372ceedd81851200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26c2e8d6bcaccde372ceedd81851200">&#9670;&nbsp;</a></span>object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ac26c2e8d6bcaccde372ceedd81851200">object_comparator_t</a> =  std::less&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes JSON objects as follows: </p><blockquote class="doxtable">
<p>An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. </p>
</blockquote>
<p>To store objects in C++, a type is defined by the template parameters described below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>the container to store objects (e.g., <code>std::map</code> or <code>std::unordered_map</code>) </td></tr>
    <tr><td class="paramname">StringType</td><td>the type of the keys or names (e.g., <code>std::string</code>). The comparison function <code>std::less&lt;StringType&gt;</code> is used to order elements inside the container. </td></tr>
    <tr><td class="paramname">AllocatorType</td><td>the allocator to use for objects (e.g., <code>std::allocator</code>)</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md0"></a>
Default type</h4>
<p>With the default values for <em>ObjectType</em> (<code>std::map</code>), <em>StringType</em> (<code>std::string</code>), and <em>AllocatorType</em> (<code>std::allocator</code>), the default value for <em>object_t</em> is:</p>
<div class="fragment"><div class="line">std::map&lt;</div>
<div class="line">  std::string, <span class="comment">// key_type</span></div>
<div class="line">  <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>, <span class="comment">// value_type</span></div>
<div class="line">  std::less&lt;std::string&gt;, <span class="comment">// key_compare</span></div>
<div class="line">  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; <span class="comment">// allocator_type</span></div>
<div class="line">&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1"></a>
Behavior</h4>
<p>The choice of <em>object_t</em> influences the behavior of the JSON class. With the default type, objects have the following behavior:</p>
<ul>
<li>When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings.</li>
<li>When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, <code>{"key": 2, "key": 1}</code> could be equal to either <code>{"key": 1}</code> or <code>{"key": 2}</code>.</li>
<li>Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see <a class="el" href="classnlohmann_1_1basic__json.html#a476756fb08e7f2416aad116d137977f4">dump</a>) in this order. For instance, <code>{"b": 1, "a": 2}</code> and <code>{"a": 2, "b": 1}</code> will be stored and serialized as <code>{"a": 2, "b": 1}</code>.</li>
<li>When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, <code>{"b": 1, "a": 2}</code> and <code>{"a": 2, "b": 1}</code> will be treated as equal.</li>
</ul>
<h4><a class="anchor" id="autotoc_md2"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> specifies: </p><blockquote class="doxtable">
<p>An implementation may set limits on the maximum depth of nesting. </p>
</blockquote>
<p>In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <a class="el" href="classnlohmann_1_1basic__json.html#a1b46c6631e30b8394e89bd1546d69736">max_size</a> function of a JSON object.</p>
<h4><a class="anchor" id="autotoc_md3"></a>
Storage</h4>
<p>Objects are stored as pointers in a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type. That is, for any access to object values, a pointer of type <code>object_t*</code> must be dereferenced.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for an <a class="el" href="classnlohmann_1_1basic__json.html#a2c8d8f5741aedadac8f3bffd8f2ce13e" title="explicitly create a binary array (without subtype)">array</a> <a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659" title="overload for a default value of type const char*">value</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The order name/value pairs are added to the object is <em>not</em> preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as <code>std::map</code> with <code>std::less</code> is used by default. Please note this behavior conforms to <a href="http://rfc7159.net/rfc7159">RFC 7159</a>, because any order implements the specified "unordered" nature of JSON objects. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16908">16908</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aef3ff5a73597850597d1d40db9edd376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3ff5a73597850597d1d40db9edd376">&#9670;&nbsp;</a></span>object_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a> =  ObjectType&lt;StringType, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>, <a class="el" href="classnlohmann_1_1basic__json.html#ac26c2e8d6bcaccde372ceedd81851200">object_comparator_t</a>, AllocatorType&lt;std::pair&lt;const StringType, <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes JSON objects as follows: </p><blockquote class="doxtable">
<p>An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. </p>
</blockquote>
<p>To store objects in C++, a type is defined by the template parameters described below.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ObjectType</td><td>the container to store objects (e.g., <code>std::map</code> or <code>std::unordered_map</code>) </td></tr>
    <tr><td class="paramname">StringType</td><td>the type of the keys or names (e.g., <code>std::string</code>). The comparison function <code>std::less&lt;StringType&gt;</code> is used to order elements inside the container. </td></tr>
    <tr><td class="paramname">AllocatorType</td><td>the allocator to use for objects (e.g., <code>std::allocator</code>)</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md0"></a>
Default type</h4>
<p>With the default values for <em>ObjectType</em> (<code>std::map</code>), <em>StringType</em> (<code>std::string</code>), and <em>AllocatorType</em> (<code>std::allocator</code>), the default value for <em>object_t</em> is:</p>
<div class="fragment"><div class="line">std::map&lt;</div>
<div class="line">  std::string, <span class="comment">// key_type</span></div>
<div class="line">  <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>, <span class="comment">// value_type</span></div>
<div class="line">  std::less&lt;std::string&gt;, <span class="comment">// key_compare</span></div>
<div class="line">  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; <span class="comment">// allocator_type</span></div>
<div class="line">&gt;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1"></a>
Behavior</h4>
<p>The choice of <em>object_t</em> influences the behavior of the JSON class. With the default type, objects have the following behavior:</p>
<ul>
<li>When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings.</li>
<li>When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, <code>{"key": 2, "key": 1}</code> could be equal to either <code>{"key": 1}</code> or <code>{"key": 2}</code>.</li>
<li>Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see <a class="el" href="classnlohmann_1_1basic__json.html#a476756fb08e7f2416aad116d137977f4">dump</a>) in this order. For instance, <code>{"b": 1, "a": 2}</code> and <code>{"a": 2, "b": 1}</code> will be stored and serialized as <code>{"a": 2, "b": 1}</code>.</li>
<li>When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, <code>{"b": 1, "a": 2}</code> and <code>{"a": 2, "b": 1}</code> will be treated as equal.</li>
</ul>
<h4><a class="anchor" id="autotoc_md2"></a>
Limits</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> specifies: </p><blockquote class="doxtable">
<p>An implementation may set limits on the maximum depth of nesting. </p>
</blockquote>
<p>In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <a class="el" href="classnlohmann_1_1basic__json.html#a1b46c6631e30b8394e89bd1546d69736">max_size</a> function of a JSON object.</p>
<h4><a class="anchor" id="autotoc_md3"></a>
Storage</h4>
<p>Objects are stored as pointers in a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type. That is, for any access to object values, a pointer of type <code>object_t*</code> must be dereferenced.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> &ndash; <a class="el" href="classnlohmann_1_1basic__json.html#a5b7c4b35a0ad9f97474912a08965d7ad">type</a> for an <a class="el" href="classnlohmann_1_1basic__json.html#a2c8d8f5741aedadac8f3bffd8f2ce13e" title="explicitly create a binary array (without subtype)">array</a> <a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659" title="overload for a default value of type const char*">value</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The order name/value pairs are added to the object is <em>not</em> preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as <code>std::map</code> with <code>std::less</code> is used by default. Please note this behavior conforms to <a href="http://rfc7159.net/rfc7159">RFC 7159</a>, because any order implements the specified "unordered" nature of JSON objects. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16994">16994</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6fc373c99facc37aadbc5651b3d6631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc373c99facc37aadbc5651b3d6631d">&#9670;&nbsp;</a></span>other_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a6fc373c99facc37aadbc5651b3d6631d">other_error</a> =  <a class="el" href="classnlohmann_1_1detail_1_1other__error.html">detail::other_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16756">16756</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2251d8523fa6d16c0fba6388ffa2ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2251d8523fa6d16c0fba6388ffa2ef8c">&#9670;&nbsp;</a></span>out_of_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a2251d8523fa6d16c0fba6388ffa2ef8c">out_of_range</a> =  <a class="el" href="classnlohmann_1_1detail_1_1out__of__range.html">detail::out_of_range</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16754">16754</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a555b05e9da63d486126759922685a37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555b05e9da63d486126759922685a37a">&#9670;&nbsp;</a></span>parse_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a555b05e9da63d486126759922685a37a">parse_error</a> =  <a class="el" href="classnlohmann_1_1detail_1_1parse__error.html">detail::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16748">16748</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a24086b03c5c063849df0307f78c41c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24086b03c5c063849df0307f78c41c54">&#9670;&nbsp;</a></span>parse_event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1a">parse_event_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1a">detail::parse_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parser event types </p>
<p>The parser callback distinguishes the following events:</p><ul>
<li><code>object_start</code>: the parser read <code>{</code> and started to process a JSON object</li>
<li><code>key</code>: the parser read a key of a value in an object</li>
<li><code>object_end</code>: the parser read <code>}</code> and finished processing a JSON object</li>
<li><code>array_start</code>: the parser read <code>[</code> and started to process a JSON array</li>
<li><code>array_end</code>: the parser read <code>]</code> and finished processing a JSON array</li>
<li><code>value</code>: the parser finished reading a JSON value</li>
</ul>
<div class="image">
<img src="callback_events.png" alt=""/>
<div class="caption">
Example when certain parse events are triggered</div></div>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> for more information and examples </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17745">17745</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0273d074462644e5d5a7ff313ad0d742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0273d074462644e5d5a7ff313ad0d742">&#9670;&nbsp;</a></span>parser_callback_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#a9980144ad77e50ae944d1fe797ceec08">detail::parser_callback_t</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>per-element parser callback type </p>
<p>With a parser callback function, the result of parsing a JSON text can be influenced. When passed to <a class="el" href="classnlohmann_1_1basic__json.html#a15018ade392a844ea32d5188d1a0b9c6">parse</a>, it is called on certain events (passed as <a class="el" href="classnlohmann_1_1basic__json.html#a24086b03c5c063849df0307f78c41c54">parse_event_t</a> via parameter <em>event</em>) with a set recursion depth <em>depth</em> and context JSON value <em>parsed</em>. The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not.</p>
<p>We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters <em>depth</em>, <em>event</em>, and <em>parsed</em>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter <em>event</em>   </th><th class="markdownTableHeadNone">description   </th><th class="markdownTableHeadNone">parameter <em>depth</em>   </th><th class="markdownTableHeadNone">parameter <em>parsed</em>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parse_event_t::object_start   </td><td class="markdownTableBodyNone">the parser read <code>{</code> and started to process a JSON object   </td><td class="markdownTableBodyNone">depth of the parent of the JSON object   </td><td class="markdownTableBodyNone">a JSON value with type discarded    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d" title="the parser read a key of a value in an object">parse_event_t::key</a>   </td><td class="markdownTableBodyNone">the parser read a key of a value in an object   </td><td class="markdownTableBodyNone">depth of the currently parsed JSON object   </td><td class="markdownTableBodyNone">a JSON string containing the key    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parse_event_t::object_end   </td><td class="markdownTableBodyNone">the parser read <code>}</code> and finished processing a JSON object   </td><td class="markdownTableBodyNone">depth of the parent of the JSON object   </td><td class="markdownTableBodyNone">the parsed JSON object    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">parse_event_t::array_start   </td><td class="markdownTableBodyNone">the parser read <code>[</code> and started to process a JSON array   </td><td class="markdownTableBodyNone">depth of the parent of the JSON array   </td><td class="markdownTableBodyNone">a JSON value with type discarded    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parse_event_t::array_end   </td><td class="markdownTableBodyNone">the parser read <code>]</code> and finished processing a JSON array   </td><td class="markdownTableBodyNone">depth of the parent of the JSON array   </td><td class="markdownTableBodyNone">the parsed JSON array    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa2063c1608d6e0baf80249c42e2be5804" title="the parser finished reading a JSON value">parse_event_t::value</a>   </td><td class="markdownTableBodyNone">the parser finished reading a JSON value   </td><td class="markdownTableBodyNone">depth of the value   </td><td class="markdownTableBodyNone">the parsed JSON value   </td></tr>
</table>
<div class="image">
<img src="callback_events.png" alt=""/>
<div class="caption">
Example when certain parse events are triggered</div></div>
<p>Discarding a value (i.e., returning <code>false</code>) has different effects depending on the context in which function was called:</p>
<ul>
<li>Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read.</li>
<li>In case a value outside a structured type is skipped, it is replaced with <code>null</code>. This case happens if the top-level element is skipped.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>the depth of the recursion during parsing</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>an event of type parse_event_t indicating the context in the callback function has been called</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parsed</td><td>the current intermediate parse result; note that writing to this value has no effect for <a class="el" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d" title="the parser read a key of a value in an object">parse_event_t::key</a> events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the JSON value which called the function during parsing should be kept (<code>true</code>) or not (<code>false</code>). In the latter case, it is either skipped completely or replaced by an empty discarded object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a15018ade392a844ea32d5188d1a0b9c6">parse</a> for examples</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17796">17796</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a42e5c23402f4c2e1df487e1d102bc5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e5c23402f4c2e1df487e1d102bc5fa">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a42e5c23402f4c2e1df487e1d102bc5fa">pointer</a> =  typename std::allocator_traits&lt;<a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a>&gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a42e5c23402f4c2e1df487e1d102bc5fa">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16787">16787</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a220ae98554a76205fb7f8822d36b2d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220ae98554a76205fb7f8822d36b2d5a">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> =  <a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16774">16774</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5b8c0ebedd920b507f4f7ff4e19bf3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8c0ebedd920b507f4f7ff4e19bf3c6">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a> =  <a class="el" href="classnlohmann_1_1detail_1_1json__reverse__iterator.html">json_reverse_iterator</a>&lt;typename <a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">basic_json::iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a reverse iterator for a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16796">16796</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a3ada29bca70b4965f6fd37ec1c8f85f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ada29bca70b4965f6fd37ec1c8f85f7">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent container sizes </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16781">16781</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a33593865ffb1860323dcbd52425b90c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33593865ffb1860323dcbd52425b90c8">&#9670;&nbsp;</a></span>string_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> =  StringType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a string </p>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> describes JSON strings as follows: </p><blockquote class="doxtable">
<p>A string is a sequence of zero or more Unicode characters. </p>
</blockquote>
<p>To store objects in C++, a type is defined by the template parameter described below. Unicode values are split by the JSON class into byte-sized characters during deserialization.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringType</td><td>the container to store strings (e.g., <code>std::string</code>). Note this container is used for keys/names in objects, see <a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md7"></a>
Default type</h4>
<p>With the default values for <em>StringType</em> (<code>std::string</code>), the default value for <em>string_t</em> is:</p>
<div class="fragment"><div class="line">std::string</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md8"></a>
Encoding</h4>
<p>Strings are stored in UTF-8 encoding. Therefore, functions like <code>std::string::size()</code> or <code>std::string::length()</code> return the number of bytes in the string rather than the number of characters or glyphs.</p>
<h4><a class="anchor" id="autotoc_md9"></a>
String comparison</h4>
<p><a href="http://rfc7159.net/rfc7159">RFC 7159</a> states: </p><blockquote class="doxtable">
<p>Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that <code>"a\\b"</code> and <code>"a\u005Cb"</code> are not equal. </p>
</blockquote>
<p>This implementation is interoperable as it does compare strings code unit by code unit.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
Storage</h4>
<p>String values are stored as pointers in a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type. That is, for any access to string values, a pointer of type <code>string_t*</code> must be dereferenced.</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17097">17097</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ace5bf851eafe85bd6332f978991bc11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5bf851eafe85bd6332f978991bc11c">&#9670;&nbsp;</a></span>type_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#ace5bf851eafe85bd6332f978991bc11c">type_error</a> =  <a class="el" href="classnlohmann_1_1detail_1_1type__error.html">detail::type_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16752">16752</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac68cb65a7f3517f0c5b1d3a4967406ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68cb65a7f3517f0c5b1d3a4967406ad">&#9670;&nbsp;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> =  <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">detail::value_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16721">16721</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a57c816a20c1d3ccc9bbc2972829da847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c816a20c1d3ccc9bbc2972829da847">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html#a57c816a20c1d3ccc9bbc2972829da847">value_type</a> =  <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of elements in a <a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16771">16771</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19734fbc9c97d536832892ddacd6b62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19734fbc9c97d536832892ddacd6b62a">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17837">17837</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l17838"></a><span class="lineno">17838</span>&#160;                : m_type(v), m_value(v)</div>
<div class="line"><a name="l17839"></a><span class="lineno">17839</span>&#160;            {</div>
<div class="line"><a name="l17840"></a><span class="lineno">17840</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l17841"></a><span class="lineno">17841</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ace6fbaf6c64f60b61922b5c9d3e61aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6fbaf6c64f60b61922b5c9d3e61aa6">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17861">17861</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l17862"></a><span class="lineno">17862</span>&#160;                : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>)</div>
<div class="line"><a name="l17863"></a><span class="lineno">17863</span>&#160;            {</div>
<div class="line"><a name="l17864"></a><span class="lineno">17864</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l17865"></a><span class="lineno">17865</span>&#160;            }</div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">nlohmann::detail::value_t::null</a></div><div class="ttdeci">@ null</div><div class="ttdoc">null value</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b5d76a1546257689ad260ed34ec20b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5d76a1546257689ad260ed34ec20b5">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">CompatibleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17934">17934</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l17937"></a><span class="lineno">17937</span>&#160;            {</div>
<div class="line"><a name="l17938"></a><span class="lineno">17938</span>&#160;                <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;U&gt;::to_json</a>(*<span class="keyword">this</span>, std::forward&lt;CompatibleType&gt;(val));</div>
<div class="line"><a name="l17939"></a><span class="lineno">17939</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l17940"></a><span class="lineno">17940</span>&#160;            }</div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_aaa77b0c9745130b77733a92a1a2e82ec"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">nlohmann::detail::to_json</a></div><div class="ttdeci">void to_json(BasicJsonType &amp;j, const T &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l04333">json.hpp:4333</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a40738eb9cb8c5a9ca14ae4b697c29f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40738eb9cb8c5a9ca14ae4b697c29f8e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an existing one </p>
<p>This is a constructor for existing <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones.</p>
<p>The constructor tries to convert the internal m_value of the parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>a type such that:<ul>
<li><em>BasicJsonType</em> is a <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type.</li>
<li><em>BasicJsonType</em> has different template arguments than basic_json_t.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Usually linear in the size of the passed <em>val</em>, also depending on the implementation of the called <code><a class="el" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">to_json()</a></code> method.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Depends</td><td>on the called constructor. For types directly supported by the library (i.e., all types for which no <code><a class="el" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">to_json()</a></code> function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l17971">17971</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l17972"></a><span class="lineno">17972</span>&#160;            {</div>
<div class="line"><a name="l17973"></a><span class="lineno">17973</span>&#160;                <span class="keyword">using</span> other_boolean_t = <span class="keyword">typename</span> BasicJsonType::boolean_t;</div>
<div class="line"><a name="l17974"></a><span class="lineno">17974</span>&#160;                <span class="keyword">using</span> other_number_float_t = <span class="keyword">typename</span> BasicJsonType::number_float_t;</div>
<div class="line"><a name="l17975"></a><span class="lineno">17975</span>&#160;                <span class="keyword">using</span> other_number_integer_t = <span class="keyword">typename</span> BasicJsonType::number_integer_t;</div>
<div class="line"><a name="l17976"></a><span class="lineno">17976</span>&#160;                <span class="keyword">using</span> other_number_unsigned_t = <span class="keyword">typename</span> BasicJsonType::number_unsigned_t;</div>
<div class="line"><a name="l17977"></a><span class="lineno">17977</span>&#160;                <span class="keyword">using</span> other_string_t = <span class="keyword">typename</span> BasicJsonType::string_t;</div>
<div class="line"><a name="l17978"></a><span class="lineno">17978</span>&#160;                <span class="keyword">using</span> other_object_t = <span class="keyword">typename</span> BasicJsonType::object_t;</div>
<div class="line"><a name="l17979"></a><span class="lineno">17979</span>&#160;                <span class="keyword">using</span> other_array_t = <span class="keyword">typename</span> BasicJsonType::array_t;</div>
<div class="line"><a name="l17980"></a><span class="lineno">17980</span>&#160;                <span class="keyword">using</span> other_binary_t = <span class="keyword">typename</span> BasicJsonType::binary_t;</div>
<div class="line"><a name="l17981"></a><span class="lineno">17981</span>&#160; </div>
<div class="line"><a name="l17982"></a><span class="lineno">17982</span>&#160;                <span class="keywordflow">switch</span> (val.type())</div>
<div class="line"><a name="l17983"></a><span class="lineno">17983</span>&#160;                {</div>
<div class="line"><a name="l17984"></a><span class="lineno">17984</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l17985"></a><span class="lineno">17985</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_boolean_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get&lt;other_boolean_t&gt;());</div>
<div class="line"><a name="l17986"></a><span class="lineno">17986</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l17987"></a><span class="lineno">17987</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l17988"></a><span class="lineno">17988</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_number_float_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get&lt;other_number_float_t&gt;());</div>
<div class="line"><a name="l17989"></a><span class="lineno">17989</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l17990"></a><span class="lineno">17990</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l17991"></a><span class="lineno">17991</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_number_integer_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get&lt;other_number_integer_t&gt;());</div>
<div class="line"><a name="l17992"></a><span class="lineno">17992</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l17993"></a><span class="lineno">17993</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l17994"></a><span class="lineno">17994</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_number_unsigned_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get&lt;other_number_unsigned_t&gt;());</div>
<div class="line"><a name="l17995"></a><span class="lineno">17995</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l17996"></a><span class="lineno">17996</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l17997"></a><span class="lineno">17997</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_string_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get_ref&lt;const other_string_t&amp;&gt;());</div>
<div class="line"><a name="l17998"></a><span class="lineno">17998</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l17999"></a><span class="lineno">17999</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l18000"></a><span class="lineno">18000</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_object_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get_ref&lt;const other_object_t&amp;&gt;());</div>
<div class="line"><a name="l18001"></a><span class="lineno">18001</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18002"></a><span class="lineno">18002</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l18003"></a><span class="lineno">18003</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_array_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get_ref&lt;const other_array_t&amp;&gt;());</div>
<div class="line"><a name="l18004"></a><span class="lineno">18004</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18005"></a><span class="lineno">18005</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l18006"></a><span class="lineno">18006</span>&#160;                        <a class="code" href="namespacenlohmann_1_1detail.html#aaa77b0c9745130b77733a92a1a2e82ec">JSONSerializer&lt;other_binary_t&gt;::to_json</a>(*<span class="keyword">this</span>, val.template get_ref&lt;const other_binary_t&amp;&gt;());</div>
<div class="line"><a name="l18007"></a><span class="lineno">18007</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18008"></a><span class="lineno">18008</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l18009"></a><span class="lineno">18009</span>&#160;                        *<span class="keyword">this</span> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l18010"></a><span class="lineno">18010</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18011"></a><span class="lineno">18011</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>:</div>
<div class="line"><a name="l18012"></a><span class="lineno">18012</span>&#160;                        m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>;</div>
<div class="line"><a name="l18013"></a><span class="lineno">18013</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18014"></a><span class="lineno">18014</span>&#160;                    <span class="keywordflow">default</span>:            <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><a name="l18015"></a><span class="lineno">18015</span>&#160;                        <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(<span class="keyword">false</span>);  <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><a name="l18016"></a><span class="lineno">18016</span>&#160;                }</div>
<div class="line"><a name="l18017"></a><span class="lineno">18017</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18018"></a><span class="lineno">18018</span>&#160;            }</div>
<div class="ttc" id="ajson_8hpp_html_a69f131cff49da1989667220173fbeae6"><div class="ttname"><a href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a></div><div class="ttdeci">#define JSON_ASSERT(x)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02103">json.hpp:2103</a></div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">nlohmann::detail::value_t::number_integer</a></div><div class="ttdeci">@ number_integer</div><div class="ttdoc">number value (signed integer)</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">nlohmann::detail::value_t::boolean</a></div><div class="ttdeci">@ boolean</div><div class="ttdoc">boolean value</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">nlohmann::detail::value_t::discarded</a></div><div class="ttdeci">@ discarded</div><div class="ttdoc">discarded by the parser callback function</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">nlohmann::detail::value_t::binary</a></div><div class="ttdeci">@ binary</div><div class="ttdoc">binary array (ordered collection of bytes)</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">nlohmann::detail::value_t::object</a></div><div class="ttdeci">@ object</div><div class="ttdoc">object (unordered set of name/value pairs)</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">nlohmann::detail::value_t::string</a></div><div class="ttdeci">@ string</div><div class="ttdoc">string value</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">nlohmann::detail::value_t::number_float</a></div><div class="ttdeci">@ number_float</div><div class="ttdoc">number value (floating-point)</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">nlohmann::detail::value_t::number_unsigned</a></div><div class="ttdeci">@ number_unsigned</div><div class="ttdoc">number value (unsigned integer)</div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">nlohmann::detail::value_t::array</a></div><div class="ttdeci">@ array</div><div class="ttdoc">array (ordered collection of values)</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeac617faf3448d6d2cb33a020be01d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac617faf3448d6d2cb33a020be01d37">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_deduction</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a>&#160;</td>
          <td class="paramname"><em>manual_type</em> = <code><a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18094">18094</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18097"></a><span class="lineno">18097</span>&#160;            {</div>
<div class="line"><a name="l18098"></a><span class="lineno">18098</span>&#160;                <span class="comment">// check if each element is an array with two elements whose first</span></div>
<div class="line"><a name="l18099"></a><span class="lineno">18099</span>&#160;                <span class="comment">// element is a string</span></div>
<div class="line"><a name="l18100"></a><span class="lineno">18100</span>&#160;                <span class="keywordtype">bool</span> is_an_object = std::all_of(init.begin(), init.end(),</div>
<div class="line"><a name="l18101"></a><span class="lineno">18101</span>&#160;                                                [](<span class="keyword">const</span> detail::json_ref&lt;basic_json&gt;&amp; element_ref)</div>
<div class="line"><a name="l18102"></a><span class="lineno">18102</span>&#160;                {</div>
<div class="line"><a name="l18103"></a><span class="lineno">18103</span>&#160;                    return element_ref-&gt;is_array() &amp;&amp; element_ref-&gt;size() == 2 &amp;&amp; (*element_ref)[0].is_string();</div>
<div class="line"><a name="l18104"></a><span class="lineno">18104</span>&#160;                });</div>
<div class="line"><a name="l18105"></a><span class="lineno">18105</span>&#160; </div>
<div class="line"><a name="l18106"></a><span class="lineno">18106</span>&#160;                <span class="comment">// adjust type if type deduction is not wanted</span></div>
<div class="line"><a name="l18107"></a><span class="lineno">18107</span>&#160;                <span class="keywordflow">if</span> (!type_deduction)</div>
<div class="line"><a name="l18108"></a><span class="lineno">18108</span>&#160;                {</div>
<div class="line"><a name="l18109"></a><span class="lineno">18109</span>&#160;                    <span class="comment">// if array is wanted, do not create an object though possible</span></div>
<div class="line"><a name="l18110"></a><span class="lineno">18110</span>&#160;                    <span class="keywordflow">if</span> (manual_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</div>
<div class="line"><a name="l18111"></a><span class="lineno">18111</span>&#160;                    {</div>
<div class="line"><a name="l18112"></a><span class="lineno">18112</span>&#160;                        is_an_object = <span class="keyword">false</span>;</div>
<div class="line"><a name="l18113"></a><span class="lineno">18113</span>&#160;                    }</div>
<div class="line"><a name="l18114"></a><span class="lineno">18114</span>&#160; </div>
<div class="line"><a name="l18115"></a><span class="lineno">18115</span>&#160;                    <span class="comment">// if object is wanted but impossible, throw an exception</span></div>
<div class="line"><a name="l18116"></a><span class="lineno">18116</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(manual_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a> &amp;&amp; !is_an_object))</div>
<div class="line"><a name="l18117"></a><span class="lineno">18117</span>&#160;                    {</div>
<div class="line"><a name="l18118"></a><span class="lineno">18118</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(301, <span class="stringliteral">&quot;cannot create object from initializer list&quot;</span>));</div>
<div class="line"><a name="l18119"></a><span class="lineno">18119</span>&#160;                    }</div>
<div class="line"><a name="l18120"></a><span class="lineno">18120</span>&#160;                }</div>
<div class="line"><a name="l18121"></a><span class="lineno">18121</span>&#160; </div>
<div class="line"><a name="l18122"></a><span class="lineno">18122</span>&#160;                <span class="keywordflow">if</span> (is_an_object)</div>
<div class="line"><a name="l18123"></a><span class="lineno">18123</span>&#160;                {</div>
<div class="line"><a name="l18124"></a><span class="lineno">18124</span>&#160;                    <span class="comment">// the initializer list is a list of pairs -&gt; create object</span></div>
<div class="line"><a name="l18125"></a><span class="lineno">18125</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l18126"></a><span class="lineno">18126</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l18127"></a><span class="lineno">18127</span>&#160; </div>
<div class="line"><a name="l18128"></a><span class="lineno">18128</span>&#160;                    std::for_each(init.begin(), init.end(), [<span class="keyword">this</span>](<span class="keyword">const</span> detail::json_ref&lt;basic_json&gt;&amp; element_ref)</div>
<div class="line"><a name="l18129"></a><span class="lineno">18129</span>&#160;                    {</div>
<div class="line"><a name="l18130"></a><span class="lineno">18130</span>&#160;                        auto element = element_ref.moved_or_copied();</div>
<div class="line"><a name="l18131"></a><span class="lineno">18131</span>&#160;                        m_value.object-&gt;emplace(</div>
<div class="line"><a name="l18132"></a><span class="lineno">18132</span>&#160;                                    std::move(*((*element.m_value.array)[0].m_value.string)),</div>
<div class="line"><a name="l18133"></a><span class="lineno">18133</span>&#160;                                std::move((*element.m_value.array)[1]));</div>
<div class="line"><a name="l18134"></a><span class="lineno">18134</span>&#160;                    });</div>
<div class="line"><a name="l18135"></a><span class="lineno">18135</span>&#160;                }</div>
<div class="line"><a name="l18136"></a><span class="lineno">18136</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l18137"></a><span class="lineno">18137</span>&#160;                {</div>
<div class="line"><a name="l18138"></a><span class="lineno">18138</span>&#160;                    <span class="comment">// the initializer list describes an array -&gt; create array</span></div>
<div class="line"><a name="l18139"></a><span class="lineno">18139</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l18140"></a><span class="lineno">18140</span>&#160;                    m_value.array = create&lt;array_t&gt;(init.begin(), init.end());</div>
<div class="line"><a name="l18141"></a><span class="lineno">18141</span>&#160;                }</div>
<div class="line"><a name="l18142"></a><span class="lineno">18142</span>&#160; </div>
<div class="line"><a name="l18143"></a><span class="lineno">18143</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18144"></a><span class="lineno">18144</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1detail_1_1type__error_html_aecc083aea4b698c33d042670ba50c10f"><div class="ttname"><a href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">nlohmann::detail::type_error::create</a></div><div class="ttdeci">static type_error create(int id_, const std::string &amp;what_arg)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02570">json.hpp:2570</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a6c274f6db2e65c1b66c7d41b06ad690f"><div class="ttname"><a href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a></div><div class="ttdeci">#define JSON_THROW(exception)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02074">json.hpp:2074</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a8df7de76ab3c9445f46f6994ec205bcd"><div class="ttname"><a href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a></div><div class="ttdeci">#define JSON_HEDLEY_UNLIKELY(expr)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l01404">json.hpp:1404</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbccea367512a87b5d76e2bd92c5cc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbccea367512a87b5d76e2bd92c5cc85">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18348">18348</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18349"></a><span class="lineno">18349</span>&#160;                : m_type(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</div>
<div class="line"><a name="l18350"></a><span class="lineno">18350</span>&#160;            {</div>
<div class="line"><a name="l18351"></a><span class="lineno">18351</span>&#160;                m_value.array = create&lt;array_t&gt;(cnt, val);</div>
<div class="line"><a name="l18352"></a><span class="lineno">18352</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18353"></a><span class="lineno">18353</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23e540f473d32f1cf5d3243ea3ad495e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e540f473d32f1cf5d3243ea3ad495e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18413">18413</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18414"></a><span class="lineno">18414</span>&#160;            {</div>
<div class="line"><a name="l18415"></a><span class="lineno">18415</span>&#160;                <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(first.m_object != <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l18416"></a><span class="lineno">18416</span>&#160;                <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(last.m_object != <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l18417"></a><span class="lineno">18417</span>&#160; </div>
<div class="line"><a name="l18418"></a><span class="lineno">18418</span>&#160;                <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><a name="l18419"></a><span class="lineno">18419</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(first.m_object != last.m_object))</div>
<div class="line"><a name="l18420"></a><span class="lineno">18420</span>&#160;                {</div>
<div class="line"><a name="l18421"></a><span class="lineno">18421</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(201, <span class="stringliteral">&quot;iterators are not compatible&quot;</span>));</div>
<div class="line"><a name="l18422"></a><span class="lineno">18422</span>&#160;                }</div>
<div class="line"><a name="l18423"></a><span class="lineno">18423</span>&#160; </div>
<div class="line"><a name="l18424"></a><span class="lineno">18424</span>&#160;                <span class="comment">// copy type from first iterator</span></div>
<div class="line"><a name="l18425"></a><span class="lineno">18425</span>&#160;                m_type = first.m_object-&gt;m_type;</div>
<div class="line"><a name="l18426"></a><span class="lineno">18426</span>&#160; </div>
<div class="line"><a name="l18427"></a><span class="lineno">18427</span>&#160;                <span class="comment">// check if iterator range is complete for primitive values</span></div>
<div class="line"><a name="l18428"></a><span class="lineno">18428</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l18429"></a><span class="lineno">18429</span>&#160;                {</div>
<div class="line"><a name="l18430"></a><span class="lineno">18430</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l18431"></a><span class="lineno">18431</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l18432"></a><span class="lineno">18432</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l18433"></a><span class="lineno">18433</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l18434"></a><span class="lineno">18434</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l18435"></a><span class="lineno">18435</span>&#160;                    {</div>
<div class="line"><a name="l18436"></a><span class="lineno">18436</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!first.m_it.primitive_iterator.is_begin()</div>
<div class="line"><a name="l18437"></a><span class="lineno">18437</span>&#160;                                                 || !last.m_it.primitive_iterator.is_end()))</div>
<div class="line"><a name="l18438"></a><span class="lineno">18438</span>&#160;                        {</div>
<div class="line"><a name="l18439"></a><span class="lineno">18439</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(204, <span class="stringliteral">&quot;iterators out of range&quot;</span>));</div>
<div class="line"><a name="l18440"></a><span class="lineno">18440</span>&#160;                        }</div>
<div class="line"><a name="l18441"></a><span class="lineno">18441</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18442"></a><span class="lineno">18442</span>&#160;                    }</div>
<div class="line"><a name="l18443"></a><span class="lineno">18443</span>&#160; </div>
<div class="line"><a name="l18444"></a><span class="lineno">18444</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l18445"></a><span class="lineno">18445</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18446"></a><span class="lineno">18446</span>&#160;                }</div>
<div class="line"><a name="l18447"></a><span class="lineno">18447</span>&#160; </div>
<div class="line"><a name="l18448"></a><span class="lineno">18448</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l18449"></a><span class="lineno">18449</span>&#160;                {</div>
<div class="line"><a name="l18450"></a><span class="lineno">18450</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l18451"></a><span class="lineno">18451</span>&#160;                    {</div>
<div class="line"><a name="l18452"></a><span class="lineno">18452</span>&#160;                        m_value.number_integer = first.m_object-&gt;m_value.number_integer;</div>
<div class="line"><a name="l18453"></a><span class="lineno">18453</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18454"></a><span class="lineno">18454</span>&#160;                    }</div>
<div class="line"><a name="l18455"></a><span class="lineno">18455</span>&#160; </div>
<div class="line"><a name="l18456"></a><span class="lineno">18456</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l18457"></a><span class="lineno">18457</span>&#160;                    {</div>
<div class="line"><a name="l18458"></a><span class="lineno">18458</span>&#160;                        m_value.number_unsigned = first.m_object-&gt;m_value.number_unsigned;</div>
<div class="line"><a name="l18459"></a><span class="lineno">18459</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18460"></a><span class="lineno">18460</span>&#160;                    }</div>
<div class="line"><a name="l18461"></a><span class="lineno">18461</span>&#160; </div>
<div class="line"><a name="l18462"></a><span class="lineno">18462</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l18463"></a><span class="lineno">18463</span>&#160;                    {</div>
<div class="line"><a name="l18464"></a><span class="lineno">18464</span>&#160;                        m_value.number_float = first.m_object-&gt;m_value.number_float;</div>
<div class="line"><a name="l18465"></a><span class="lineno">18465</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18466"></a><span class="lineno">18466</span>&#160;                    }</div>
<div class="line"><a name="l18467"></a><span class="lineno">18467</span>&#160; </div>
<div class="line"><a name="l18468"></a><span class="lineno">18468</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l18469"></a><span class="lineno">18469</span>&#160;                    {</div>
<div class="line"><a name="l18470"></a><span class="lineno">18470</span>&#160;                        m_value.boolean = first.m_object-&gt;m_value.boolean;</div>
<div class="line"><a name="l18471"></a><span class="lineno">18471</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18472"></a><span class="lineno">18472</span>&#160;                    }</div>
<div class="line"><a name="l18473"></a><span class="lineno">18473</span>&#160; </div>
<div class="line"><a name="l18474"></a><span class="lineno">18474</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l18475"></a><span class="lineno">18475</span>&#160;                    {</div>
<div class="line"><a name="l18476"></a><span class="lineno">18476</span>&#160;                        m_value = *first.m_object-&gt;m_value.string;</div>
<div class="line"><a name="l18477"></a><span class="lineno">18477</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18478"></a><span class="lineno">18478</span>&#160;                    }</div>
<div class="line"><a name="l18479"></a><span class="lineno">18479</span>&#160; </div>
<div class="line"><a name="l18480"></a><span class="lineno">18480</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l18481"></a><span class="lineno">18481</span>&#160;                    {</div>
<div class="line"><a name="l18482"></a><span class="lineno">18482</span>&#160;                        m_value.object = create&lt;object_t&gt;(first.m_it.object_iterator,</div>
<div class="line"><a name="l18483"></a><span class="lineno">18483</span>&#160;                                                          last.m_it.object_iterator);</div>
<div class="line"><a name="l18484"></a><span class="lineno">18484</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18485"></a><span class="lineno">18485</span>&#160;                    }</div>
<div class="line"><a name="l18486"></a><span class="lineno">18486</span>&#160; </div>
<div class="line"><a name="l18487"></a><span class="lineno">18487</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l18488"></a><span class="lineno">18488</span>&#160;                    {</div>
<div class="line"><a name="l18489"></a><span class="lineno">18489</span>&#160;                        m_value.array = create&lt;array_t&gt;(first.m_it.array_iterator,</div>
<div class="line"><a name="l18490"></a><span class="lineno">18490</span>&#160;                                                        last.m_it.array_iterator);</div>
<div class="line"><a name="l18491"></a><span class="lineno">18491</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18492"></a><span class="lineno">18492</span>&#160;                    }</div>
<div class="line"><a name="l18493"></a><span class="lineno">18493</span>&#160; </div>
<div class="line"><a name="l18494"></a><span class="lineno">18494</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l18495"></a><span class="lineno">18495</span>&#160;                    {</div>
<div class="line"><a name="l18496"></a><span class="lineno">18496</span>&#160;                        m_value = *first.m_object-&gt;m_value.binary;</div>
<div class="line"><a name="l18497"></a><span class="lineno">18497</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18498"></a><span class="lineno">18498</span>&#160;                    }</div>
<div class="line"><a name="l18499"></a><span class="lineno">18499</span>&#160; </div>
<div class="line"><a name="l18500"></a><span class="lineno">18500</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l18501"></a><span class="lineno">18501</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(206, <span class="stringliteral">&quot;cannot construct with iterators from &quot;</span> +</div>
<div class="line"><a name="l18502"></a><span class="lineno">18502</span>&#160;                                                            std::string(first.m_object-&gt;type_name())));</div>
<div class="line"><a name="l18503"></a><span class="lineno">18503</span>&#160;                }</div>
<div class="line"><a name="l18504"></a><span class="lineno">18504</span>&#160; </div>
<div class="line"><a name="l18505"></a><span class="lineno">18505</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18506"></a><span class="lineno">18506</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1detail_1_1invalid__iterator_html_a4e849260a3caa1b288c7e619130c6c09"><div class="ttname"><a href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">nlohmann::detail::invalid_iterator::create</a></div><div class="ttdeci">static invalid_iterator create(int id_, const std::string &amp;what_arg)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02516">json.hpp:2516</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28524e9c443076ea6dccff8e391354ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28524e9c443076ea6dccff8e391354ed">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename JsonRef , detail::enable_if_t&lt; detail::conjunction&lt; detail::is_json_ref&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, basic_json &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const JsonRef &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18516">18516</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18516"></a><span class="lineno">18516</span>&#160;: <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(ref.moved_or_copied()) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a603be713183ad63dd8c9e1052c606004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603be713183ad63dd8c9e1052c606004">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18543">18543</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18544"></a><span class="lineno">18544</span>&#160;                : m_type(other.m_type)</div>
<div class="line"><a name="l18545"></a><span class="lineno">18545</span>&#160;            {</div>
<div class="line"><a name="l18546"></a><span class="lineno">18546</span>&#160;                <span class="comment">// check of passed value is valid</span></div>
<div class="line"><a name="l18547"></a><span class="lineno">18547</span>&#160;                other.assert_invariant();</div>
<div class="line"><a name="l18548"></a><span class="lineno">18548</span>&#160; </div>
<div class="line"><a name="l18549"></a><span class="lineno">18549</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l18550"></a><span class="lineno">18550</span>&#160;                {</div>
<div class="line"><a name="l18551"></a><span class="lineno">18551</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l18552"></a><span class="lineno">18552</span>&#160;                    {</div>
<div class="line"><a name="l18553"></a><span class="lineno">18553</span>&#160;                        m_value = *other.m_value.object;</div>
<div class="line"><a name="l18554"></a><span class="lineno">18554</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18555"></a><span class="lineno">18555</span>&#160;                    }</div>
<div class="line"><a name="l18556"></a><span class="lineno">18556</span>&#160; </div>
<div class="line"><a name="l18557"></a><span class="lineno">18557</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l18558"></a><span class="lineno">18558</span>&#160;                    {</div>
<div class="line"><a name="l18559"></a><span class="lineno">18559</span>&#160;                        m_value = *other.m_value.array;</div>
<div class="line"><a name="l18560"></a><span class="lineno">18560</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18561"></a><span class="lineno">18561</span>&#160;                    }</div>
<div class="line"><a name="l18562"></a><span class="lineno">18562</span>&#160; </div>
<div class="line"><a name="l18563"></a><span class="lineno">18563</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l18564"></a><span class="lineno">18564</span>&#160;                    {</div>
<div class="line"><a name="l18565"></a><span class="lineno">18565</span>&#160;                        m_value = *other.m_value.string;</div>
<div class="line"><a name="l18566"></a><span class="lineno">18566</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18567"></a><span class="lineno">18567</span>&#160;                    }</div>
<div class="line"><a name="l18568"></a><span class="lineno">18568</span>&#160; </div>
<div class="line"><a name="l18569"></a><span class="lineno">18569</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l18570"></a><span class="lineno">18570</span>&#160;                    {</div>
<div class="line"><a name="l18571"></a><span class="lineno">18571</span>&#160;                        m_value = other.m_value.boolean;</div>
<div class="line"><a name="l18572"></a><span class="lineno">18572</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18573"></a><span class="lineno">18573</span>&#160;                    }</div>
<div class="line"><a name="l18574"></a><span class="lineno">18574</span>&#160; </div>
<div class="line"><a name="l18575"></a><span class="lineno">18575</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l18576"></a><span class="lineno">18576</span>&#160;                    {</div>
<div class="line"><a name="l18577"></a><span class="lineno">18577</span>&#160;                        m_value = other.m_value.number_integer;</div>
<div class="line"><a name="l18578"></a><span class="lineno">18578</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18579"></a><span class="lineno">18579</span>&#160;                    }</div>
<div class="line"><a name="l18580"></a><span class="lineno">18580</span>&#160; </div>
<div class="line"><a name="l18581"></a><span class="lineno">18581</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l18582"></a><span class="lineno">18582</span>&#160;                    {</div>
<div class="line"><a name="l18583"></a><span class="lineno">18583</span>&#160;                        m_value = other.m_value.number_unsigned;</div>
<div class="line"><a name="l18584"></a><span class="lineno">18584</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18585"></a><span class="lineno">18585</span>&#160;                    }</div>
<div class="line"><a name="l18586"></a><span class="lineno">18586</span>&#160; </div>
<div class="line"><a name="l18587"></a><span class="lineno">18587</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l18588"></a><span class="lineno">18588</span>&#160;                    {</div>
<div class="line"><a name="l18589"></a><span class="lineno">18589</span>&#160;                        m_value = other.m_value.number_float;</div>
<div class="line"><a name="l18590"></a><span class="lineno">18590</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18591"></a><span class="lineno">18591</span>&#160;                    }</div>
<div class="line"><a name="l18592"></a><span class="lineno">18592</span>&#160; </div>
<div class="line"><a name="l18593"></a><span class="lineno">18593</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l18594"></a><span class="lineno">18594</span>&#160;                    {</div>
<div class="line"><a name="l18595"></a><span class="lineno">18595</span>&#160;                        m_value = *other.m_value.binary;</div>
<div class="line"><a name="l18596"></a><span class="lineno">18596</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18597"></a><span class="lineno">18597</span>&#160;                    }</div>
<div class="line"><a name="l18598"></a><span class="lineno">18598</span>&#160; </div>
<div class="line"><a name="l18599"></a><span class="lineno">18599</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l18600"></a><span class="lineno">18600</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l18601"></a><span class="lineno">18601</span>&#160;                }</div>
<div class="line"><a name="l18602"></a><span class="lineno">18602</span>&#160; </div>
<div class="line"><a name="l18603"></a><span class="lineno">18603</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18604"></a><span class="lineno">18604</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a642afd9d8886e0dedfc0d5cee2baf57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642afd9d8886e0dedfc0d5cee2baf57f">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18632">18632</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18633"></a><span class="lineno">18633</span>&#160;                : m_type(std::move(other.m_type)),</div>
<div class="line"><a name="l18634"></a><span class="lineno">18634</span>&#160;                  m_value(std::move(other.m_value))</div>
<div class="line"><a name="l18635"></a><span class="lineno">18635</span>&#160;            {</div>
<div class="line"><a name="l18636"></a><span class="lineno">18636</span>&#160;                <span class="comment">// check that passed value is valid</span></div>
<div class="line"><a name="l18637"></a><span class="lineno">18637</span>&#160;                other.assert_invariant();</div>
<div class="line"><a name="l18638"></a><span class="lineno">18638</span>&#160; </div>
<div class="line"><a name="l18639"></a><span class="lineno">18639</span>&#160;                <span class="comment">// invalidate payload</span></div>
<div class="line"><a name="l18640"></a><span class="lineno">18640</span>&#160;                other.m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>;</div>
<div class="line"><a name="l18641"></a><span class="lineno">18641</span>&#160;                other.m_value = {};</div>
<div class="line"><a name="l18642"></a><span class="lineno">18642</span>&#160; </div>
<div class="line"><a name="l18643"></a><span class="lineno">18643</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18644"></a><span class="lineno">18644</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a60b643c02a19fa52f99db8215ff58e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b643c02a19fa52f99db8215ff58e0f">&#9670;&nbsp;</a></span>~basic_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::~<a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<p>Destroys the JSON value and frees all allocated memory.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Linear.</dd>
<dd>
This function helps <code><a class="el" href="classnlohmann_1_1basic__json.html" title="a class to store JSON values">basic_json</a></code> satisfying the <a href="https://en.cppreference.com/w/cpp/named_req/Container">Container</a> requirements:<ul>
<li>The complexity is linear.</li>
<li>All stored elements are destroyed and all memory is freed.</li>
</ul>
</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18702">18702</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18703"></a><span class="lineno">18703</span>&#160;            {</div>
<div class="line"><a name="l18704"></a><span class="lineno">18704</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18705"></a><span class="lineno">18705</span>&#160;                m_value.destroy(m_type);</div>
<div class="line"><a name="l18706"></a><span class="lineno">18706</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6d9e85910b91d02f6807b69b61690a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9e85910b91d02f6807b69b61690a4b">&#9670;&nbsp;</a></span>accept() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23250">23250</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23252"></a><span class="lineno">23252</span>&#160;            {</div>
<div class="line"><a name="l23253"></a><span class="lineno">23253</span>&#160;                                           <span class="keywordflow">return</span> parser(i.get(), <span class="keyword">nullptr</span>, <span class="keyword">false</span>, ignore_comments).accept(<span class="keyword">true</span>);</div>
<div class="line"><a name="l23254"></a><span class="lineno">23254</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a32872afe5bfd040777e3e2bb85f0ca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32872afe5bfd040777e3e2bb85f0ca55">&#9670;&nbsp;</a></span>accept() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23235">23235</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23237"></a><span class="lineno">23237</span>&#160;            {</div>
<div class="line"><a name="l23238"></a><span class="lineno">23238</span>&#160;                                           <span class="keywordflow">return</span> parser(<a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i)), <span class="keyword">nullptr</span>, <span class="keyword">false</span>, ignore_comments).accept(<span class="keyword">true</span>);</div>
<div class="line"><a name="l23239"></a><span class="lineno">23239</span>&#160;    }</div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_ad11a087dbe66eade5af4056aef9600bf"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">nlohmann::detail::input_adapter</a></div><div class="ttdeci">iterator_input_adapter_factory&lt; IteratorType &gt;::adapter_type input_adapter(IteratorType first, IteratorType last)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l05091">json.hpp:5091</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a47fb596473649332185aedb0a8a6ccc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fb596473649332185aedb0a8a6ccc5">&#9670;&nbsp;</a></span>accept() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23242">23242</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23244"></a><span class="lineno">23244</span>&#160;            {</div>
<div class="line"><a name="l23245"></a><span class="lineno">23245</span>&#160;                                           <span class="keywordflow">return</span> parser(<a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last)), <span class="keyword">nullptr</span>, <span class="keyword">false</span>, ignore_comments).accept(<span class="keyword">true</span>);</div>
<div class="line"><a name="l23246"></a><span class="lineno">23246</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c8d8f5741aedadac8f3bffd8f2ce13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8d8f5741aedadac8f3bffd8f2ce13e">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18277">18277</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18277"></a><span class="lineno">18277</span>&#160;                                                              {})</div>
<div class="line"><a name="l18278"></a><span class="lineno">18278</span>&#160;            {</div>
<div class="line"><a name="l18279"></a><span class="lineno">18279</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(init, <span class="keyword">false</span>, <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>);</div>
<div class="line"><a name="l18280"></a><span class="lineno">18280</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa014a978f8b6c085db8825faa8dad320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa014a978f8b6c085db8825faa8dad320">&#9670;&nbsp;</a></span>at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24501">24501</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24502"></a><span class="lineno">24502</span>&#160;            {</div>
<div class="line"><a name="l24503"></a><span class="lineno">24503</span>&#160;                <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><a name="l24504"></a><span class="lineno">24504</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8284b9c1d4d0830151eaa000f907b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8284b9c1d4d0830151eaa000f907b2e6">&#9670;&nbsp;</a></span>at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24544">24544</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24545"></a><span class="lineno">24545</span>&#160;            {</div>
<div class="line"><a name="l24546"></a><span class="lineno">24546</span>&#160;                <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><a name="l24547"></a><span class="lineno">24547</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a239e942da82f2597d0cf5ec806f5bc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239e942da82f2597d0cf5ec806f5bc0d">&#9670;&nbsp;</a></span>at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19898">19898</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19899"></a><span class="lineno">19899</span>&#160;            {</div>
<div class="line"><a name="l19900"></a><span class="lineno">19900</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l19901"></a><span class="lineno">19901</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l19902"></a><span class="lineno">19902</span>&#160;                {</div>
<div class="line"><a name="l19903"></a><span class="lineno">19903</span>&#160;                    <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l19904"></a><span class="lineno">19904</span>&#160;                    {</div>
<div class="line"><a name="l19905"></a><span class="lineno">19905</span>&#160;                        <span class="keywordflow">return</span> m_value.object-&gt;at(key);</div>
<div class="line"><a name="l19906"></a><span class="lineno">19906</span>&#160;                    }</div>
<div class="line"><a name="l19907"></a><span class="lineno">19907</span>&#160;                    <a class="code" href="json_8hpp.html#a6954bec49ed2a2dfb938c1131c82740a">JSON_CATCH</a> (std::out_of_range&amp;)</div>
<div class="line"><a name="l19908"></a><span class="lineno">19908</span>&#160;                    {</div>
<div class="line"><a name="l19909"></a><span class="lineno">19909</span>&#160;                        <span class="comment">// create better exception explanation</span></div>
<div class="line"><a name="l19910"></a><span class="lineno">19910</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(403, <span class="stringliteral">&quot;key &#39;&quot;</span> + key + <span class="stringliteral">&quot;&#39; not found&quot;</span>));</div>
<div class="line"><a name="l19911"></a><span class="lineno">19911</span>&#160;                    }</div>
<div class="line"><a name="l19912"></a><span class="lineno">19912</span>&#160;                }</div>
<div class="line"><a name="l19913"></a><span class="lineno">19913</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l19914"></a><span class="lineno">19914</span>&#160;                {</div>
<div class="line"><a name="l19915"></a><span class="lineno">19915</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(304, <span class="stringliteral">&quot;cannot use at() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19916"></a><span class="lineno">19916</span>&#160;                }</div>
<div class="line"><a name="l19917"></a><span class="lineno">19917</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a459dbfcd47bd632ca82ca8ff8db278c8"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">nlohmann::basic_json::type_name</a></div><div class="ttdeci">JSON_HEDLEY_RETURNS_NON_NULL const char * type_name() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23419">json.hpp:23419</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a57e8411a770a6263d6d8f2116c37f3aa"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">nlohmann::basic_json::is_object</a></div><div class="ttdeci">constexpr bool is_object() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19058">json.hpp:19058</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1detail_1_1out__of__range_html_a3f6d82a6f967c4728a1ec735a7867073"><div class="ttname"><a href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">nlohmann::detail::out_of_range::create</a></div><div class="ttdeci">static out_of_range create(int id_, const std::string &amp;what_arg)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02617">json.hpp:2617</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a355f2770653ff7bdd5c74b204b5a3ad0"><div class="ttname"><a href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a></div><div class="ttdeci">#define JSON_HEDLEY_LIKELY(expr)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l01403">json.hpp:1403</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a6954bec49ed2a2dfb938c1131c82740a"><div class="ttname"><a href="json_8hpp.html#a6954bec49ed2a2dfb938c1131c82740a">JSON_CATCH</a></div><div class="ttdeci">#define JSON_CATCH(exception)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02076">json.hpp:2076</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a985d3b82445302c57257f6432f261fe9"><div class="ttname"><a href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div><div class="ttdeci">#define JSON_TRY</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02075">json.hpp:2075</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a229964ee10c92ba89ae4fba786fe6b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229964ee10c92ba89ae4fba786fe6b50">&#9670;&nbsp;</a></span>at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19949">19949</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19950"></a><span class="lineno">19950</span>&#160;            {</div>
<div class="line"><a name="l19951"></a><span class="lineno">19951</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l19952"></a><span class="lineno">19952</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l19953"></a><span class="lineno">19953</span>&#160;                {</div>
<div class="line"><a name="l19954"></a><span class="lineno">19954</span>&#160;                    <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l19955"></a><span class="lineno">19955</span>&#160;                    {</div>
<div class="line"><a name="l19956"></a><span class="lineno">19956</span>&#160;                        <span class="keywordflow">return</span> m_value.object-&gt;at(key);</div>
<div class="line"><a name="l19957"></a><span class="lineno">19957</span>&#160;                    }</div>
<div class="line"><a name="l19958"></a><span class="lineno">19958</span>&#160;                    <a class="code" href="json_8hpp.html#a6954bec49ed2a2dfb938c1131c82740a">JSON_CATCH</a> (std::out_of_range&amp;)</div>
<div class="line"><a name="l19959"></a><span class="lineno">19959</span>&#160;                    {</div>
<div class="line"><a name="l19960"></a><span class="lineno">19960</span>&#160;                        <span class="comment">// create better exception explanation</span></div>
<div class="line"><a name="l19961"></a><span class="lineno">19961</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(403, <span class="stringliteral">&quot;key &#39;&quot;</span> + key + <span class="stringliteral">&quot;&#39; not found&quot;</span>));</div>
<div class="line"><a name="l19962"></a><span class="lineno">19962</span>&#160;                    }</div>
<div class="line"><a name="l19963"></a><span class="lineno">19963</span>&#160;                }</div>
<div class="line"><a name="l19964"></a><span class="lineno">19964</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l19965"></a><span class="lineno">19965</span>&#160;                {</div>
<div class="line"><a name="l19966"></a><span class="lineno">19966</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(304, <span class="stringliteral">&quot;cannot use at() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19967"></a><span class="lineno">19967</span>&#160;                }</div>
<div class="line"><a name="l19968"></a><span class="lineno">19968</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a52b18a5b7e68652c65b070900c438c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b18a5b7e68652c65b070900c438c6e">&#9670;&nbsp;</a></span>at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19800">19800</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19801"></a><span class="lineno">19801</span>&#160;            {</div>
<div class="line"><a name="l19802"></a><span class="lineno">19802</span>&#160;                <span class="comment">// at only works for arrays</span></div>
<div class="line"><a name="l19803"></a><span class="lineno">19803</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l19804"></a><span class="lineno">19804</span>&#160;                {</div>
<div class="line"><a name="l19805"></a><span class="lineno">19805</span>&#160;                    <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l19806"></a><span class="lineno">19806</span>&#160;                    {</div>
<div class="line"><a name="l19807"></a><span class="lineno">19807</span>&#160;                        <span class="keywordflow">return</span> m_value.array-&gt;at(idx);</div>
<div class="line"><a name="l19808"></a><span class="lineno">19808</span>&#160;                    }</div>
<div class="line"><a name="l19809"></a><span class="lineno">19809</span>&#160;                    <a class="code" href="json_8hpp.html#a6954bec49ed2a2dfb938c1131c82740a">JSON_CATCH</a> (std::out_of_range&amp;)</div>
<div class="line"><a name="l19810"></a><span class="lineno">19810</span>&#160;                    {</div>
<div class="line"><a name="l19811"></a><span class="lineno">19811</span>&#160;                        <span class="comment">// create better exception explanation</span></div>
<div class="line"><a name="l19812"></a><span class="lineno">19812</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(401, <span class="stringliteral">&quot;array index &quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(idx) + <span class="stringliteral">&quot; is out of range&quot;</span>));</div>
<div class="line"><a name="l19813"></a><span class="lineno">19813</span>&#160;                    }</div>
<div class="line"><a name="l19814"></a><span class="lineno">19814</span>&#160;                }</div>
<div class="line"><a name="l19815"></a><span class="lineno">19815</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l19816"></a><span class="lineno">19816</span>&#160;                {</div>
<div class="line"><a name="l19817"></a><span class="lineno">19817</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(304, <span class="stringliteral">&quot;cannot use at() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19818"></a><span class="lineno">19818</span>&#160;                }</div>
<div class="line"><a name="l19819"></a><span class="lineno">19819</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ab5b70d60a636b9c5e10f6c8caac60b9e"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">nlohmann::basic_json::is_array</a></div><div class="ttdeci">constexpr bool is_array() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19080">json.hpp:19080</a></div></div>
<div class="ttc" id="anamespacenlohmann_html_a6ce645a0b8717757e096a5b5773b7a16"><div class="ttname"><a href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">nlohmann::to_string</a></div><div class="ttdeci">NLOHMANN_BASIC_JSON_TPL_DECLARATION std::string to_string(const NLOHMANN_BASIC_JSON_TPL &amp;j)</div><div class="ttdoc">user-defined to_string function for JSON values</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l25179">json.hpp:25179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb18fe2b8a5dbff4ccf2848de854c3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb18fe2b8a5dbff4ccf2848de854c3ac">&#9670;&nbsp;</a></span>at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19847">19847</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19848"></a><span class="lineno">19848</span>&#160;            {</div>
<div class="line"><a name="l19849"></a><span class="lineno">19849</span>&#160;                <span class="comment">// at only works for arrays</span></div>
<div class="line"><a name="l19850"></a><span class="lineno">19850</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l19851"></a><span class="lineno">19851</span>&#160;                {</div>
<div class="line"><a name="l19852"></a><span class="lineno">19852</span>&#160;                    <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l19853"></a><span class="lineno">19853</span>&#160;                    {</div>
<div class="line"><a name="l19854"></a><span class="lineno">19854</span>&#160;                        <span class="keywordflow">return</span> m_value.array-&gt;at(idx);</div>
<div class="line"><a name="l19855"></a><span class="lineno">19855</span>&#160;                    }</div>
<div class="line"><a name="l19856"></a><span class="lineno">19856</span>&#160;                    <a class="code" href="json_8hpp.html#a6954bec49ed2a2dfb938c1131c82740a">JSON_CATCH</a> (std::out_of_range&amp;)</div>
<div class="line"><a name="l19857"></a><span class="lineno">19857</span>&#160;                    {</div>
<div class="line"><a name="l19858"></a><span class="lineno">19858</span>&#160;                        <span class="comment">// create better exception explanation</span></div>
<div class="line"><a name="l19859"></a><span class="lineno">19859</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(401, <span class="stringliteral">&quot;array index &quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(idx) + <span class="stringliteral">&quot; is out of range&quot;</span>));</div>
<div class="line"><a name="l19860"></a><span class="lineno">19860</span>&#160;                    }</div>
<div class="line"><a name="l19861"></a><span class="lineno">19861</span>&#160;                }</div>
<div class="line"><a name="l19862"></a><span class="lineno">19862</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l19863"></a><span class="lineno">19863</span>&#160;                {</div>
<div class="line"><a name="l19864"></a><span class="lineno">19864</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(304, <span class="stringliteral">&quot;cannot use at() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19865"></a><span class="lineno">19865</span>&#160;                }</div>
<div class="line"><a name="l19866"></a><span class="lineno">19866</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a30914ad0767ccdc3633f88a906ed7dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30914ad0767ccdc3633f88a906ed7dfa">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20456">20456</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20457"></a><span class="lineno">20457</span>&#160;            {</div>
<div class="line"><a name="l20458"></a><span class="lineno">20458</span>&#160;                <span class="keyword">auto</span> tmp = <a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>();</div>
<div class="line"><a name="l20459"></a><span class="lineno">20459</span>&#160;                --tmp;</div>
<div class="line"><a name="l20460"></a><span class="lineno">20460</span>&#160;                <span class="keywordflow">return</span> *tmp;</div>
<div class="line"><a name="l20461"></a><span class="lineno">20461</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a931267ec3f09eb67e4382f321b2c52bc"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">nlohmann::basic_json::end</a></div><div class="ttdeci">iterator end() noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21044">json.hpp:21044</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aac965b84ea43ccd8aef9caefef02794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac965b84ea43ccd8aef9caefef02794a">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20466">20466</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20467"></a><span class="lineno">20467</span>&#160;            {</div>
<div class="line"><a name="l20468"></a><span class="lineno">20468</span>&#160;                <span class="keyword">auto</span> tmp = <a class="code" href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">cend</a>();</div>
<div class="line"><a name="l20469"></a><span class="lineno">20469</span>&#160;                --tmp;</div>
<div class="line"><a name="l20470"></a><span class="lineno">20470</span>&#160;                <span class="keywordflow">return</span> *tmp;</div>
<div class="line"><a name="l20471"></a><span class="lineno">20471</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a3017cf0f1a4673e904e34cfef62e7758"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">nlohmann::basic_json::cend</a></div><div class="ttdeci">const_iterator cend() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21084">json.hpp:21084</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f147be16fcde9f510c4aac89ab511c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f147be16fcde9f510c4aac89ab511c9">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20983">20983</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20984"></a><span class="lineno">20984</span>&#160;            {</div>
<div class="line"><a name="l20985"></a><span class="lineno">20985</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ae508c13e3ad6ce445bcaf24a2bc7d039">cbegin</a>();</div>
<div class="line"><a name="l20986"></a><span class="lineno">20986</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ae508c13e3ad6ce445bcaf24a2bc7d039"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ae508c13e3ad6ce445bcaf24a2bc7d039">nlohmann::basic_json::cbegin</a></div><div class="ttdeci">const_iterator cbegin() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21013">json.hpp:21013</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a23b495b4c282e4afacf382f5b49af7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b495b4c282e4afacf382f5b49af7c7">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20973">20973</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20974"></a><span class="lineno">20974</span>&#160;            {</div>
<div class="line"><a name="l20975"></a><span class="lineno">20975</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><a name="l20976"></a><span class="lineno">20976</span>&#160;                result.set_begin();</div>
<div class="line"><a name="l20977"></a><span class="lineno">20977</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l20978"></a><span class="lineno">20978</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aa549b2b382916b3baafb526e5cb410bd"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">nlohmann::basic_json::iterator</a></div><div class="ttdeci">iter_impl&lt; basic_json &gt; iterator</div><div class="ttdoc">an iterator for a basic_json container</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16792">json.hpp:16792</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d255dbe024ce2d0fdfb1b4837629091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d255dbe024ce2d0fdfb1b4837629091">&#9670;&nbsp;</a></span>binary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18174">18174</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18175"></a><span class="lineno">18175</span>&#160;            {</div>
<div class="line"><a name="l18176"></a><span class="lineno">18176</span>&#160;                <span class="keyword">auto</span> res = <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>();</div>
<div class="line"><a name="l18177"></a><span class="lineno">18177</span>&#160;                res.m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>;</div>
<div class="line"><a name="l18178"></a><span class="lineno">18178</span>&#160;                res.m_value = init;</div>
<div class="line"><a name="l18179"></a><span class="lineno">18179</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l18180"></a><span class="lineno">18180</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd2c506b279049f7d92ad7ae10a2f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2c506b279049f7d92ad7ae10a2f12b">&#9670;&nbsp;</a></span>binary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtype</td><td>subtype to use in MessagePack and BSON</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18211">18211</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18212"></a><span class="lineno">18212</span>&#160;            {</div>
<div class="line"><a name="l18213"></a><span class="lineno">18213</span>&#160;                <span class="keyword">auto</span> res = <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>();</div>
<div class="line"><a name="l18214"></a><span class="lineno">18214</span>&#160;                res.m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>;</div>
<div class="line"><a name="l18215"></a><span class="lineno">18215</span>&#160;                res.m_value = <a class="code" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a>(init, subtype);</div>
<div class="line"><a name="l18216"></a><span class="lineno">18216</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l18217"></a><span class="lineno">18217</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ad6c955145bebde84d93991ffed7cd389"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">nlohmann::basic_json::binary_t</a></div><div class="ttdeci">nlohmann::byte_container_with_subtype&lt; BinaryType &gt; binary_t</div><div class="ttdoc">a type for a packed binary type</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l17405">json.hpp:17405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab085777bbfbfac5a472120b991ef5cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab085777bbfbfac5a472120b991ef5cf3">&#9670;&nbsp;</a></span>binary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18221">18221</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18222"></a><span class="lineno">18222</span>&#160;            {</div>
<div class="line"><a name="l18223"></a><span class="lineno">18223</span>&#160;                <span class="keyword">auto</span> res = <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>();</div>
<div class="line"><a name="l18224"></a><span class="lineno">18224</span>&#160;                res.m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>;</div>
<div class="line"><a name="l18225"></a><span class="lineno">18225</span>&#160;                res.m_value = std::move(init);</div>
<div class="line"><a name="l18226"></a><span class="lineno">18226</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l18227"></a><span class="lineno">18227</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a012e375f4016b89444c528ed46cce3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012e375f4016b89444c528ed46cce3af">&#9670;&nbsp;</a></span>binary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtype</td><td>subtype to use in MessagePack and BSON</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18231">18231</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18232"></a><span class="lineno">18232</span>&#160;            {</div>
<div class="line"><a name="l18233"></a><span class="lineno">18233</span>&#160;                <span class="keyword">auto</span> res = <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>();</div>
<div class="line"><a name="l18234"></a><span class="lineno">18234</span>&#160;                res.m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>;</div>
<div class="line"><a name="l18235"></a><span class="lineno">18235</span>&#160;                res.m_value = <a class="code" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a>(std::move(init), subtype);</div>
<div class="line"><a name="l18236"></a><span class="lineno">18236</span>&#160;                <span class="keywordflow">return</span> res;</div>
<div class="line"><a name="l18237"></a><span class="lineno">18237</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae508c13e3ad6ce445bcaf24a2bc7d039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae508c13e3ad6ce445bcaf24a2bc7d039">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21013">21013</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21014"></a><span class="lineno">21014</span>&#160;            {</div>
<div class="line"><a name="l21015"></a><span class="lineno">21015</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><a name="l21016"></a><span class="lineno">21016</span>&#160;                result.set_begin();</div>
<div class="line"><a name="l21017"></a><span class="lineno">21017</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l21018"></a><span class="lineno">21018</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aebd2cfa7e4ded4e97cde9269bfeeea38"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">nlohmann::basic_json::const_iterator</a></div><div class="ttdeci">iter_impl&lt; const basic_json &gt; const_iterator</div><div class="ttdoc">a const iterator for a basic_json container</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16794">json.hpp:16794</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3017cf0f1a4673e904e34cfef62e7758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3017cf0f1a4673e904e34cfef62e7758">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21084">21084</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21085"></a><span class="lineno">21085</span>&#160;            {</div>
<div class="line"><a name="l21086"></a><span class="lineno">21086</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><a name="l21087"></a><span class="lineno">21087</span>&#160;                result.set_end();</div>
<div class="line"><a name="l21088"></a><span class="lineno">21088</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l21089"></a><span class="lineno">21089</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a946cc8f30d8b1d6609b57387b647fe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946cc8f30d8b1d6609b57387b647fe53">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21643">21643</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21644"></a><span class="lineno">21644</span>&#160;            {</div>
<div class="line"><a name="l21645"></a><span class="lineno">21645</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l21646"></a><span class="lineno">21646</span>&#160;                {</div>
<div class="line"><a name="l21647"></a><span class="lineno">21647</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l21648"></a><span class="lineno">21648</span>&#160;                    {</div>
<div class="line"><a name="l21649"></a><span class="lineno">21649</span>&#160;                        m_value.number_integer = 0;</div>
<div class="line"><a name="l21650"></a><span class="lineno">21650</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21651"></a><span class="lineno">21651</span>&#160;                    }</div>
<div class="line"><a name="l21652"></a><span class="lineno">21652</span>&#160; </div>
<div class="line"><a name="l21653"></a><span class="lineno">21653</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l21654"></a><span class="lineno">21654</span>&#160;                    {</div>
<div class="line"><a name="l21655"></a><span class="lineno">21655</span>&#160;                        m_value.number_unsigned = 0;</div>
<div class="line"><a name="l21656"></a><span class="lineno">21656</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21657"></a><span class="lineno">21657</span>&#160;                    }</div>
<div class="line"><a name="l21658"></a><span class="lineno">21658</span>&#160; </div>
<div class="line"><a name="l21659"></a><span class="lineno">21659</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l21660"></a><span class="lineno">21660</span>&#160;                    {</div>
<div class="line"><a name="l21661"></a><span class="lineno">21661</span>&#160;                        m_value.number_float = 0.0;</div>
<div class="line"><a name="l21662"></a><span class="lineno">21662</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21663"></a><span class="lineno">21663</span>&#160;                    }</div>
<div class="line"><a name="l21664"></a><span class="lineno">21664</span>&#160; </div>
<div class="line"><a name="l21665"></a><span class="lineno">21665</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l21666"></a><span class="lineno">21666</span>&#160;                    {</div>
<div class="line"><a name="l21667"></a><span class="lineno">21667</span>&#160;                        m_value.boolean = <span class="keyword">false</span>;</div>
<div class="line"><a name="l21668"></a><span class="lineno">21668</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21669"></a><span class="lineno">21669</span>&#160;                    }</div>
<div class="line"><a name="l21670"></a><span class="lineno">21670</span>&#160; </div>
<div class="line"><a name="l21671"></a><span class="lineno">21671</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l21672"></a><span class="lineno">21672</span>&#160;                    {</div>
<div class="line"><a name="l21673"></a><span class="lineno">21673</span>&#160;                        m_value.string-&gt;clear();</div>
<div class="line"><a name="l21674"></a><span class="lineno">21674</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21675"></a><span class="lineno">21675</span>&#160;                    }</div>
<div class="line"><a name="l21676"></a><span class="lineno">21676</span>&#160; </div>
<div class="line"><a name="l21677"></a><span class="lineno">21677</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l21678"></a><span class="lineno">21678</span>&#160;                    {</div>
<div class="line"><a name="l21679"></a><span class="lineno">21679</span>&#160;                        m_value.binary-&gt;clear();</div>
<div class="line"><a name="l21680"></a><span class="lineno">21680</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21681"></a><span class="lineno">21681</span>&#160;                    }</div>
<div class="line"><a name="l21682"></a><span class="lineno">21682</span>&#160; </div>
<div class="line"><a name="l21683"></a><span class="lineno">21683</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l21684"></a><span class="lineno">21684</span>&#160;                    {</div>
<div class="line"><a name="l21685"></a><span class="lineno">21685</span>&#160;                        m_value.array-&gt;clear();</div>
<div class="line"><a name="l21686"></a><span class="lineno">21686</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21687"></a><span class="lineno">21687</span>&#160;                    }</div>
<div class="line"><a name="l21688"></a><span class="lineno">21688</span>&#160; </div>
<div class="line"><a name="l21689"></a><span class="lineno">21689</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l21690"></a><span class="lineno">21690</span>&#160;                    {</div>
<div class="line"><a name="l21691"></a><span class="lineno">21691</span>&#160;                        m_value.object-&gt;clear();</div>
<div class="line"><a name="l21692"></a><span class="lineno">21692</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21693"></a><span class="lineno">21693</span>&#160;                    }</div>
<div class="line"><a name="l21694"></a><span class="lineno">21694</span>&#160; </div>
<div class="line"><a name="l21695"></a><span class="lineno">21695</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l21696"></a><span class="lineno">21696</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l21697"></a><span class="lineno">21697</span>&#160;                }</div>
<div class="line"><a name="l21698"></a><span class="lineno">21698</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb82c1f34c73486e013da71ae369e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb82c1f34c73486e013da71ae369e597">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<p>find an element in a JSON object</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20934">20934</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20935"></a><span class="lineno">20935</span>&#160;            {</div>
<div class="line"><a name="l20936"></a><span class="lineno">20936</span>&#160;                <span class="keywordflow">return</span> ptr.contains(<span class="keyword">this</span>);</div>
<div class="line"><a name="l20937"></a><span class="lineno">20937</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c9bc4d0f33b7dec20b2798301d6971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c9bc4d0f33b7dec20b2798301d6971">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KeyT , typename std::enable_if&lt; !std::is_same&lt; typename std::decay&lt; KeyT &gt;::type, json_pointer &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">KeyT &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<p>find an element in a JSON object</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20903">20903</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20904"></a><span class="lineno">20904</span>&#160;            {</div>
<div class="line"><a name="l20905"></a><span class="lineno">20905</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>() &amp;&amp; m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key)) != m_value.object-&gt;end();</div>
<div class="line"><a name="l20906"></a><span class="lineno">20906</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba5ec6d1e37eda6b11eba491a1e5237e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5ec6d1e37eda6b11eba491a1e5237e">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">KeyT &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<p>find an element in a JSON object</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20870">20870</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20871"></a><span class="lineno">20871</span>&#160;            {</div>
<div class="line"><a name="l20872"></a><span class="lineno">20872</span>&#160;                <span class="comment">// return 0 for all nonobject types</span></div>
<div class="line"><a name="l20873"></a><span class="lineno">20873</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>() ? m_value.object-&gt;count(std::forward&lt;KeyT&gt;(key)) : 0;</div>
<div class="line"><a name="l20874"></a><span class="lineno">20874</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a044298d189bdf7e4b36492de9811ddd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044298d189bdf7e4b36492de9811ddd6">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21188">21188</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21189"></a><span class="lineno">21189</span>&#160;            {</div>
<div class="line"><a name="l21190"></a><span class="lineno">21190</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">cend</a>());</div>
<div class="line"><a name="l21191"></a><span class="lineno">21191</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aa7dba16ed9ee97380aeb17a207dd919a"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">nlohmann::basic_json::const_reverse_iterator</a></div><div class="ttdeci">json_reverse_iterator&lt; typename basic_json::const_iterator &gt; const_reverse_iterator</div><div class="ttdoc">a const reverse iterator for a basic_json container</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16798">json.hpp:16798</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a223480466a0922267d680ec8f0722d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223480466a0922267d680ec8f0722d58">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21217">21217</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21218"></a><span class="lineno">21218</span>&#160;            {</div>
<div class="line"><a name="l21219"></a><span class="lineno">21219</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ae508c13e3ad6ce445bcaf24a2bc7d039">cbegin</a>());</div>
<div class="line"><a name="l21220"></a><span class="lineno">21220</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c1f21327df91a4dd6c5f5a107240385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1f21327df91a4dd6c5f5a107240385">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24965">24965</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24967"></a><span class="lineno">24967</span>&#160;            {</div>
<div class="line"><a name="l24968"></a><span class="lineno">24968</span>&#160;                <span class="comment">// the patch</span></div>
<div class="line"><a name="l24969"></a><span class="lineno">24969</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>);</div>
<div class="line"><a name="l24970"></a><span class="lineno">24970</span>&#160; </div>
<div class="line"><a name="l24971"></a><span class="lineno">24971</span>&#160;                <span class="comment">// if the values are the same, return empty patch</span></div>
<div class="line"><a name="l24972"></a><span class="lineno">24972</span>&#160;                <span class="keywordflow">if</span> (source == target)</div>
<div class="line"><a name="l24973"></a><span class="lineno">24973</span>&#160;                {</div>
<div class="line"><a name="l24974"></a><span class="lineno">24974</span>&#160;                    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l24975"></a><span class="lineno">24975</span>&#160;                }</div>
<div class="line"><a name="l24976"></a><span class="lineno">24976</span>&#160; </div>
<div class="line"><a name="l24977"></a><span class="lineno">24977</span>&#160;                <span class="keywordflow">if</span> (source.type() != target.type())</div>
<div class="line"><a name="l24978"></a><span class="lineno">24978</span>&#160;                {</div>
<div class="line"><a name="l24979"></a><span class="lineno">24979</span>&#160;                    <span class="comment">// different types: replace value</span></div>
<div class="line"><a name="l24980"></a><span class="lineno">24980</span>&#160;                    result.push_back(</div>
<div class="line"><a name="l24981"></a><span class="lineno">24981</span>&#160;                                {</div>
<div class="line"><a name="l24982"></a><span class="lineno">24982</span>&#160;                                    {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;replace&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path}, {<span class="stringliteral">&quot;value&quot;</span>, target}</div>
<div class="line"><a name="l24983"></a><span class="lineno">24983</span>&#160;                                });</div>
<div class="line"><a name="l24984"></a><span class="lineno">24984</span>&#160;                    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l24985"></a><span class="lineno">24985</span>&#160;                }</div>
<div class="line"><a name="l24986"></a><span class="lineno">24986</span>&#160; </div>
<div class="line"><a name="l24987"></a><span class="lineno">24987</span>&#160;                <span class="keywordflow">switch</span> (source.type())</div>
<div class="line"><a name="l24988"></a><span class="lineno">24988</span>&#160;                {</div>
<div class="line"><a name="l24989"></a><span class="lineno">24989</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l24990"></a><span class="lineno">24990</span>&#160;                    {</div>
<div class="line"><a name="l24991"></a><span class="lineno">24991</span>&#160;                        <span class="comment">// first pass: traverse common elements</span></div>
<div class="line"><a name="l24992"></a><span class="lineno">24992</span>&#160;                        std::size_t i = 0;</div>
<div class="line"><a name="l24993"></a><span class="lineno">24993</span>&#160;                        <span class="keywordflow">while</span> (i &lt; source.size() &amp;&amp; i &lt; target.size())</div>
<div class="line"><a name="l24994"></a><span class="lineno">24994</span>&#160;                        {</div>
<div class="line"><a name="l24995"></a><span class="lineno">24995</span>&#160;                            <span class="comment">// recursive call to compare array values at index i</span></div>
<div class="line"><a name="l24996"></a><span class="lineno">24996</span>&#160;                            <span class="keyword">auto</span> temp_diff = <a class="code" href="classnlohmann_1_1basic__json.html#a1c1f21327df91a4dd6c5f5a107240385">diff</a>(source[i], target[i], path + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(i));</div>
<div class="line"><a name="l24997"></a><span class="lineno">24997</span>&#160;                            result.insert(result.end(), temp_diff.begin(), temp_diff.end());</div>
<div class="line"><a name="l24998"></a><span class="lineno">24998</span>&#160;                            ++i;</div>
<div class="line"><a name="l24999"></a><span class="lineno">24999</span>&#160;                        }</div>
<div class="line"><a name="l25000"></a><span class="lineno">25000</span>&#160; </div>
<div class="line"><a name="l25001"></a><span class="lineno">25001</span>&#160;                        <span class="comment">// i now reached the end of at least one array</span></div>
<div class="line"><a name="l25002"></a><span class="lineno">25002</span>&#160;                        <span class="comment">// in a second pass, traverse the remaining elements</span></div>
<div class="line"><a name="l25003"></a><span class="lineno">25003</span>&#160; </div>
<div class="line"><a name="l25004"></a><span class="lineno">25004</span>&#160;                        <span class="comment">// remove my remaining elements</span></div>
<div class="line"><a name="l25005"></a><span class="lineno">25005</span>&#160;                        <span class="keyword">const</span> <span class="keyword">auto</span> end_index = <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">difference_type</a><span class="keyword">&gt;</span>(result.size());</div>
<div class="line"><a name="l25006"></a><span class="lineno">25006</span>&#160;                        <span class="keywordflow">while</span> (i &lt; source.size())</div>
<div class="line"><a name="l25007"></a><span class="lineno">25007</span>&#160;                        {</div>
<div class="line"><a name="l25008"></a><span class="lineno">25008</span>&#160;                            <span class="comment">// add operations in reverse order to avoid invalid</span></div>
<div class="line"><a name="l25009"></a><span class="lineno">25009</span>&#160;                            <span class="comment">// indices</span></div>
<div class="line"><a name="l25010"></a><span class="lineno">25010</span>&#160;                            result.insert(result.begin() + end_index, <a class="code" href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903">object</a>(</div>
<div class="line"><a name="l25011"></a><span class="lineno">25011</span>&#160;                                              {</div>
<div class="line"><a name="l25012"></a><span class="lineno">25012</span>&#160;                                                  {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;remove&quot;</span>},</div>
<div class="line"><a name="l25013"></a><span class="lineno">25013</span>&#160;                                                  {<span class="stringliteral">&quot;path&quot;</span>, path + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(i)}</div>
<div class="line"><a name="l25014"></a><span class="lineno">25014</span>&#160;                                              }));</div>
<div class="line"><a name="l25015"></a><span class="lineno">25015</span>&#160;                            ++i;</div>
<div class="line"><a name="l25016"></a><span class="lineno">25016</span>&#160;                        }</div>
<div class="line"><a name="l25017"></a><span class="lineno">25017</span>&#160; </div>
<div class="line"><a name="l25018"></a><span class="lineno">25018</span>&#160;                        <span class="comment">// add other remaining elements</span></div>
<div class="line"><a name="l25019"></a><span class="lineno">25019</span>&#160;                        <span class="keywordflow">while</span> (i &lt; target.size())</div>
<div class="line"><a name="l25020"></a><span class="lineno">25020</span>&#160;                        {</div>
<div class="line"><a name="l25021"></a><span class="lineno">25021</span>&#160;                            result.push_back(</div>
<div class="line"><a name="l25022"></a><span class="lineno">25022</span>&#160;                                        {</div>
<div class="line"><a name="l25023"></a><span class="lineno">25023</span>&#160;                                            {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>},</div>
<div class="line"><a name="l25024"></a><span class="lineno">25024</span>&#160;                                            {<span class="stringliteral">&quot;path&quot;</span>, path + <span class="stringliteral">&quot;/-&quot;</span>},</div>
<div class="line"><a name="l25025"></a><span class="lineno">25025</span>&#160;                                            {<span class="stringliteral">&quot;value&quot;</span>, target[i]}</div>
<div class="line"><a name="l25026"></a><span class="lineno">25026</span>&#160;                                        });</div>
<div class="line"><a name="l25027"></a><span class="lineno">25027</span>&#160;                            ++i;</div>
<div class="line"><a name="l25028"></a><span class="lineno">25028</span>&#160;                        }</div>
<div class="line"><a name="l25029"></a><span class="lineno">25029</span>&#160; </div>
<div class="line"><a name="l25030"></a><span class="lineno">25030</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l25031"></a><span class="lineno">25031</span>&#160;                    }</div>
<div class="line"><a name="l25032"></a><span class="lineno">25032</span>&#160; </div>
<div class="line"><a name="l25033"></a><span class="lineno">25033</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l25034"></a><span class="lineno">25034</span>&#160;                    {</div>
<div class="line"><a name="l25035"></a><span class="lineno">25035</span>&#160;                        <span class="comment">// first pass: traverse this object&#39;s elements</span></div>
<div class="line"><a name="l25036"></a><span class="lineno">25036</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = source.cbegin(); it != source.cend(); ++it)</div>
<div class="line"><a name="l25037"></a><span class="lineno">25037</span>&#160;                        {</div>
<div class="line"><a name="l25038"></a><span class="lineno">25038</span>&#160;                            <span class="comment">// escape the key name to be used in a JSON patch</span></div>
<div class="line"><a name="l25039"></a><span class="lineno">25039</span>&#160;                            <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a> = json_pointer::escape(it.key());</div>
<div class="line"><a name="l25040"></a><span class="lineno">25040</span>&#160; </div>
<div class="line"><a name="l25041"></a><span class="lineno">25041</span>&#160;                            <span class="keywordflow">if</span> (target.find(it.key()) != target.end())</div>
<div class="line"><a name="l25042"></a><span class="lineno">25042</span>&#160;                            {</div>
<div class="line"><a name="l25043"></a><span class="lineno">25043</span>&#160;                                <span class="comment">// recursive call to compare object values at key it</span></div>
<div class="line"><a name="l25044"></a><span class="lineno">25044</span>&#160;                                <span class="keyword">auto</span> temp_diff = <a class="code" href="classnlohmann_1_1basic__json.html#a1c1f21327df91a4dd6c5f5a107240385">diff</a>(it.value(), target[it.key()], path + <span class="stringliteral">&quot;/&quot;</span> + key);</div>
<div class="line"><a name="l25045"></a><span class="lineno">25045</span>&#160;                                result.insert(result.end(), temp_diff.begin(), temp_diff.end());</div>
<div class="line"><a name="l25046"></a><span class="lineno">25046</span>&#160;                            }</div>
<div class="line"><a name="l25047"></a><span class="lineno">25047</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l25048"></a><span class="lineno">25048</span>&#160;                            {</div>
<div class="line"><a name="l25049"></a><span class="lineno">25049</span>&#160;                                <span class="comment">// found a key that is not in o -&gt; remove it</span></div>
<div class="line"><a name="l25050"></a><span class="lineno">25050</span>&#160;                                result.push_back(<span class="keywordtype">object</span>(</div>
<div class="line"><a name="l25051"></a><span class="lineno">25051</span>&#160;                                                     {</div>
<div class="line"><a name="l25052"></a><span class="lineno">25052</span>&#160;                                                         {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;remove&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a>}</div>
<div class="line"><a name="l25053"></a><span class="lineno">25053</span>&#160;                                                     }));</div>
<div class="line"><a name="l25054"></a><span class="lineno">25054</span>&#160;                            }</div>
<div class="line"><a name="l25055"></a><span class="lineno">25055</span>&#160;                        }</div>
<div class="line"><a name="l25056"></a><span class="lineno">25056</span>&#160; </div>
<div class="line"><a name="l25057"></a><span class="lineno">25057</span>&#160;                        <span class="comment">// second pass: traverse other object&#39;s elements</span></div>
<div class="line"><a name="l25058"></a><span class="lineno">25058</span>&#160;                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = target.cbegin(); it != target.cend(); ++it)</div>
<div class="line"><a name="l25059"></a><span class="lineno">25059</span>&#160;                        {</div>
<div class="line"><a name="l25060"></a><span class="lineno">25060</span>&#160;                            <span class="keywordflow">if</span> (source.find(it.key()) == source.end())</div>
<div class="line"><a name="l25061"></a><span class="lineno">25061</span>&#160;                            {</div>
<div class="line"><a name="l25062"></a><span class="lineno">25062</span>&#160;                                <span class="comment">// found a key that is not in this -&gt; add it</span></div>
<div class="line"><a name="l25063"></a><span class="lineno">25063</span>&#160;                                <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a> = json_pointer::escape(it.key());</div>
<div class="line"><a name="l25064"></a><span class="lineno">25064</span>&#160;                                result.push_back(</div>
<div class="line"><a name="l25065"></a><span class="lineno">25065</span>&#160;                                            {</div>
<div class="line"><a name="l25066"></a><span class="lineno">25066</span>&#160;                                                {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a>},</div>
<div class="line"><a name="l25067"></a><span class="lineno">25067</span>&#160;                                                {<span class="stringliteral">&quot;value&quot;</span>, it.value()}</div>
<div class="line"><a name="l25068"></a><span class="lineno">25068</span>&#160;                                            });</div>
<div class="line"><a name="l25069"></a><span class="lineno">25069</span>&#160;                            }</div>
<div class="line"><a name="l25070"></a><span class="lineno">25070</span>&#160;                        }</div>
<div class="line"><a name="l25071"></a><span class="lineno">25071</span>&#160; </div>
<div class="line"><a name="l25072"></a><span class="lineno">25072</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l25073"></a><span class="lineno">25073</span>&#160;                    }</div>
<div class="line"><a name="l25074"></a><span class="lineno">25074</span>&#160; </div>
<div class="line"><a name="l25075"></a><span class="lineno">25075</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l25076"></a><span class="lineno">25076</span>&#160;                    {</div>
<div class="line"><a name="l25077"></a><span class="lineno">25077</span>&#160;                        <span class="comment">// both primitive type: replace value</span></div>
<div class="line"><a name="l25078"></a><span class="lineno">25078</span>&#160;                        result.push_back(</div>
<div class="line"><a name="l25079"></a><span class="lineno">25079</span>&#160;                                    {</div>
<div class="line"><a name="l25080"></a><span class="lineno">25080</span>&#160;                                        {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;replace&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path}, {<span class="stringliteral">&quot;value&quot;</span>, target}</div>
<div class="line"><a name="l25081"></a><span class="lineno">25081</span>&#160;                                    });</div>
<div class="line"><a name="l25082"></a><span class="lineno">25082</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l25083"></a><span class="lineno">25083</span>&#160;                    }</div>
<div class="line"><a name="l25084"></a><span class="lineno">25084</span>&#160;                }</div>
<div class="line"><a name="l25085"></a><span class="lineno">25085</span>&#160; </div>
<div class="line"><a name="l25086"></a><span class="lineno">25086</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l25087"></a><span class="lineno">25087</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a1c1f21327df91a4dd6c5f5a107240385"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a1c1f21327df91a4dd6c5f5a107240385">nlohmann::basic_json::diff</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json diff(const basic_json &amp;source, const basic_json &amp;target, const std::string &amp;path=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l24965">json.hpp:24965</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a3d20d11e5dfe95084a76f62eca54fadd"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">nlohmann::basic_json::difference_type</a></div><div class="ttdeci">std::ptrdiff_t difference_type</div><div class="ttdoc">a type to represent differences between iterators</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16779">json.hpp:16779</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a9a4df356e05415438fadf8a15e583903"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903">nlohmann::basic_json::object</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json object(initializer_list_t init={})</div><div class="ttdoc">explicitly create a binary array (without subtype)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l18321">json.hpp:18321</a></div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">nlohmann::detail::parse_event_t::key</a></div><div class="ttdeci">@ key</div><div class="ttdoc">the parser read a key of a value in an object</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a476756fb08e7f2416aad116d137977f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476756fb08e7f2416aad116d137977f4">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967df">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18766">18766</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18770"></a><span class="lineno">18770</span>&#160;            {</div>
<div class="line"><a name="l18771"></a><span class="lineno">18771</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> result;</div>
<div class="line"><a name="l18772"></a><span class="lineno">18772</span>&#160;                serializer s(detail::output_adapter&lt;char, string_t&gt;(result), indent_char, error_handler);</div>
<div class="line"><a name="l18773"></a><span class="lineno">18773</span>&#160; </div>
<div class="line"><a name="l18774"></a><span class="lineno">18774</span>&#160;                <span class="keywordflow">if</span> (indent &gt;= 0)</div>
<div class="line"><a name="l18775"></a><span class="lineno">18775</span>&#160;                {</div>
<div class="line"><a name="l18776"></a><span class="lineno">18776</span>&#160;                    s.dump(*<span class="keyword">this</span>, <span class="keyword">true</span>, ensure_ascii, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(indent));</div>
<div class="line"><a name="l18777"></a><span class="lineno">18777</span>&#160;                }</div>
<div class="line"><a name="l18778"></a><span class="lineno">18778</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l18779"></a><span class="lineno">18779</span>&#160;                {</div>
<div class="line"><a name="l18780"></a><span class="lineno">18780</span>&#160;                    s.dump(*<span class="keyword">this</span>, <span class="keyword">false</span>, ensure_ascii, 0);</div>
<div class="line"><a name="l18781"></a><span class="lineno">18781</span>&#160;                }</div>
<div class="line"><a name="l18782"></a><span class="lineno">18782</span>&#160; </div>
<div class="line"><a name="l18783"></a><span class="lineno">18783</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l18784"></a><span class="lineno">18784</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a33593865ffb1860323dcbd52425b90c8"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">nlohmann::basic_json::string_t</a></div><div class="ttdeci">StringType string_t</div><div class="ttdoc">a type for a string</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l17097">json.hpp:17097</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac479e609cbd03948bd3e85fb441b66e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac479e609cbd03948bd3e85fb441b66e5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>, bool&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21961">21961</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21962"></a><span class="lineno">21962</span>&#160;            {</div>
<div class="line"><a name="l21963"></a><span class="lineno">21963</span>&#160;                <span class="comment">// emplace only works for null objects or arrays</span></div>
<div class="line"><a name="l21964"></a><span class="lineno">21964</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!(<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>())))</div>
<div class="line"><a name="l21965"></a><span class="lineno">21965</span>&#160;                {</div>
<div class="line"><a name="l21966"></a><span class="lineno">21966</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(311, <span class="stringliteral">&quot;cannot use emplace() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l21967"></a><span class="lineno">21967</span>&#160;                }</div>
<div class="line"><a name="l21968"></a><span class="lineno">21968</span>&#160; </div>
<div class="line"><a name="l21969"></a><span class="lineno">21969</span>&#160;                <span class="comment">// transform null object into an object</span></div>
<div class="line"><a name="l21970"></a><span class="lineno">21970</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l21971"></a><span class="lineno">21971</span>&#160;                {</div>
<div class="line"><a name="l21972"></a><span class="lineno">21972</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l21973"></a><span class="lineno">21973</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l21974"></a><span class="lineno">21974</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l21975"></a><span class="lineno">21975</span>&#160;                }</div>
<div class="line"><a name="l21976"></a><span class="lineno">21976</span>&#160; </div>
<div class="line"><a name="l21977"></a><span class="lineno">21977</span>&#160;                <span class="comment">// add element to array (perfect forwarding)</span></div>
<div class="line"><a name="l21978"></a><span class="lineno">21978</span>&#160;                <span class="keyword">auto</span> res = m_value.object-&gt;emplace(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><a name="l21979"></a><span class="lineno">21979</span>&#160;                <span class="comment">// create result iterator and set iterator to the result of emplace</span></div>
<div class="line"><a name="l21980"></a><span class="lineno">21980</span>&#160;                <span class="keyword">auto</span> it = <a class="code" href="classnlohmann_1_1basic__json.html#a23b495b4c282e4afacf382f5b49af7c7">begin</a>();</div>
<div class="line"><a name="l21981"></a><span class="lineno">21981</span>&#160;                it.m_it.object_iterator = res.first;</div>
<div class="line"><a name="l21982"></a><span class="lineno">21982</span>&#160; </div>
<div class="line"><a name="l21983"></a><span class="lineno">21983</span>&#160;                <span class="comment">// return pair of iterator and boolean</span></div>
<div class="line"><a name="l21984"></a><span class="lineno">21984</span>&#160;                <span class="keywordflow">return</span> {it, res.second};</div>
<div class="line"><a name="l21985"></a><span class="lineno">21985</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a23b495b4c282e4afacf382f5b49af7c7"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a23b495b4c282e4afacf382f5b49af7c7">nlohmann::basic_json::begin</a></div><div class="ttdeci">iterator begin() noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l20973">json.hpp:20973</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aedc7afad96292b5ab61a2e0ad3067f5f"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">nlohmann::basic_json::is_null</a></div><div class="ttdeci">constexpr bool is_null() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l18899">json.hpp:18899</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a15c0a5db4fb12d49433801bbe6436bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c0a5db4fb12d49433801bbe6436bfb">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21908">21908</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21909"></a><span class="lineno">21909</span>&#160;            {</div>
<div class="line"><a name="l21910"></a><span class="lineno">21910</span>&#160;                <span class="comment">// emplace_back only works for null objects or arrays</span></div>
<div class="line"><a name="l21911"></a><span class="lineno">21911</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!(<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>())))</div>
<div class="line"><a name="l21912"></a><span class="lineno">21912</span>&#160;                {</div>
<div class="line"><a name="l21913"></a><span class="lineno">21913</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(311, <span class="stringliteral">&quot;cannot use emplace_back() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l21914"></a><span class="lineno">21914</span>&#160;                }</div>
<div class="line"><a name="l21915"></a><span class="lineno">21915</span>&#160; </div>
<div class="line"><a name="l21916"></a><span class="lineno">21916</span>&#160;                <span class="comment">// transform null object into an array</span></div>
<div class="line"><a name="l21917"></a><span class="lineno">21917</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l21918"></a><span class="lineno">21918</span>&#160;                {</div>
<div class="line"><a name="l21919"></a><span class="lineno">21919</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21920"></a><span class="lineno">21920</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21921"></a><span class="lineno">21921</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l21922"></a><span class="lineno">21922</span>&#160;                }</div>
<div class="line"><a name="l21923"></a><span class="lineno">21923</span>&#160; </div>
<div class="line"><a name="l21924"></a><span class="lineno">21924</span>&#160;                <span class="comment">// add element to array (perfect forwarding)</span></div>
<div class="line"><a name="l21925"></a><span class="lineno">21925</span>&#160;<span class="preprocessor">#ifdef JSON_HAS_CPP_17</span></div>
<div class="line"><a name="l21926"></a><span class="lineno">21926</span>&#160;                <span class="keywordflow">return</span> m_value.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><a name="l21927"></a><span class="lineno">21927</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l21928"></a><span class="lineno">21928</span>&#160;                m_value.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><a name="l21929"></a><span class="lineno">21929</span>&#160;                <span class="keywordflow">return</span> m_value.array-&gt;back();</div>
<div class="line"><a name="l21930"></a><span class="lineno">21930</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l21931"></a><span class="lineno">21931</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c99855f3e35ff35558cb46139b785f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c99855f3e35ff35558cb46139b785f8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21428">21428</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21429"></a><span class="lineno">21429</span>&#160;            {</div>
<div class="line"><a name="l21430"></a><span class="lineno">21430</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l21431"></a><span class="lineno">21431</span>&#160;                {</div>
<div class="line"><a name="l21432"></a><span class="lineno">21432</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l21433"></a><span class="lineno">21433</span>&#160;                    {</div>
<div class="line"><a name="l21434"></a><span class="lineno">21434</span>&#160;                        <span class="comment">// null values are empty</span></div>
<div class="line"><a name="l21435"></a><span class="lineno">21435</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l21436"></a><span class="lineno">21436</span>&#160;                    }</div>
<div class="line"><a name="l21437"></a><span class="lineno">21437</span>&#160; </div>
<div class="line"><a name="l21438"></a><span class="lineno">21438</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l21439"></a><span class="lineno">21439</span>&#160;                    {</div>
<div class="line"><a name="l21440"></a><span class="lineno">21440</span>&#160;                        <span class="comment">// delegate call to array_t::empty()</span></div>
<div class="line"><a name="l21441"></a><span class="lineno">21441</span>&#160;                        <span class="keywordflow">return</span> m_value.array-&gt;empty();</div>
<div class="line"><a name="l21442"></a><span class="lineno">21442</span>&#160;                    }</div>
<div class="line"><a name="l21443"></a><span class="lineno">21443</span>&#160; </div>
<div class="line"><a name="l21444"></a><span class="lineno">21444</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l21445"></a><span class="lineno">21445</span>&#160;                    {</div>
<div class="line"><a name="l21446"></a><span class="lineno">21446</span>&#160;                        <span class="comment">// delegate call to object_t::empty()</span></div>
<div class="line"><a name="l21447"></a><span class="lineno">21447</span>&#160;                        <span class="keywordflow">return</span> m_value.object-&gt;empty();</div>
<div class="line"><a name="l21448"></a><span class="lineno">21448</span>&#160;                    }</div>
<div class="line"><a name="l21449"></a><span class="lineno">21449</span>&#160; </div>
<div class="line"><a name="l21450"></a><span class="lineno">21450</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l21451"></a><span class="lineno">21451</span>&#160;                    {</div>
<div class="line"><a name="l21452"></a><span class="lineno">21452</span>&#160;                        <span class="comment">// all other types are nonempty</span></div>
<div class="line"><a name="l21453"></a><span class="lineno">21453</span>&#160;                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l21454"></a><span class="lineno">21454</span>&#160;                    }</div>
<div class="line"><a name="l21455"></a><span class="lineno">21455</span>&#160;                }</div>
<div class="line"><a name="l21456"></a><span class="lineno">21456</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82b5b96f86879a3bac0c713d33178551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b5b96f86879a3bac0c713d33178551">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21054">21054</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21055"></a><span class="lineno">21055</span>&#160;            {</div>
<div class="line"><a name="l21056"></a><span class="lineno">21056</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">cend</a>();</div>
<div class="line"><a name="l21057"></a><span class="lineno">21057</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a931267ec3f09eb67e4382f321b2c52bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931267ec3f09eb67e4382f321b2c52bc">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21044">21044</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21045"></a><span class="lineno">21045</span>&#160;            {</div>
<div class="line"><a name="l21046"></a><span class="lineno">21046</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><a name="l21047"></a><span class="lineno">21047</span>&#160;                result.set_end();</div>
<div class="line"><a name="l21048"></a><span class="lineno">21048</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l21049"></a><span class="lineno">21049</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a221b943d3228488c14225e55f726cc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221b943d3228488c14225e55f726cc26">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20766">20766</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20767"></a><span class="lineno">20767</span>&#160;            {</div>
<div class="line"><a name="l20768"></a><span class="lineno">20768</span>&#160;                <span class="comment">// this erase only works for arrays</span></div>
<div class="line"><a name="l20769"></a><span class="lineno">20769</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l20770"></a><span class="lineno">20770</span>&#160;                {</div>
<div class="line"><a name="l20771"></a><span class="lineno">20771</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(idx &gt;= <a class="code" href="classnlohmann_1_1basic__json.html#a33c7c8638bb0b12e6d1b69d8106dd2e0">size</a>()))</div>
<div class="line"><a name="l20772"></a><span class="lineno">20772</span>&#160;                    {</div>
<div class="line"><a name="l20773"></a><span class="lineno">20773</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(401, <span class="stringliteral">&quot;array index &quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(idx) + <span class="stringliteral">&quot; is out of range&quot;</span>));</div>
<div class="line"><a name="l20774"></a><span class="lineno">20774</span>&#160;                    }</div>
<div class="line"><a name="l20775"></a><span class="lineno">20775</span>&#160; </div>
<div class="line"><a name="l20776"></a><span class="lineno">20776</span>&#160;                    m_value.array-&gt;erase(m_value.array-&gt;begin() + <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">difference_type</a><span class="keyword">&gt;</span>(idx));</div>
<div class="line"><a name="l20777"></a><span class="lineno">20777</span>&#160;                }</div>
<div class="line"><a name="l20778"></a><span class="lineno">20778</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l20779"></a><span class="lineno">20779</span>&#160;                {</div>
<div class="line"><a name="l20780"></a><span class="lineno">20780</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(307, <span class="stringliteral">&quot;cannot use erase() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20781"></a><span class="lineno">20781</span>&#160;                }</div>
<div class="line"><a name="l20782"></a><span class="lineno">20782</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a33c7c8638bb0b12e6d1b69d8106dd2e0"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a33c7c8638bb0b12e6d1b69d8106dd2e0">nlohmann::basic_json::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21501">json.hpp:21501</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af72b1c9d1502b02a49a0cb9db9f980ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72b1c9d1502b02a49a0cb9db9f980ea">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20731">20731</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20732"></a><span class="lineno">20732</span>&#160;            {</div>
<div class="line"><a name="l20733"></a><span class="lineno">20733</span>&#160;                <span class="comment">// this erase only works for objects</span></div>
<div class="line"><a name="l20734"></a><span class="lineno">20734</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20735"></a><span class="lineno">20735</span>&#160;                {</div>
<div class="line"><a name="l20736"></a><span class="lineno">20736</span>&#160;                    <span class="keywordflow">return</span> m_value.object-&gt;erase(key);</div>
<div class="line"><a name="l20737"></a><span class="lineno">20737</span>&#160;                }</div>
<div class="line"><a name="l20738"></a><span class="lineno">20738</span>&#160; </div>
<div class="line"><a name="l20739"></a><span class="lineno">20739</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(307, <span class="stringliteral">&quot;cannot use erase() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20740"></a><span class="lineno">20740</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ac83750e267e37d5d47591eb44cce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac83750e267e37d5d47591eb44cce42">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , typename std::enable_if&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20636">20636</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20637"></a><span class="lineno">20637</span>&#160;            {</div>
<div class="line"><a name="l20638"></a><span class="lineno">20638</span>&#160;                <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><a name="l20639"></a><span class="lineno">20639</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(<span class="keyword">this</span> != first.m_object || <span class="keyword">this</span> != last.m_object))</div>
<div class="line"><a name="l20640"></a><span class="lineno">20640</span>&#160;                {</div>
<div class="line"><a name="l20641"></a><span class="lineno">20641</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(203, <span class="stringliteral">&quot;iterators do not fit current value&quot;</span>));</div>
<div class="line"><a name="l20642"></a><span class="lineno">20642</span>&#160;                }</div>
<div class="line"><a name="l20643"></a><span class="lineno">20643</span>&#160; </div>
<div class="line"><a name="l20644"></a><span class="lineno">20644</span>&#160;                IteratorType result = <a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>();</div>
<div class="line"><a name="l20645"></a><span class="lineno">20645</span>&#160; </div>
<div class="line"><a name="l20646"></a><span class="lineno">20646</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l20647"></a><span class="lineno">20647</span>&#160;                {</div>
<div class="line"><a name="l20648"></a><span class="lineno">20648</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l20649"></a><span class="lineno">20649</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l20650"></a><span class="lineno">20650</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l20651"></a><span class="lineno">20651</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l20652"></a><span class="lineno">20652</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l20653"></a><span class="lineno">20653</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l20654"></a><span class="lineno">20654</span>&#160;                    {</div>
<div class="line"><a name="l20655"></a><span class="lineno">20655</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(!first.m_it.primitive_iterator.is_begin()</div>
<div class="line"><a name="l20656"></a><span class="lineno">20656</span>&#160;                                               || !last.m_it.primitive_iterator.is_end()))</div>
<div class="line"><a name="l20657"></a><span class="lineno">20657</span>&#160;                        {</div>
<div class="line"><a name="l20658"></a><span class="lineno">20658</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(204, <span class="stringliteral">&quot;iterators out of range&quot;</span>));</div>
<div class="line"><a name="l20659"></a><span class="lineno">20659</span>&#160;                        }</div>
<div class="line"><a name="l20660"></a><span class="lineno">20660</span>&#160; </div>
<div class="line"><a name="l20661"></a><span class="lineno">20661</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">is_string</a>())</div>
<div class="line"><a name="l20662"></a><span class="lineno">20662</span>&#160;                        {</div>
<div class="line"><a name="l20663"></a><span class="lineno">20663</span>&#160;                            AllocatorType&lt;string_t&gt; alloc;</div>
<div class="line"><a name="l20664"></a><span class="lineno">20664</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);</div>
<div class="line"><a name="l20665"></a><span class="lineno">20665</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);</div>
<div class="line"><a name="l20666"></a><span class="lineno">20666</span>&#160;                            m_value.string = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l20667"></a><span class="lineno">20667</span>&#160;                        }</div>
<div class="line"><a name="l20668"></a><span class="lineno">20668</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>())</div>
<div class="line"><a name="l20669"></a><span class="lineno">20669</span>&#160;                        {</div>
<div class="line"><a name="l20670"></a><span class="lineno">20670</span>&#160;                            AllocatorType&lt;binary_t&gt; alloc;</div>
<div class="line"><a name="l20671"></a><span class="lineno">20671</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);</div>
<div class="line"><a name="l20672"></a><span class="lineno">20672</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);</div>
<div class="line"><a name="l20673"></a><span class="lineno">20673</span>&#160;                            m_value.binary = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l20674"></a><span class="lineno">20674</span>&#160;                        }</div>
<div class="line"><a name="l20675"></a><span class="lineno">20675</span>&#160; </div>
<div class="line"><a name="l20676"></a><span class="lineno">20676</span>&#160;                        m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>;</div>
<div class="line"><a name="l20677"></a><span class="lineno">20677</span>&#160;                        assert_invariant();</div>
<div class="line"><a name="l20678"></a><span class="lineno">20678</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20679"></a><span class="lineno">20679</span>&#160;                    }</div>
<div class="line"><a name="l20680"></a><span class="lineno">20680</span>&#160; </div>
<div class="line"><a name="l20681"></a><span class="lineno">20681</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l20682"></a><span class="lineno">20682</span>&#160;                    {</div>
<div class="line"><a name="l20683"></a><span class="lineno">20683</span>&#160;                        result.m_it.object_iterator = m_value.object-&gt;erase(first.m_it.object_iterator,</div>
<div class="line"><a name="l20684"></a><span class="lineno">20684</span>&#160;                                                                            last.m_it.object_iterator);</div>
<div class="line"><a name="l20685"></a><span class="lineno">20685</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20686"></a><span class="lineno">20686</span>&#160;                    }</div>
<div class="line"><a name="l20687"></a><span class="lineno">20687</span>&#160; </div>
<div class="line"><a name="l20688"></a><span class="lineno">20688</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l20689"></a><span class="lineno">20689</span>&#160;                    {</div>
<div class="line"><a name="l20690"></a><span class="lineno">20690</span>&#160;                        result.m_it.array_iterator = m_value.array-&gt;erase(first.m_it.array_iterator,</div>
<div class="line"><a name="l20691"></a><span class="lineno">20691</span>&#160;                                                                          last.m_it.array_iterator);</div>
<div class="line"><a name="l20692"></a><span class="lineno">20692</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20693"></a><span class="lineno">20693</span>&#160;                    }</div>
<div class="line"><a name="l20694"></a><span class="lineno">20694</span>&#160; </div>
<div class="line"><a name="l20695"></a><span class="lineno">20695</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l20696"></a><span class="lineno">20696</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(307, <span class="stringliteral">&quot;cannot use erase() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20697"></a><span class="lineno">20697</span>&#160;                }</div>
<div class="line"><a name="l20698"></a><span class="lineno">20698</span>&#160; </div>
<div class="line"><a name="l20699"></a><span class="lineno">20699</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l20700"></a><span class="lineno">20700</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a9576224f7b3ff812a308e7c1e784ea80"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">nlohmann::basic_json::is_binary</a></div><div class="ttdeci">constexpr bool is_binary() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19124">json.hpp:19124</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ab303d17366c26fca12242c7f8def1bb7"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">nlohmann::basic_json::is_string</a></div><div class="ttdeci">constexpr bool is_string() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19102">json.hpp:19102</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a494632b69bbe1d0153d3bedad0901b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494632b69bbe1d0153d3bedad0901b8e">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , typename std::enable_if&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20523">20523</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20524"></a><span class="lineno">20524</span>&#160;            {</div>
<div class="line"><a name="l20525"></a><span class="lineno">20525</span>&#160;                <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><a name="l20526"></a><span class="lineno">20526</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(<span class="keyword">this</span> != pos.m_object))</div>
<div class="line"><a name="l20527"></a><span class="lineno">20527</span>&#160;                {</div>
<div class="line"><a name="l20528"></a><span class="lineno">20528</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>));</div>
<div class="line"><a name="l20529"></a><span class="lineno">20529</span>&#160;                }</div>
<div class="line"><a name="l20530"></a><span class="lineno">20530</span>&#160; </div>
<div class="line"><a name="l20531"></a><span class="lineno">20531</span>&#160;                IteratorType result = <a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>();</div>
<div class="line"><a name="l20532"></a><span class="lineno">20532</span>&#160; </div>
<div class="line"><a name="l20533"></a><span class="lineno">20533</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l20534"></a><span class="lineno">20534</span>&#160;                {</div>
<div class="line"><a name="l20535"></a><span class="lineno">20535</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l20536"></a><span class="lineno">20536</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l20537"></a><span class="lineno">20537</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l20538"></a><span class="lineno">20538</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l20539"></a><span class="lineno">20539</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l20540"></a><span class="lineno">20540</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l20541"></a><span class="lineno">20541</span>&#160;                    {</div>
<div class="line"><a name="l20542"></a><span class="lineno">20542</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!pos.m_it.primitive_iterator.is_begin()))</div>
<div class="line"><a name="l20543"></a><span class="lineno">20543</span>&#160;                        {</div>
<div class="line"><a name="l20544"></a><span class="lineno">20544</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(205, <span class="stringliteral">&quot;iterator out of range&quot;</span>));</div>
<div class="line"><a name="l20545"></a><span class="lineno">20545</span>&#160;                        }</div>
<div class="line"><a name="l20546"></a><span class="lineno">20546</span>&#160; </div>
<div class="line"><a name="l20547"></a><span class="lineno">20547</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">is_string</a>())</div>
<div class="line"><a name="l20548"></a><span class="lineno">20548</span>&#160;                        {</div>
<div class="line"><a name="l20549"></a><span class="lineno">20549</span>&#160;                            AllocatorType&lt;string_t&gt; alloc;</div>
<div class="line"><a name="l20550"></a><span class="lineno">20550</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.string);</div>
<div class="line"><a name="l20551"></a><span class="lineno">20551</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.string, 1);</div>
<div class="line"><a name="l20552"></a><span class="lineno">20552</span>&#160;                            m_value.string = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l20553"></a><span class="lineno">20553</span>&#160;                        }</div>
<div class="line"><a name="l20554"></a><span class="lineno">20554</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>())</div>
<div class="line"><a name="l20555"></a><span class="lineno">20555</span>&#160;                        {</div>
<div class="line"><a name="l20556"></a><span class="lineno">20556</span>&#160;                            AllocatorType&lt;binary_t&gt; alloc;</div>
<div class="line"><a name="l20557"></a><span class="lineno">20557</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::destroy(alloc, m_value.binary);</div>
<div class="line"><a name="l20558"></a><span class="lineno">20558</span>&#160;                            std::allocator_traits&lt;decltype(alloc)&gt;::deallocate(alloc, m_value.binary, 1);</div>
<div class="line"><a name="l20559"></a><span class="lineno">20559</span>&#160;                            m_value.binary = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l20560"></a><span class="lineno">20560</span>&#160;                        }</div>
<div class="line"><a name="l20561"></a><span class="lineno">20561</span>&#160; </div>
<div class="line"><a name="l20562"></a><span class="lineno">20562</span>&#160;                        m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>;</div>
<div class="line"><a name="l20563"></a><span class="lineno">20563</span>&#160;                        assert_invariant();</div>
<div class="line"><a name="l20564"></a><span class="lineno">20564</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20565"></a><span class="lineno">20565</span>&#160;                    }</div>
<div class="line"><a name="l20566"></a><span class="lineno">20566</span>&#160; </div>
<div class="line"><a name="l20567"></a><span class="lineno">20567</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l20568"></a><span class="lineno">20568</span>&#160;                    {</div>
<div class="line"><a name="l20569"></a><span class="lineno">20569</span>&#160;                        result.m_it.object_iterator = m_value.object-&gt;erase(pos.m_it.object_iterator);</div>
<div class="line"><a name="l20570"></a><span class="lineno">20570</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20571"></a><span class="lineno">20571</span>&#160;                    }</div>
<div class="line"><a name="l20572"></a><span class="lineno">20572</span>&#160; </div>
<div class="line"><a name="l20573"></a><span class="lineno">20573</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l20574"></a><span class="lineno">20574</span>&#160;                    {</div>
<div class="line"><a name="l20575"></a><span class="lineno">20575</span>&#160;                        result.m_it.array_iterator = m_value.array-&gt;erase(pos.m_it.array_iterator);</div>
<div class="line"><a name="l20576"></a><span class="lineno">20576</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l20577"></a><span class="lineno">20577</span>&#160;                    }</div>
<div class="line"><a name="l20578"></a><span class="lineno">20578</span>&#160; </div>
<div class="line"><a name="l20579"></a><span class="lineno">20579</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l20580"></a><span class="lineno">20580</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(307, <span class="stringliteral">&quot;cannot use erase() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20581"></a><span class="lineno">20581</span>&#160;                }</div>
<div class="line"><a name="l20582"></a><span class="lineno">20582</span>&#160; </div>
<div class="line"><a name="l20583"></a><span class="lineno">20583</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l20584"></a><span class="lineno">20584</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdf9b3aab82dcf443dd91ca5ec06b80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf9b3aab82dcf443dd91ca5ec06b80c">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyT &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<p>find an element in a JSON object</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20819">20819</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20820"></a><span class="lineno">20820</span>&#160;            {</div>
<div class="line"><a name="l20821"></a><span class="lineno">20821</span>&#160;                <span class="keyword">auto</span> result = <a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>();</div>
<div class="line"><a name="l20822"></a><span class="lineno">20822</span>&#160; </div>
<div class="line"><a name="l20823"></a><span class="lineno">20823</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>())</div>
<div class="line"><a name="l20824"></a><span class="lineno">20824</span>&#160;                {</div>
<div class="line"><a name="l20825"></a><span class="lineno">20825</span>&#160;                    result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));</div>
<div class="line"><a name="l20826"></a><span class="lineno">20826</span>&#160;                }</div>
<div class="line"><a name="l20827"></a><span class="lineno">20827</span>&#160; </div>
<div class="line"><a name="l20828"></a><span class="lineno">20828</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l20829"></a><span class="lineno">20829</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a17a516671c29a69bb2e11ca12030316b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a516671c29a69bb2e11ca12030316b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyT &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<p>find an element in a JSON object</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20836">20836</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20837"></a><span class="lineno">20837</span>&#160;            {</div>
<div class="line"><a name="l20838"></a><span class="lineno">20838</span>&#160;                <span class="keyword">auto</span> result = <a class="code" href="classnlohmann_1_1basic__json.html#a3017cf0f1a4673e904e34cfef62e7758">cend</a>();</div>
<div class="line"><a name="l20839"></a><span class="lineno">20839</span>&#160; </div>
<div class="line"><a name="l20840"></a><span class="lineno">20840</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>())</div>
<div class="line"><a name="l20841"></a><span class="lineno">20841</span>&#160;                {</div>
<div class="line"><a name="l20842"></a><span class="lineno">20842</span>&#160;                    result.m_it.object_iterator = m_value.object-&gt;find(std::forward&lt;KeyT&gt;(key));</div>
<div class="line"><a name="l20843"></a><span class="lineno">20843</span>&#160;                }</div>
<div class="line"><a name="l20844"></a><span class="lineno">20844</span>&#160; </div>
<div class="line"><a name="l20845"></a><span class="lineno">20845</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l20846"></a><span class="lineno">20846</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7aa6e048e659481a036f2d872c7cba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7aa6e048e659481a036f2d872c7cba6">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24571">24571</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24572"></a><span class="lineno">24572</span>&#160;            {</div>
<div class="line"><a name="l24573"></a><span class="lineno">24573</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>);</div>
<div class="line"><a name="l24574"></a><span class="lineno">24574</span>&#160;                json_pointer::flatten(<span class="stringliteral">&quot;&quot;</span>, *<span class="keyword">this</span>, result);</div>
<div class="line"><a name="l24575"></a><span class="lineno">24575</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l24576"></a><span class="lineno">24576</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2612581e4788ddffc2f45d5e4cc04fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2612581e4788ddffc2f45d5e4cc04fc">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24369">24369</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24372"></a><span class="lineno">24372</span>&#160;            {</div>
<div class="line"><a name="l24373"></a><span class="lineno">24373</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a4e02793f2691aa29ab7cb69fddafbf5c">from_bson</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><a name="l24374"></a><span class="lineno">24374</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a4e02793f2691aa29ab7cb69fddafbf5c"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a4e02793f2691aa29ab7cb69fddafbf5c">nlohmann::basic_json::from_bson</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_bson(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l24339">json.hpp:24339</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2afe89884edf72412a0624982324755d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afe89884edf72412a0624982324755d">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24378">24378</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24381"></a><span class="lineno">24381</span>&#160;            {</div>
<div class="line"><a name="l24382"></a><span class="lineno">24382</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24383"></a><span class="lineno">24383</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24384"></a><span class="lineno">24384</span>&#160;                <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><a name="l24385"></a><span class="lineno">24385</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><a name="l24386"></a><span class="lineno">24386</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24387"></a><span class="lineno">24387</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e02793f2691aa29ab7cb69fddafbf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e02793f2691aa29ab7cb69fddafbf5c">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24339">24339</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24342"></a><span class="lineno">24342</span>&#160;            {</div>
<div class="line"><a name="l24343"></a><span class="lineno">24343</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24344"></a><span class="lineno">24344</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24345"></a><span class="lineno">24345</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><a name="l24346"></a><span class="lineno">24346</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><a name="l24347"></a><span class="lineno">24347</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24348"></a><span class="lineno">24348</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4118d0ec23d9eeafc236b9524d220e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4118d0ec23d9eeafc236b9524d220e94">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24355">24355</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24358"></a><span class="lineno">24358</span>&#160;            {</div>
<div class="line"><a name="l24359"></a><span class="lineno">24359</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24360"></a><span class="lineno">24360</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24361"></a><span class="lineno">24361</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last));</div>
<div class="line"><a name="l24362"></a><span class="lineno">24362</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><a name="l24363"></a><span class="lineno">24363</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24364"></a><span class="lineno">24364</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a188755c8cda27e2afb03c016c14125d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188755c8cda27e2afb03c016c14125d8">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23999">23999</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24003"></a><span class="lineno">24003</span>&#160;            {</div>
<div class="line"><a name="l24004"></a><span class="lineno">24004</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a44dd5635fb2da4710f6cd6e42b72773f">from_cbor</a>(ptr, ptr + len, strict, allow_exceptions, tag_handler);</div>
<div class="line"><a name="l24005"></a><span class="lineno">24005</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a44dd5635fb2da4710f6cd6e42b72773f"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a44dd5635fb2da4710f6cd6e42b72773f">nlohmann::basic_json::from_cbor</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_cbor(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const cbor_tag_handler_t tag_handler=cbor_tag_handler_t::error)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23967">json.hpp:23967</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a67e47f4bcde55214475f47f8314c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a67e47f4bcde55214475f47f8314c1f">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24010">24010</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24014"></a><span class="lineno">24014</span>&#160;            {</div>
<div class="line"><a name="l24015"></a><span class="lineno">24015</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24016"></a><span class="lineno">24016</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24017"></a><span class="lineno">24017</span>&#160;                <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><a name="l24018"></a><span class="lineno">24018</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><a name="l24019"></a><span class="lineno">24019</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24020"></a><span class="lineno">24020</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a44dd5635fb2da4710f6cd6e42b72773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dd5635fb2da4710f6cd6e42b72773f">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23967">23967</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23971"></a><span class="lineno">23971</span>&#160;            {</div>
<div class="line"><a name="l23972"></a><span class="lineno">23972</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l23973"></a><span class="lineno">23973</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l23974"></a><span class="lineno">23974</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><a name="l23975"></a><span class="lineno">23975</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><a name="l23976"></a><span class="lineno">23976</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l23977"></a><span class="lineno">23977</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba4f6fc79cc405fb212ea3d992334e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4f6fc79cc405fb212ea3d992334e71">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9ac">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacenlohmann_1_1detail.html#a58bb1ef1a9ad287a9cfaf1855784d9acacb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23984">23984</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23988"></a><span class="lineno">23988</span>&#160;            {</div>
<div class="line"><a name="l23989"></a><span class="lineno">23989</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l23990"></a><span class="lineno">23990</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l23991"></a><span class="lineno">23991</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last));</div>
<div class="line"><a name="l23992"></a><span class="lineno">23992</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><a name="l23993"></a><span class="lineno">23993</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l23994"></a><span class="lineno">23994</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d69d3102639759d5202a6f764760d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d69d3102639759d5202a6f764760d23">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24141">24141</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24144"></a><span class="lineno">24144</span>&#160;            {</div>
<div class="line"><a name="l24145"></a><span class="lineno">24145</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#adbcab52fca1e25b3311ef14e71a57590">from_msgpack</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><a name="l24146"></a><span class="lineno">24146</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_adbcab52fca1e25b3311ef14e71a57590"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#adbcab52fca1e25b3311ef14e71a57590">nlohmann::basic_json::from_msgpack</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_msgpack(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l24110">json.hpp:24110</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a84b3d89de8e774a2609dc4c0a1273f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b3d89de8e774a2609dc4c0a1273f62">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24150">24150</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24153"></a><span class="lineno">24153</span>&#160;            {</div>
<div class="line"><a name="l24154"></a><span class="lineno">24154</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24155"></a><span class="lineno">24155</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24156"></a><span class="lineno">24156</span>&#160;                <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><a name="l24157"></a><span class="lineno">24157</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><a name="l24158"></a><span class="lineno">24158</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24159"></a><span class="lineno">24159</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adbcab52fca1e25b3311ef14e71a57590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcab52fca1e25b3311ef14e71a57590">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24110">24110</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24113"></a><span class="lineno">24113</span>&#160;            {</div>
<div class="line"><a name="l24114"></a><span class="lineno">24114</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24115"></a><span class="lineno">24115</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24116"></a><span class="lineno">24116</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><a name="l24117"></a><span class="lineno">24117</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><a name="l24118"></a><span class="lineno">24118</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24119"></a><span class="lineno">24119</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94dbeb08bcd13821512957dcbf3f00bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dbeb08bcd13821512957dcbf3f00bd">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24126">24126</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24129"></a><span class="lineno">24129</span>&#160;            {</div>
<div class="line"><a name="l24130"></a><span class="lineno">24130</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24131"></a><span class="lineno">24131</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24132"></a><span class="lineno">24132</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last));</div>
<div class="line"><a name="l24133"></a><span class="lineno">24133</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><a name="l24134"></a><span class="lineno">24134</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24135"></a><span class="lineno">24135</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6eeda23c34cee79d8d72f1a8691a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eeda23c34cee79d8d72f1a8691a8de">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24256">24256</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24259"></a><span class="lineno">24259</span>&#160;            {</div>
<div class="line"><a name="l24260"></a><span class="lineno">24260</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aa81f62db69978b90ff701f05c72e03a7">from_ubjson</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><a name="l24261"></a><span class="lineno">24261</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aa81f62db69978b90ff701f05c72e03a7"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aa81f62db69978b90ff701f05c72e03a7">nlohmann::basic_json::from_ubjson</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_ubjson(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l24226">json.hpp:24226</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a47201396899371881a46562bffb922da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47201396899371881a46562bffb922da">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24265">24265</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24268"></a><span class="lineno">24268</span>&#160;            {</div>
<div class="line"><a name="l24269"></a><span class="lineno">24269</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24270"></a><span class="lineno">24270</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24271"></a><span class="lineno">24271</span>&#160;                <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><a name="l24272"></a><span class="lineno">24272</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><a name="l24273"></a><span class="lineno">24273</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24274"></a><span class="lineno">24274</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa81f62db69978b90ff701f05c72e03a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81f62db69978b90ff701f05c72e03a7">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24226">24226</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24229"></a><span class="lineno">24229</span>&#160;            {</div>
<div class="line"><a name="l24230"></a><span class="lineno">24230</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24231"></a><span class="lineno">24231</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24232"></a><span class="lineno">24232</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><a name="l24233"></a><span class="lineno">24233</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><a name="l24234"></a><span class="lineno">24234</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24235"></a><span class="lineno">24235</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9dbb422350fed520ce8c1ca8762c0251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbb422350fed520ce8c1ca8762c0251">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24242">24242</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24245"></a><span class="lineno">24245</span>&#160;            {</div>
<div class="line"><a name="l24246"></a><span class="lineno">24246</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l24247"></a><span class="lineno">24247</span>&#160;                detail::json_sax_dom_parser&lt;basic_json&gt; sdp(result, allow_exceptions);</div>
<div class="line"><a name="l24248"></a><span class="lineno">24248</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last));</div>
<div class="line"><a name="l24249"></a><span class="lineno">24249</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia)).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><a name="l24250"></a><span class="lineno">24250</span>&#160;                <span class="keywordflow">return</span> res ? result : <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(<a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>);</div>
<div class="line"><a name="l24251"></a><span class="lineno">24251</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5417ca43ae5e7a3a2f82eee2d915c6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5417ca43ae5e7a3a2f82eee2d915c6ed">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20412">20412</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20413"></a><span class="lineno">20413</span>&#160;            {</div>
<div class="line"><a name="l20414"></a><span class="lineno">20414</span>&#160;                <span class="keywordflow">return</span> *<a class="code" href="classnlohmann_1_1basic__json.html#a23b495b4c282e4afacf382f5b49af7c7">begin</a>();</div>
<div class="line"><a name="l20415"></a><span class="lineno">20415</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ac8f974c178cf9326b6765e22f50eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac8f974c178cf9326b6765e22f50eb6">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20420">20420</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20421"></a><span class="lineno">20421</span>&#160;            {</div>
<div class="line"><a name="l20422"></a><span class="lineno">20422</span>&#160;                <span class="keywordflow">return</span> *<a class="code" href="classnlohmann_1_1basic__json.html#ae508c13e3ad6ce445bcaf24a2bc7d039">cbegin</a>();</div>
<div class="line"><a name="l20423"></a><span class="lineno">20423</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c42bdda2432e4027f4b63ef20ae74e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c42bdda2432e4027f4b63ef20ae74e6">&#9670;&nbsp;</a></span>get() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; std::is_same&lt; typename std::remove_const&lt; BasicJsonType &gt;::type, basic_json_t &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19343">19343</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19344"></a><span class="lineno">19344</span>&#160;            {</div>
<div class="line"><a name="l19345"></a><span class="lineno">19345</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l19346"></a><span class="lineno">19346</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a642213bf5f206f13d2447098b737bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642213bf5f206f13d2447098b737bee7">&#9670;&nbsp;</a></span>get() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; !std::is_same&lt; BasicJsonType, basic_json &gt;::value &amp;&amp;detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BasicJsonType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads converts the current <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> in a different <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this, converted into </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Depending on the implementation of the called <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code> method.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 3.2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19366">19366</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19367"></a><span class="lineno">19367</span>&#160;            {</div>
<div class="line"><a name="l19368"></a><span class="lineno">19368</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l19369"></a><span class="lineno">19369</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a014a9be80fef74c22b54d92c2cbd90c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014a9be80fef74c22b54d92c2cbd90c6">&#9670;&nbsp;</a></span>get() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template <a class="el" href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">get_ptr</a>&lt;PointerType&gt;())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p>get special-case overload This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19634">19634</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19635"></a><span class="lineno">19635</span>&#160;            {</div>
<div class="line"><a name="l19636"></a><span class="lineno">19636</span>&#160;                <span class="comment">// delegate the call to get_ptr</span></div>
<div class="line"><a name="l19637"></a><span class="lineno">19637</span>&#160;                <span class="keywordflow">return</span> get_ptr&lt;PointerType&gt;();</div>
<div class="line"><a name="l19638"></a><span class="lineno">19638</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7c84027412c32e6dac101de144abf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c84027412c32e6dac101de144abf91">&#9670;&nbsp;</a></span>get() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;, detail::enable_if_t&lt; !std::is_same&lt; basic_json_t, ValueType &gt;::value &amp;&amp;detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit); special case </p>
<p>Explicit type conversion between the JSON value and a compatible value which is <b>not</b> <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a> and <b>not</b> <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible">DefaultConstructible</a>. The value is converted by calling the <a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code> method.</p>
<p>The function is equivalent to executing </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1f0395aad0fe853a4539288749d3a603">JSONSerializer&lt;ValueTypeCV&gt;::from_json</a>(*<span class="keyword">this</span>);</div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a1f0395aad0fe853a4539288749d3a603"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a1f0395aad0fe853a4539288749d3a603">nlohmann::detail::from_json</a></div><div class="ttdeci">void from_json(const BasicJsonType &amp;j, typename std::nullptr_t &amp;n)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l03429">json.hpp:3429</a></div></div>
</div><!-- fragment --><p>This overloads is chosen if:</p><ul>
<li><em>ValueType</em> is not <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> and</li>
<li><a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer&lt;ValueType&gt;</a> has a <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code> method of the form <code>ValueType from_json(const basic_json&amp;)</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer&lt;ValueType&gt;</a> has both overloads of <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code>, this one is chosen.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueTypeCV</td><td>the provided value type </td></tr>
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td><a class="el" href="classnlohmann_1_1basic__json.html#ad6ebc5da7ced975bb184133750e7d49f">json_serializer&lt;ValueType&gt;</a> <code><a class="el" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">from_json()</a></code> method throws</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19467">19467</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19469"></a><span class="lineno">19469</span>&#160;            {</div>
<div class="line"><a name="l19470"></a><span class="lineno">19470</span>&#160;                static_assert(!<a class="code" href="namespaceexprtk_1_1details.html#a6f82a5d5d177f717db648d56438fd693">std::is_reference&lt;ValueTypeCV&gt;::value</a>,</div>
<div class="line"><a name="l19471"></a><span class="lineno">19471</span>&#160;                        <span class="stringliteral">&quot;get() cannot be used with reference types, you might want to use get_ref()&quot;</span>);</div>
<div class="line"><a name="l19472"></a><span class="lineno">19472</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">JSONSerializer&lt;ValueType&gt;::from_json</a>(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l19473"></a><span class="lineno">19473</span>&#160;            }</div>
<div class="ttc" id="anamespaceexprtk_1_1details_html_a6f82a5d5d177f717db648d56438fd693"><div class="ttname"><a href="namespaceexprtk_1_1details.html#a6f82a5d5d177f717db648d56438fd693">exprtk::details::value</a></div><div class="ttdeci">T value(details::expression_node&lt; T &gt; *n)</div><div class="ttdef"><b>Definition:</b> <a href="exprtk_8hpp_source.html#l12448">exprtk.hpp:12448</a></div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_aef5c8ea108f4d2b03fb4a635617510de"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">nlohmann::detail::from_json</a></div><div class="ttdeci">void from_json(const BasicJsonType &amp;j, std::unordered_map&lt; Key, Value, Hash, KeyEqual, Allocator &gt; &amp;m)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l03770">json.hpp:3770</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a91198163e5ffd34d361d2db77cb1f112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91198163e5ffd34d361d2db77cb1f112">&#9670;&nbsp;</a></span>get() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!detail::has_non_default_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19416">19416</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19418"></a><span class="lineno">19418</span>&#160;            {</div>
<div class="line"><a name="l19419"></a><span class="lineno">19419</span>&#160;                <span class="comment">// we cannot static_assert on ValueTypeCV being non-const, because</span></div>
<div class="line"><a name="l19420"></a><span class="lineno">19420</span>&#160;                <span class="comment">// there is support for get&lt;const basic_json_t&gt;(), which is why we</span></div>
<div class="line"><a name="l19421"></a><span class="lineno">19421</span>&#160;                <span class="comment">// still need the uncvref</span></div>
<div class="line"><a name="l19422"></a><span class="lineno">19422</span>&#160;                static_assert(!<a class="code" href="namespaceexprtk_1_1details.html#a6f82a5d5d177f717db648d56438fd693">std::is_reference&lt;ValueTypeCV&gt;::value</a>,</div>
<div class="line"><a name="l19423"></a><span class="lineno">19423</span>&#160;                        <span class="stringliteral">&quot;get() cannot be used with reference types, you might want to use get_ref()&quot;</span>);</div>
<div class="line"><a name="l19424"></a><span class="lineno">19424</span>&#160;                static_assert(<a class="code" href="namespaceexprtk_1_1details.html#a6f82a5d5d177f717db648d56438fd693">std::is_default_constructible&lt;ValueType&gt;::value</a>,</div>
<div class="line"><a name="l19425"></a><span class="lineno">19425</span>&#160;                        <span class="stringliteral">&quot;types must be DefaultConstructible when used with get()&quot;</span>);</div>
<div class="line"><a name="l19426"></a><span class="lineno">19426</span>&#160; </div>
<div class="line"><a name="l19427"></a><span class="lineno">19427</span>&#160;                ValueType ret;</div>
<div class="line"><a name="l19428"></a><span class="lineno">19428</span>&#160;                <a class="code" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">JSONSerializer&lt;ValueType&gt;::from_json</a>(*<span class="keyword">this</span>, ret);</div>
<div class="line"><a name="l19429"></a><span class="lineno">19429</span>&#160;                <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l19430"></a><span class="lineno">19430</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a826e180d2457d114ed4c51f4b0737df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826e180d2457d114ed4c51f4b0737df8">&#9670;&nbsp;</a></span>get() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template <a class="el" href="classnlohmann_1_1basic__json.html#a85222410e03d8f5c8ff9c78cf9f6b1b6">get_ptr</a>&lt;PointerType&gt;())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19622">19622</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19623"></a><span class="lineno">19623</span>&#160;            {</div>
<div class="line"><a name="l19624"></a><span class="lineno">19624</span>&#160;                <span class="comment">// delegate the call to get_ptr</span></div>
<div class="line"><a name="l19625"></a><span class="lineno">19625</span>&#160;                <span class="keywordflow">return</span> get_ptr&lt;PointerType&gt;();</div>
<div class="line"><a name="l19626"></a><span class="lineno">19626</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afc55e7dca1a243b0d5011564824c0267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc55e7dca1a243b0d5011564824c0267">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the allocator associated with the container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16806">16806</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l16807"></a><span class="lineno">16807</span>&#160;            {</div>
<div class="line"><a name="l16808"></a><span class="lineno">16808</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">allocator_type</a>();</div>
<div class="line"><a name="l16809"></a><span class="lineno">16809</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ad38ae80f1e99d4b1f33c99fea4611457"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ad38ae80f1e99d4b1f33c99fea4611457">nlohmann::basic_json::allocator_type</a></div><div class="ttdeci">AllocatorType&lt; basic_json &gt; allocator_type</div><div class="ttdoc">the allocator type</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16784">json.hpp:16784</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aab19a246f6bcd27c195bed376cf5e138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab19a246f6bcd27c195bed376cf5e138">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a>&amp; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reference to the binary value</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>if the value is not binary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary()</a> to check if the <a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659" title="overload for a default value of type const char*">value</a> is <a class="el" href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091" title="explicitly create a binary array (without subtype)">binary</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19742">19742</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19743"></a><span class="lineno">19743</span>&#160;            {</div>
<div class="line"><a name="l19744"></a><span class="lineno">19744</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>())</div>
<div class="line"><a name="l19745"></a><span class="lineno">19745</span>&#160;                {</div>
<div class="line"><a name="l19746"></a><span class="lineno">19746</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(302, <span class="stringliteral">&quot;type must be binary, but is &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19747"></a><span class="lineno">19747</span>&#160;                }</div>
<div class="line"><a name="l19748"></a><span class="lineno">19748</span>&#160; </div>
<div class="line"><a name="l19749"></a><span class="lineno">19749</span>&#160;                <span class="keywordflow">return</span> *get_ptr&lt;binary_t*&gt;();</div>
<div class="line"><a name="l19750"></a><span class="lineno">19750</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abbfa5532931abd2d9040cbf4d18a2ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfa5532931abd2d9040cbf4d18a2ca7">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a>&amp; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>reference to the binary value</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>if the value is not binary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary()</a> to check if the <a class="el" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659" title="overload for a default value of type const char*">value</a> is <a class="el" href="classnlohmann_1_1basic__json.html#a3d255dbe024ce2d0fdfb1b4837629091" title="explicitly create a binary array (without subtype)">binary</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19753">19753</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19754"></a><span class="lineno">19754</span>&#160;            {</div>
<div class="line"><a name="l19755"></a><span class="lineno">19755</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>())</div>
<div class="line"><a name="l19756"></a><span class="lineno">19756</span>&#160;                {</div>
<div class="line"><a name="l19757"></a><span class="lineno">19757</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(302, <span class="stringliteral">&quot;type must be binary, but is &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l19758"></a><span class="lineno">19758</span>&#160;                }</div>
<div class="line"><a name="l19759"></a><span class="lineno">19759</span>&#160; </div>
<div class="line"><a name="l19760"></a><span class="lineno">19760</span>&#160;                <span class="keywordflow">return</span> *get_ptr&lt;const binary_t*&gt;();</div>
<div class="line"><a name="l19761"></a><span class="lineno">19761</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afd99a3902a2bb09a306fb854540ae1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd99a3902a2bb09a306fb854540ae1dd">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<p>get special-case overload This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19587">19587</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19588"></a><span class="lineno">19588</span>&#160;            {</div>
<div class="line"><a name="l19589"></a><span class="lineno">19589</span>&#160;                <span class="comment">// delegate the call to get_impl_ptr&lt;&gt;() const</span></div>
<div class="line"><a name="l19590"></a><span class="lineno">19590</span>&#160;                <span class="keywordflow">return</span> get_impl_ptr(<span class="keyword">static_cast&lt;</span>PointerType<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>));</div>
<div class="line"><a name="l19591"></a><span class="lineno">19591</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85222410e03d8f5c8ff9c78cf9f6b1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85222410e03d8f5c8ff9c78cf9f6b1b6">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19574">19574</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19575"></a><span class="lineno">19575</span>&#160;            {</div>
<div class="line"><a name="l19576"></a><span class="lineno">19576</span>&#160;                <span class="comment">// delegate the call to get_impl_ptr&lt;&gt;()</span></div>
<div class="line"><a name="l19577"></a><span class="lineno">19577</span>&#160;                <span class="keywordflow">return</span> get_impl_ptr(<span class="keyword">static_cast&lt;</span>PointerType<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>));</div>
<div class="line"><a name="l19578"></a><span class="lineno">19578</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14ddc6e0f6d70296bc81f810254076c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ddc6e0f6d70296bc81f810254076c5">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19668">19668</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19669"></a><span class="lineno">19669</span>&#160;            {</div>
<div class="line"><a name="l19670"></a><span class="lineno">19670</span>&#160;                <span class="comment">// delegate call to get_ref_impl</span></div>
<div class="line"><a name="l19671"></a><span class="lineno">19671</span>&#160;                <span class="keywordflow">return</span> get_ref_impl&lt;ReferenceType&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l19672"></a><span class="lineno">19672</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f0889072c54f1b899689ed6246238e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0889072c54f1b899689ed6246238e7">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<p>get special-case overload This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19681">19681</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19682"></a><span class="lineno">19682</span>&#160;            {</div>
<div class="line"><a name="l19683"></a><span class="lineno">19683</span>&#160;                <span class="comment">// delegate call to get_ref_impl</span></div>
<div class="line"><a name="l19684"></a><span class="lineno">19684</span>&#160;                <span class="keywordflow">return</span> get_ref_impl&lt;ReferenceType&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l19685"></a><span class="lineno">19685</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85dd41000e4e7751928fffb44ff4aed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dd41000e4e7751928fffb44ff4aed4">&#9670;&nbsp;</a></span>get_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; detail::has_from_json&lt; basic_json_t, Array &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19537">19537</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19540"></a><span class="lineno">19540</span>&#160;            {</div>
<div class="line"><a name="l19541"></a><span class="lineno">19541</span>&#160;                <a class="code" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">JSONSerializer&lt;Array&gt;::from_json</a>(*<span class="keyword">this</span>, v);</div>
<div class="line"><a name="l19542"></a><span class="lineno">19542</span>&#160;                <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l19543"></a><span class="lineno">19543</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6fd6c12364425e4007ee4d7ecf9fefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd6c12364425e4007ee4d7ecf9fefd">&#9670;&nbsp;</a></span>get_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_basic_json&lt; ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType&amp; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19526">19526</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19527"></a><span class="lineno">19527</span>&#160;            {</div>
<div class="line"><a name="l19528"></a><span class="lineno">19528</span>&#160;                v = *<span class="keyword">this</span>;</div>
<div class="line"><a name="l19529"></a><span class="lineno">19529</span>&#160;                <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l19530"></a><span class="lineno">19530</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1cbe06eb6b15f76e41c7c85081d2638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cbe06eb6b15f76e41c7c85081d2638">&#9670;&nbsp;</a></span>get_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType&amp; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19513">19513</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19515"></a><span class="lineno">19515</span>&#160;            {</div>
<div class="line"><a name="l19516"></a><span class="lineno">19516</span>&#160;                <a class="code" href="namespacenlohmann_1_1detail.html#aef5c8ea108f4d2b03fb4a635617510de">JSONSerializer&lt;ValueType&gt;::from_json</a>(*<span class="keyword">this</span>, v);</div>
<div class="line"><a name="l19517"></a><span class="lineno">19517</span>&#160;                <span class="keywordflow">return</span> v;</div>
<div class="line"><a name="l19518"></a><span class="lineno">19518</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0181d03c6314bedcbad2e92d3676223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0181d03c6314bedcbad2e92d3676223c">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22222">22222</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22223"></a><span class="lineno">22223</span>&#160;            {</div>
<div class="line"><a name="l22224"></a><span class="lineno">22224</span>&#160;                <span class="comment">// insert only works for objects</span></div>
<div class="line"><a name="l22225"></a><span class="lineno">22225</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l22226"></a><span class="lineno">22226</span>&#160;                {</div>
<div class="line"><a name="l22227"></a><span class="lineno">22227</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(309, <span class="stringliteral">&quot;cannot use insert() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22228"></a><span class="lineno">22228</span>&#160;                }</div>
<div class="line"><a name="l22229"></a><span class="lineno">22229</span>&#160; </div>
<div class="line"><a name="l22230"></a><span class="lineno">22230</span>&#160;                <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><a name="l22231"></a><span class="lineno">22231</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(first.m_object != last.m_object))</div>
<div class="line"><a name="l22232"></a><span class="lineno">22232</span>&#160;                {</div>
<div class="line"><a name="l22233"></a><span class="lineno">22233</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>));</div>
<div class="line"><a name="l22234"></a><span class="lineno">22234</span>&#160;                }</div>
<div class="line"><a name="l22235"></a><span class="lineno">22235</span>&#160; </div>
<div class="line"><a name="l22236"></a><span class="lineno">22236</span>&#160;                <span class="comment">// passed iterators must belong to objects</span></div>
<div class="line"><a name="l22237"></a><span class="lineno">22237</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!first.m_object-&gt;is_object()))</div>
<div class="line"><a name="l22238"></a><span class="lineno">22238</span>&#160;                {</div>
<div class="line"><a name="l22239"></a><span class="lineno">22239</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterators first and last must point to objects&quot;</span>));</div>
<div class="line"><a name="l22240"></a><span class="lineno">22240</span>&#160;                }</div>
<div class="line"><a name="l22241"></a><span class="lineno">22241</span>&#160; </div>
<div class="line"><a name="l22242"></a><span class="lineno">22242</span>&#160;                m_value.object-&gt;insert(first.m_it.object_iterator, last.m_it.object_iterator);</div>
<div class="line"><a name="l22243"></a><span class="lineno">22243</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c5b9de8a4a759861cb600b38a6c81b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5b9de8a4a759861cb600b38a6c81b1">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element </p>
<p>add an object to an array add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22051">22051</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22052"></a><span class="lineno">22052</span>&#160;            {</div>
<div class="line"><a name="l22053"></a><span class="lineno">22053</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aeb86e8478e20d95970a8b61ff01dce3b">insert</a>(pos, val);</div>
<div class="line"><a name="l22054"></a><span class="lineno">22054</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aeb86e8478e20d95970a8b61ff01dce3b"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aeb86e8478e20d95970a8b61ff01dce3b">nlohmann::basic_json::insert</a></div><div class="ttdeci">iterator insert(const_iterator pos, const basic_json &amp;val)</div><div class="ttdoc">add an object to an array</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l22029">json.hpp:22029</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb86e8478e20d95970a8b61ff01dce3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb86e8478e20d95970a8b61ff01dce3b">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22029">22029</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22030"></a><span class="lineno">22030</span>&#160;            {</div>
<div class="line"><a name="l22031"></a><span class="lineno">22031</span>&#160;                <span class="comment">// insert only works for arrays</span></div>
<div class="line"><a name="l22032"></a><span class="lineno">22032</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l22033"></a><span class="lineno">22033</span>&#160;                {</div>
<div class="line"><a name="l22034"></a><span class="lineno">22034</span>&#160;                    <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><a name="l22035"></a><span class="lineno">22035</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><a name="l22036"></a><span class="lineno">22036</span>&#160;                    {</div>
<div class="line"><a name="l22037"></a><span class="lineno">22037</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>));</div>
<div class="line"><a name="l22038"></a><span class="lineno">22038</span>&#160;                    }</div>
<div class="line"><a name="l22039"></a><span class="lineno">22039</span>&#160; </div>
<div class="line"><a name="l22040"></a><span class="lineno">22040</span>&#160;                    <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><a name="l22041"></a><span class="lineno">22041</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">insert_iterator</a>(pos, val);</div>
<div class="line"><a name="l22042"></a><span class="lineno">22042</span>&#160;                }</div>
<div class="line"><a name="l22043"></a><span class="lineno">22043</span>&#160; </div>
<div class="line"><a name="l22044"></a><span class="lineno">22044</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(309, <span class="stringliteral">&quot;cannot use insert() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22045"></a><span class="lineno">22045</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ab5c8034e997c5b852b92bdc6a3f70994"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">nlohmann::basic_json::insert_iterator</a></div><div class="ttdeci">iterator insert_iterator(const_iterator pos, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21991">json.hpp:21991</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8137d5471edcd71606e42155ed9c23e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8137d5471edcd71606e42155ed9c23e2">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22128">22128</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22129"></a><span class="lineno">22129</span>&#160;            {</div>
<div class="line"><a name="l22130"></a><span class="lineno">22130</span>&#160;                <span class="comment">// insert only works for arrays</span></div>
<div class="line"><a name="l22131"></a><span class="lineno">22131</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l22132"></a><span class="lineno">22132</span>&#160;                {</div>
<div class="line"><a name="l22133"></a><span class="lineno">22133</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(309, <span class="stringliteral">&quot;cannot use insert() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22134"></a><span class="lineno">22134</span>&#160;                }</div>
<div class="line"><a name="l22135"></a><span class="lineno">22135</span>&#160; </div>
<div class="line"><a name="l22136"></a><span class="lineno">22136</span>&#160;                <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><a name="l22137"></a><span class="lineno">22137</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><a name="l22138"></a><span class="lineno">22138</span>&#160;                {</div>
<div class="line"><a name="l22139"></a><span class="lineno">22139</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>));</div>
<div class="line"><a name="l22140"></a><span class="lineno">22140</span>&#160;                }</div>
<div class="line"><a name="l22141"></a><span class="lineno">22141</span>&#160; </div>
<div class="line"><a name="l22142"></a><span class="lineno">22142</span>&#160;                <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><a name="l22143"></a><span class="lineno">22143</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(first.m_object != last.m_object))</div>
<div class="line"><a name="l22144"></a><span class="lineno">22144</span>&#160;                {</div>
<div class="line"><a name="l22145"></a><span class="lineno">22145</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>));</div>
<div class="line"><a name="l22146"></a><span class="lineno">22146</span>&#160;                }</div>
<div class="line"><a name="l22147"></a><span class="lineno">22147</span>&#160; </div>
<div class="line"><a name="l22148"></a><span class="lineno">22148</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(first.m_object == <span class="keyword">this</span>))</div>
<div class="line"><a name="l22149"></a><span class="lineno">22149</span>&#160;                {</div>
<div class="line"><a name="l22150"></a><span class="lineno">22150</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(211, <span class="stringliteral">&quot;passed iterators may not belong to container&quot;</span>));</div>
<div class="line"><a name="l22151"></a><span class="lineno">22151</span>&#160;                }</div>
<div class="line"><a name="l22152"></a><span class="lineno">22152</span>&#160; </div>
<div class="line"><a name="l22153"></a><span class="lineno">22153</span>&#160;                <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><a name="l22154"></a><span class="lineno">22154</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">insert_iterator</a>(pos, first.m_it.array_iterator, last.m_it.array_iterator);</div>
<div class="line"><a name="l22155"></a><span class="lineno">22155</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a856b8764efd21dac4205a00fec82e09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b8764efd21dac4205a00fec82e09a">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22181">22181</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22182"></a><span class="lineno">22182</span>&#160;            {</div>
<div class="line"><a name="l22183"></a><span class="lineno">22183</span>&#160;                <span class="comment">// insert only works for arrays</span></div>
<div class="line"><a name="l22184"></a><span class="lineno">22184</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l22185"></a><span class="lineno">22185</span>&#160;                {</div>
<div class="line"><a name="l22186"></a><span class="lineno">22186</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(309, <span class="stringliteral">&quot;cannot use insert() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22187"></a><span class="lineno">22187</span>&#160;                }</div>
<div class="line"><a name="l22188"></a><span class="lineno">22188</span>&#160; </div>
<div class="line"><a name="l22189"></a><span class="lineno">22189</span>&#160;                <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><a name="l22190"></a><span class="lineno">22190</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><a name="l22191"></a><span class="lineno">22191</span>&#160;                {</div>
<div class="line"><a name="l22192"></a><span class="lineno">22192</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>));</div>
<div class="line"><a name="l22193"></a><span class="lineno">22193</span>&#160;                }</div>
<div class="line"><a name="l22194"></a><span class="lineno">22194</span>&#160; </div>
<div class="line"><a name="l22195"></a><span class="lineno">22195</span>&#160;                <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><a name="l22196"></a><span class="lineno">22196</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">insert_iterator</a>(pos, ilist.begin(), ilist.end());</div>
<div class="line"><a name="l22197"></a><span class="lineno">22197</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71e197e6cc78c3960011f68a75f8ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e197e6cc78c3960011f68a75f8ef22">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22080">22080</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22081"></a><span class="lineno">22081</span>&#160;            {</div>
<div class="line"><a name="l22082"></a><span class="lineno">22082</span>&#160;                <span class="comment">// insert only works for arrays</span></div>
<div class="line"><a name="l22083"></a><span class="lineno">22083</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l22084"></a><span class="lineno">22084</span>&#160;                {</div>
<div class="line"><a name="l22085"></a><span class="lineno">22085</span>&#160;                    <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><a name="l22086"></a><span class="lineno">22086</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><a name="l22087"></a><span class="lineno">22087</span>&#160;                    {</div>
<div class="line"><a name="l22088"></a><span class="lineno">22088</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>));</div>
<div class="line"><a name="l22089"></a><span class="lineno">22089</span>&#160;                    }</div>
<div class="line"><a name="l22090"></a><span class="lineno">22090</span>&#160; </div>
<div class="line"><a name="l22091"></a><span class="lineno">22091</span>&#160;                    <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><a name="l22092"></a><span class="lineno">22092</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ab5c8034e997c5b852b92bdc6a3f70994">insert_iterator</a>(pos, cnt, val);</div>
<div class="line"><a name="l22093"></a><span class="lineno">22093</span>&#160;                }</div>
<div class="line"><a name="l22094"></a><span class="lineno">22094</span>&#160; </div>
<div class="line"><a name="l22095"></a><span class="lineno">22095</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(309, <span class="stringliteral">&quot;cannot use insert() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22096"></a><span class="lineno">22096</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5c8034e997c5b852b92bdc6a3f70994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c8034e997c5b852b92bdc6a3f70994">&#9670;&nbsp;</a></span>insert_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for insertion of an iterator </p><dl class="section note"><dt>Note</dt><dd>: This uses std::distance to support GCC 4.8, see <a href="https://github.com/nlohmann/json/pull/1257">https://github.com/nlohmann/json/pull/1257</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21991">21991</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21992"></a><span class="lineno">21992</span>&#160;            {</div>
<div class="line"><a name="l21993"></a><span class="lineno">21993</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><a name="l21994"></a><span class="lineno">21994</span>&#160;                <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(m_value.array != <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l21995"></a><span class="lineno">21995</span>&#160; </div>
<div class="line"><a name="l21996"></a><span class="lineno">21996</span>&#160;                <span class="keyword">auto</span> insert_pos = std::distance(m_value.array-&gt;begin(), pos.m_it.array_iterator);</div>
<div class="line"><a name="l21997"></a><span class="lineno">21997</span>&#160;                m_value.array-&gt;insert(pos.m_it.array_iterator, std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><a name="l21998"></a><span class="lineno">21998</span>&#160;                result.m_it.array_iterator = m_value.array-&gt;begin() + insert_pos;</div>
<div class="line"><a name="l21999"></a><span class="lineno">21999</span>&#160; </div>
<div class="line"><a name="l22000"></a><span class="lineno">22000</span>&#160;                <span class="comment">// This could have been written as:</span></div>
<div class="line"><a name="l22001"></a><span class="lineno">22001</span>&#160;                <span class="comment">// result.m_it.array_iterator = m_value.array-&gt;insert(pos.m_it.array_iterator, cnt, val);</span></div>
<div class="line"><a name="l22002"></a><span class="lineno">22002</span>&#160;                <span class="comment">// but the return value of insert is missing in GCC 4.8, so it is written this way instead.</span></div>
<div class="line"><a name="l22003"></a><span class="lineno">22003</span>&#160; </div>
<div class="line"><a name="l22004"></a><span class="lineno">22004</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l22005"></a><span class="lineno">22005</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5b70d60a636b9c5e10f6c8caac60b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b70d60a636b9c5e10f6c8caac60b9e">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19080">19080</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19081"></a><span class="lineno">19081</span>&#160;            {</div>
<div class="line"><a name="l19082"></a><span class="lineno">19082</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l19083"></a><span class="lineno">19083</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9576224f7b3ff812a308e7c1e784ea80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9576224f7b3ff812a308e7c1e784ea80">&#9670;&nbsp;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19124">19124</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19125"></a><span class="lineno">19125</span>&#160;            {</div>
<div class="line"><a name="l19126"></a><span class="lineno">19126</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>;</div>
<div class="line"><a name="l19127"></a><span class="lineno">19127</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a911b11e855e685fa59ea1d111490b36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911b11e855e685fa59ea1d111490b36b">&#9670;&nbsp;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18921">18921</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18922"></a><span class="lineno">18922</span>&#160;            {</div>
<div class="line"><a name="l18923"></a><span class="lineno">18923</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>;</div>
<div class="line"><a name="l18924"></a><span class="lineno">18924</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aecaaa0613d3f3a5b49b34b02afc5f85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecaaa0613d3f3a5b49b34b02afc5f85d">&#9670;&nbsp;</a></span>is_discarded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_discarded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19151">19151</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19152"></a><span class="lineno">19152</span>&#160;            {</div>
<div class="line"><a name="l19153"></a><span class="lineno">19153</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>;</div>
<div class="line"><a name="l19154"></a><span class="lineno">19154</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedc7afad96292b5ab61a2e0ad3067f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc7afad96292b5ab61a2e0ad3067f5f">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18899">18899</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18900"></a><span class="lineno">18900</span>&#160;            {</div>
<div class="line"><a name="l18901"></a><span class="lineno">18901</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>;</div>
<div class="line"><a name="l18902"></a><span class="lineno">18902</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd47ac8eba63833152795280f75b5851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd47ac8eba63833152795280f75b5851">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18951">18951</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18952"></a><span class="lineno">18952</span>&#160;            {</div>
<div class="line"><a name="l18953"></a><span class="lineno">18953</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ac4b4acf2c0ad075c0dc125a65c102362">is_number_integer</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a116cdb9300b56519fc9cf756609296cb">is_number_float</a>();</div>
<div class="line"><a name="l18954"></a><span class="lineno">18954</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a116cdb9300b56519fc9cf756609296cb"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a116cdb9300b56519fc9cf756609296cb">nlohmann::basic_json::is_number_float</a></div><div class="ttdeci">constexpr bool is_number_float() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19036">json.hpp:19036</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ac4b4acf2c0ad075c0dc125a65c102362"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ac4b4acf2c0ad075c0dc125a65c102362">nlohmann::basic_json::is_number_integer</a></div><div class="ttdeci">constexpr bool is_number_integer() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l18980">json.hpp:18980</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a116cdb9300b56519fc9cf756609296cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116cdb9300b56519fc9cf756609296cb">&#9670;&nbsp;</a></span>is_number_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19036">19036</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19037"></a><span class="lineno">19037</span>&#160;            {</div>
<div class="line"><a name="l19038"></a><span class="lineno">19038</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>;</div>
<div class="line"><a name="l19039"></a><span class="lineno">19039</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4b4acf2c0ad075c0dc125a65c102362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b4acf2c0ad075c0dc125a65c102362">&#9670;&nbsp;</a></span>is_number_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18980">18980</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18981"></a><span class="lineno">18981</span>&#160;            {</div>
<div class="line"><a name="l18982"></a><span class="lineno">18982</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a> || m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>;</div>
<div class="line"><a name="l18983"></a><span class="lineno">18983</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5493f2ed1e07b0ece428bd5a47e2fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5493f2ed1e07b0ece428bd5a47e2fb95">&#9670;&nbsp;</a></span>is_number_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19008">19008</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19009"></a><span class="lineno">19009</span>&#160;            {</div>
<div class="line"><a name="l19010"></a><span class="lineno">19010</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>;</div>
<div class="line"><a name="l19011"></a><span class="lineno">19011</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57e8411a770a6263d6d8f2116c37f3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e8411a770a6263d6d8f2116c37f3aa">&#9670;&nbsp;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19058">19058</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19059"></a><span class="lineno">19059</span>&#160;            {</div>
<div class="line"><a name="l19060"></a><span class="lineno">19060</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l19061"></a><span class="lineno">19061</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a548d2d4013da24e7d7510d90febc80c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548d2d4013da24e7d7510d90febc80c4">&#9670;&nbsp;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18850">18850</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18851"></a><span class="lineno">18851</span>&#160;            {</div>
<div class="line"><a name="l18852"></a><span class="lineno">18852</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">is_string</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a911b11e855e685fa59ea1d111490b36b">is_boolean</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#abd47ac8eba63833152795280f75b5851">is_number</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>();</div>
<div class="line"><a name="l18853"></a><span class="lineno">18853</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a911b11e855e685fa59ea1d111490b36b"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a911b11e855e685fa59ea1d111490b36b">nlohmann::basic_json::is_boolean</a></div><div class="ttdeci">constexpr bool is_boolean() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l18921">json.hpp:18921</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_abd47ac8eba63833152795280f75b5851"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#abd47ac8eba63833152795280f75b5851">nlohmann::basic_json::is_number</a></div><div class="ttdeci">constexpr bool is_number() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l18951">json.hpp:18951</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab303d17366c26fca12242c7f8def1bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab303d17366c26fca12242c7f8def1bb7">&#9670;&nbsp;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19102">19102</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19103"></a><span class="lineno">19103</span>&#160;            {</div>
<div class="line"><a name="l19104"></a><span class="lineno">19104</span>&#160;                <span class="keywordflow">return</span> m_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>;</div>
<div class="line"><a name="l19105"></a><span class="lineno">19105</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e05a7d5deec758f1d830741b68b4249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e05a7d5deec758f1d830741b68b4249">&#9670;&nbsp;</a></span>is_structured()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_structured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18877">18877</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18878"></a><span class="lineno">18878</span>&#160;            {</div>
<div class="line"><a name="l18879"></a><span class="lineno">18879</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>();</div>
<div class="line"><a name="l18880"></a><span class="lineno">18880</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4faaed730a81347f2f01e93f37c73823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faaed730a81347f2f01e93f37c73823">&#9670;&nbsp;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21371">21371</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21372"></a><span class="lineno">21372</span>&#160;            {</div>
<div class="line"><a name="l21373"></a><span class="lineno">21373</span>&#160;                <span class="keywordflow">return</span> iteration_proxy&lt;const_iterator&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l21374"></a><span class="lineno">21374</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a916a6ba75ec7624e9c6c977a52d6fd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916a6ba75ec7624e9c6c977a52d6fd17">&#9670;&nbsp;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21363">21363</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21364"></a><span class="lineno">21364</span>&#160;            {</div>
<div class="line"><a name="l21365"></a><span class="lineno">21365</span>&#160;                <span class="keywordflow">return</span> iteration_proxy&lt;iterator&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l21366"></a><span class="lineno">21366</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3710ff8c5a1cbedb4f75b700a8962d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3710ff8c5a1cbedb4f75b700a8962d5c">&#9670;&nbsp;</a></span>iterator_wrapper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21290">21290</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21291"></a><span class="lineno">21291</span>&#160;            {</div>
<div class="line"><a name="l21292"></a><span class="lineno">21292</span>&#160;                <span class="keywordflow">return</span> ref.items();</div>
<div class="line"><a name="l21293"></a><span class="lineno">21293</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a22e2e5b0e68d9d7c63be2cada5187259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e2e5b0e68d9d7c63be2cada5187259">&#9670;&nbsp;</a></span>iterator_wrapper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnlohmann_1_1detail_1_1iteration__proxy.html">iteration_proxy</a>&lt;<a class="el" href="classnlohmann_1_1basic__json.html#aa549b2b382916b3baafb526e5cb410bd">iterator</a>&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21281">21281</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21282"></a><span class="lineno">21282</span>&#160;            {</div>
<div class="line"><a name="l21283"></a><span class="lineno">21283</span>&#160;                <span class="keywordflow">return</span> ref.items();</div>
<div class="line"><a name="l21284"></a><span class="lineno">21284</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b46c6631e30b8394e89bd1546d69736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b46c6631e30b8394e89bd1546d69736">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21572">21572</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21573"></a><span class="lineno">21573</span>&#160;            {</div>
<div class="line"><a name="l21574"></a><span class="lineno">21574</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l21575"></a><span class="lineno">21575</span>&#160;                {</div>
<div class="line"><a name="l21576"></a><span class="lineno">21576</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l21577"></a><span class="lineno">21577</span>&#160;                    {</div>
<div class="line"><a name="l21578"></a><span class="lineno">21578</span>&#160;                        <span class="comment">// delegate call to array_t::max_size()</span></div>
<div class="line"><a name="l21579"></a><span class="lineno">21579</span>&#160;                        <span class="keywordflow">return</span> m_value.array-&gt;max_size();</div>
<div class="line"><a name="l21580"></a><span class="lineno">21580</span>&#160;                    }</div>
<div class="line"><a name="l21581"></a><span class="lineno">21581</span>&#160; </div>
<div class="line"><a name="l21582"></a><span class="lineno">21582</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l21583"></a><span class="lineno">21583</span>&#160;                    {</div>
<div class="line"><a name="l21584"></a><span class="lineno">21584</span>&#160;                        <span class="comment">// delegate call to object_t::max_size()</span></div>
<div class="line"><a name="l21585"></a><span class="lineno">21585</span>&#160;                        <span class="keywordflow">return</span> m_value.object-&gt;max_size();</div>
<div class="line"><a name="l21586"></a><span class="lineno">21586</span>&#160;                    }</div>
<div class="line"><a name="l21587"></a><span class="lineno">21587</span>&#160; </div>
<div class="line"><a name="l21588"></a><span class="lineno">21588</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l21589"></a><span class="lineno">21589</span>&#160;                    {</div>
<div class="line"><a name="l21590"></a><span class="lineno">21590</span>&#160;                        <span class="comment">// all other types have max_size() == size()</span></div>
<div class="line"><a name="l21591"></a><span class="lineno">21591</span>&#160;                        <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a33c7c8638bb0b12e6d1b69d8106dd2e0">size</a>();</div>
<div class="line"><a name="l21592"></a><span class="lineno">21592</span>&#160;                    }</div>
<div class="line"><a name="l21593"></a><span class="lineno">21593</span>&#160;                }</div>
<div class="line"><a name="l21594"></a><span class="lineno">21594</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a844a77cb154752d12118f10af26d54cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844a77cb154752d12118f10af26d54cb">&#9670;&nbsp;</a></span>merge_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::merge_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>apply_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l25140">25140</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l25141"></a><span class="lineno">25141</span>&#160;            {</div>
<div class="line"><a name="l25142"></a><span class="lineno">25142</span>&#160;                <span class="keywordflow">if</span> (apply_patch.is_object())</div>
<div class="line"><a name="l25143"></a><span class="lineno">25143</span>&#160;                {</div>
<div class="line"><a name="l25144"></a><span class="lineno">25144</span>&#160;                    <span class="keywordflow">if</span> (!<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>())</div>
<div class="line"><a name="l25145"></a><span class="lineno">25145</span>&#160;                    {</div>
<div class="line"><a name="l25146"></a><span class="lineno">25146</span>&#160;                        *<span class="keyword">this</span> = <a class="code" href="classnlohmann_1_1basic__json.html#a9a4df356e05415438fadf8a15e583903">object</a>();</div>
<div class="line"><a name="l25147"></a><span class="lineno">25147</span>&#160;                    }</div>
<div class="line"><a name="l25148"></a><span class="lineno">25148</span>&#160;                    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = apply_patch.begin(); it != apply_patch.end(); ++it)</div>
<div class="line"><a name="l25149"></a><span class="lineno">25149</span>&#160;                    {</div>
<div class="line"><a name="l25150"></a><span class="lineno">25150</span>&#160;                        <span class="keywordflow">if</span> (it.value().is_null())</div>
<div class="line"><a name="l25151"></a><span class="lineno">25151</span>&#160;                        {</div>
<div class="line"><a name="l25152"></a><span class="lineno">25152</span>&#160;                            <a class="code" href="classnlohmann_1_1basic__json.html#a494632b69bbe1d0153d3bedad0901b8e">erase</a>(it.key());</div>
<div class="line"><a name="l25153"></a><span class="lineno">25153</span>&#160;                        }</div>
<div class="line"><a name="l25154"></a><span class="lineno">25154</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l25155"></a><span class="lineno">25155</span>&#160;                        {</div>
<div class="line"><a name="l25156"></a><span class="lineno">25156</span>&#160;                            <a class="code" href="classnlohmann_1_1basic__json.html#a9ea67fc1ef0ccc42e1d5388fe0416ae5">operator[]</a>(it.key()).<a class="code" href="classnlohmann_1_1basic__json.html#a844a77cb154752d12118f10af26d54cb">merge_patch</a>(it.value());</div>
<div class="line"><a name="l25157"></a><span class="lineno">25157</span>&#160;                        }</div>
<div class="line"><a name="l25158"></a><span class="lineno">25158</span>&#160;                    }</div>
<div class="line"><a name="l25159"></a><span class="lineno">25159</span>&#160;                }</div>
<div class="line"><a name="l25160"></a><span class="lineno">25160</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l25161"></a><span class="lineno">25161</span>&#160;                {</div>
<div class="line"><a name="l25162"></a><span class="lineno">25162</span>&#160;                    *<span class="keyword">this</span> = apply_patch;</div>
<div class="line"><a name="l25163"></a><span class="lineno">25163</span>&#160;                }</div>
<div class="line"><a name="l25164"></a><span class="lineno">25164</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a494632b69bbe1d0153d3bedad0901b8e"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a494632b69bbe1d0153d3bedad0901b8e">nlohmann::basic_json::erase</a></div><div class="ttdeci">IteratorType erase(IteratorType pos)</div><div class="ttdoc">overload for a default value of type const char*</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l20523">json.hpp:20523</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a844a77cb154752d12118f10af26d54cb"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a844a77cb154752d12118f10af26d54cb">nlohmann::basic_json::merge_patch</a></div><div class="ttdeci">void merge_patch(const basic_json &amp;apply_patch)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l25140">json.hpp:25140</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a9ea67fc1ef0ccc42e1d5388fe0416ae5"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a9ea67fc1ef0ccc42e1d5388fe0416ae5">nlohmann::basic_json::operator[]</a></div><div class="ttdeci">reference operator[](size_type idx)</div><div class="ttdoc">overload for a default value of type const char*</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l19995">json.hpp:19995</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a351b4f65014f6c2b8b2832847d44bbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351b4f65014f6c2b8b2832847d44bbd7">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16838">16838</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l16839"></a><span class="lineno">16839</span>&#160;            {</div>
<div class="line"><a name="l16840"></a><span class="lineno">16840</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l16841"></a><span class="lineno">16841</span>&#160; </div>
<div class="line"><a name="l16842"></a><span class="lineno">16842</span>&#160;                result[<span class="stringliteral">&quot;copyright&quot;</span>] = <span class="stringliteral">&quot;(C) 2013-2020 Niels Lohmann&quot;</span>;</div>
<div class="line"><a name="l16843"></a><span class="lineno">16843</span>&#160;                result[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;JSON for Modern C++&quot;</span>;</div>
<div class="line"><a name="l16844"></a><span class="lineno">16844</span>&#160;                result[<span class="stringliteral">&quot;url&quot;</span>] = <span class="stringliteral">&quot;https://github.com/nlohmann/json&quot;</span>;</div>
<div class="line"><a name="l16845"></a><span class="lineno">16845</span>&#160;                result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;string&quot;</span>] =</div>
<div class="line"><a name="l16846"></a><span class="lineno">16846</span>&#160;                        <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(<a class="code" href="json_8hpp.html#a7c94253db90041af11dd946a49f0f8a4">NLOHMANN_JSON_VERSION_MAJOR</a>) + <span class="stringliteral">&quot;.&quot;</span> +</div>
<div class="line"><a name="l16847"></a><span class="lineno">16847</span>&#160;                        <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(<a class="code" href="json_8hpp.html#ab5ca1e164894d78d3276d2e5fe58c5e3">NLOHMANN_JSON_VERSION_MINOR</a>) + <span class="stringliteral">&quot;.&quot;</span> +</div>
<div class="line"><a name="l16848"></a><span class="lineno">16848</span>&#160;                        <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(<a class="code" href="json_8hpp.html#a307e0238ebc35e99ea45c68823eb83eb">NLOHMANN_JSON_VERSION_PATCH</a>);</div>
<div class="line"><a name="l16849"></a><span class="lineno">16849</span>&#160;                result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;major&quot;</span>] = <a class="code" href="json_8hpp.html#a7c94253db90041af11dd946a49f0f8a4">NLOHMANN_JSON_VERSION_MAJOR</a>;</div>
<div class="line"><a name="l16850"></a><span class="lineno">16850</span>&#160;                result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;minor&quot;</span>] = <a class="code" href="json_8hpp.html#ab5ca1e164894d78d3276d2e5fe58c5e3">NLOHMANN_JSON_VERSION_MINOR</a>;</div>
<div class="line"><a name="l16851"></a><span class="lineno">16851</span>&#160;                result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;patch&quot;</span>] = <a class="code" href="json_8hpp.html#a307e0238ebc35e99ea45c68823eb83eb">NLOHMANN_JSON_VERSION_PATCH</a>;</div>
<div class="line"><a name="l16852"></a><span class="lineno">16852</span>&#160; </div>
<div class="line"><a name="l16853"></a><span class="lineno">16853</span>&#160;<span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><a name="l16854"></a><span class="lineno">16854</span>&#160;                result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;win32&quot;</span>;</div>
<div class="line"><a name="l16855"></a><span class="lineno">16855</span>&#160;<span class="preprocessor">#elif defined __linux__</span></div>
<div class="line"><a name="l16856"></a><span class="lineno">16856</span>&#160;                result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;linux&quot;</span>;</div>
<div class="line"><a name="l16857"></a><span class="lineno">16857</span>&#160;<span class="preprocessor">#elif defined __APPLE__</span></div>
<div class="line"><a name="l16858"></a><span class="lineno">16858</span>&#160;                result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;apple&quot;</span>;</div>
<div class="line"><a name="l16859"></a><span class="lineno">16859</span>&#160;<span class="preprocessor">#elif defined __unix__</span></div>
<div class="line"><a name="l16860"></a><span class="lineno">16860</span>&#160;                result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;unix&quot;</span>;</div>
<div class="line"><a name="l16861"></a><span class="lineno">16861</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l16862"></a><span class="lineno">16862</span>&#160;                result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line"><a name="l16863"></a><span class="lineno">16863</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l16864"></a><span class="lineno">16864</span>&#160; </div>
<div class="line"><a name="l16865"></a><span class="lineno">16865</span>&#160;<span class="preprocessor">#if defined(__ICC) || defined(__INTEL_COMPILER)</span></div>
<div class="line"><a name="l16866"></a><span class="lineno">16866</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;icc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __INTEL_COMPILER}};</div>
<div class="line"><a name="l16867"></a><span class="lineno">16867</span>&#160;<span class="preprocessor">#elif defined(__clang__)</span></div>
<div class="line"><a name="l16868"></a><span class="lineno">16868</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;clang&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __clang_version__}};</div>
<div class="line"><a name="l16869"></a><span class="lineno">16869</span>&#160;<span class="preprocessor">#elif defined(__GNUC__) || defined(__GNUG__)</span></div>
<div class="line"><a name="l16870"></a><span class="lineno">16870</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;gcc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(__GNUC__) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(__GNUC_MINOR__) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(__GNUC_PATCHLEVEL__)}};</div>
<div class="line"><a name="l16871"></a><span class="lineno">16871</span>&#160;<span class="preprocessor">#elif defined(__HP_cc) || defined(__HP_aCC)</span></div>
<div class="line"><a name="l16872"></a><span class="lineno">16872</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = <span class="stringliteral">&quot;hp&quot;</span></div>
<div class="line"><a name="l16873"></a><span class="lineno">16873</span>&#160;<span class="preprocessor">#elif defined(__IBMCPP__)</span></div>
<div class="line"><a name="l16874"></a><span class="lineno">16874</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;ilecpp&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __IBMCPP__}};</div>
<div class="line"><a name="l16875"></a><span class="lineno">16875</span>&#160;<span class="preprocessor">#elif defined(_MSC_VER)</span></div>
<div class="line"><a name="l16876"></a><span class="lineno">16876</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;msvc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, _MSC_VER}};</div>
<div class="line"><a name="l16877"></a><span class="lineno">16877</span>&#160;<span class="preprocessor">#elif defined(__PGI)</span></div>
<div class="line"><a name="l16878"></a><span class="lineno">16878</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;pgcpp&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __PGI}};</div>
<div class="line"><a name="l16879"></a><span class="lineno">16879</span>&#160;<span class="preprocessor">#elif defined(__SUNPRO_CC)</span></div>
<div class="line"><a name="l16880"></a><span class="lineno">16880</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;sunpro&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __SUNPRO_CC}};</div>
<div class="line"><a name="l16881"></a><span class="lineno">16881</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l16882"></a><span class="lineno">16882</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>}};</div>
<div class="line"><a name="l16883"></a><span class="lineno">16883</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l16884"></a><span class="lineno">16884</span>&#160; </div>
<div class="line"><a name="l16885"></a><span class="lineno">16885</span>&#160;<span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><a name="l16886"></a><span class="lineno">16886</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>][<span class="stringliteral">&quot;c++&quot;</span>] = <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(__cplusplus);</div>
<div class="line"><a name="l16887"></a><span class="lineno">16887</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l16888"></a><span class="lineno">16888</span>&#160;                result[<span class="stringliteral">&quot;compiler&quot;</span>][<span class="stringliteral">&quot;c++&quot;</span>] = <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line"><a name="l16889"></a><span class="lineno">16889</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l16890"></a><span class="lineno">16890</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l16891"></a><span class="lineno">16891</span>&#160;            }</div>
<div class="ttc" id="ajson_8hpp_html_a307e0238ebc35e99ea45c68823eb83eb"><div class="ttname"><a href="json_8hpp.html#a307e0238ebc35e99ea45c68823eb83eb">NLOHMANN_JSON_VERSION_PATCH</a></div><div class="ttdeci">#define NLOHMANN_JSON_VERSION_PATCH</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l00035">json.hpp:35</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a7c94253db90041af11dd946a49f0f8a4"><div class="ttname"><a href="json_8hpp.html#a7c94253db90041af11dd946a49f0f8a4">NLOHMANN_JSON_VERSION_MAJOR</a></div><div class="ttdeci">#define NLOHMANN_JSON_VERSION_MAJOR</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l00033">json.hpp:33</a></div></div>
<div class="ttc" id="ajson_8hpp_html_ab5ca1e164894d78d3276d2e5fe58c5e3"><div class="ttname"><a href="json_8hpp.html#ab5ca1e164894d78d3276d2e5fe58c5e3">NLOHMANN_JSON_VERSION_MINOR</a></div><div class="ttdeci">#define NLOHMANN_JSON_VERSION_MINOR</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l00034">json.hpp:34</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a4df356e05415438fadf8a15e583903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4df356e05415438fadf8a15e583903">&#9670;&nbsp;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18321">18321</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18321"></a><span class="lineno">18321</span>&#160;                                                               {})</div>
<div class="line"><a name="l18322"></a><span class="lineno">18322</span>&#160;            {</div>
<div class="line"><a name="l18323"></a><span class="lineno">18323</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(init, <span class="keyword">false</span>, <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>);</div>
<div class="line"><a name="l18324"></a><span class="lineno">18324</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d4b8df10ecc533a50823e8805f4a873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4b8df10ecc533a50823e8805f4a873">&#9670;&nbsp;</a></span>operator value_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19177">19177</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19178"></a><span class="lineno">19178</span>&#160;            {</div>
<div class="line"><a name="l19179"></a><span class="lineno">19179</span>&#160;                <span class="keywordflow">return</span> m_type;</div>
<div class="line"><a name="l19180"></a><span class="lineno">19180</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada1463d8d7ba77865f28f5e83dec7f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1463d8d7ba77865f28f5e83dec7f33">&#9670;&nbsp;</a></span>operator ValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename std::enable_if&lt; !std::is_pointer&lt; ValueType &gt;::value &amp;&amp;!std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;::value &amp;&amp;!std::is_same&lt; ValueType, typename string_t::value_type &gt;::value &amp;&amp;!detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;!std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;::value &amp;&amp;detail::is_detected&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#aefed8cf27cadeea45f12c6f3db3ce774">JSON_EXPLICIT</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator ValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get special-case overload </p>
<p>This overloads avoids a lot of template boilerplate, it can be seen as the identity method</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BasicJsonType</td><td>== <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of *this</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Constant.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19727">19727</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19728"></a><span class="lineno">19728</span>&#160;            {</div>
<div class="line"><a name="l19729"></a><span class="lineno">19729</span>&#160;                <span class="comment">// delegate the call to get&lt;&gt;() const</span></div>
<div class="line"><a name="l19730"></a><span class="lineno">19730</span>&#160;                <span class="keywordflow">return</span> get&lt;ValueType&gt;();</div>
<div class="line"><a name="l19731"></a><span class="lineno">19731</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a40226d9c84fcb9cb948ae0c27b842c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40226d9c84fcb9cb948ae0c27b842c57">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21745">21745</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21746"></a><span class="lineno">21746</span>&#160;            {</div>
<div class="line"><a name="l21747"></a><span class="lineno">21747</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(std::move(val));</div>
<div class="line"><a name="l21748"></a><span class="lineno">21748</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l21749"></a><span class="lineno">21749</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_ab9e0253c92736db021840105d374c4c4"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">nlohmann::basic_json::push_back</a></div><div class="ttdeci">void push_back(basic_json &amp;&amp;val)</div><div class="ttdoc">add an object to an array</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21720">json.hpp:21720</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af643a4baa91f484b11af0e4437183115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643a4baa91f484b11af0e4437183115">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21779">21779</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21780"></a><span class="lineno">21780</span>&#160;            {</div>
<div class="line"><a name="l21781"></a><span class="lineno">21781</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(val);</div>
<div class="line"><a name="l21782"></a><span class="lineno">21782</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l21783"></a><span class="lineno">21783</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae300819781bce2193369609457f70f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae300819781bce2193369609457f70f30">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<p>add an object to an array add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21829">21829</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21830"></a><span class="lineno">21830</span>&#160;            {</div>
<div class="line"><a name="l21831"></a><span class="lineno">21831</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(val);</div>
<div class="line"><a name="l21832"></a><span class="lineno">21832</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l21833"></a><span class="lineno">21833</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac48302a8b4f8c2a6e30c2a7bff6abc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48302a8b4f8c2a6e30c2a7bff6abc49">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<p>add an object to an array add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21878">21878</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21879"></a><span class="lineno">21879</span>&#160;            {</div>
<div class="line"><a name="l21880"></a><span class="lineno">21880</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(init);</div>
<div class="line"><a name="l21881"></a><span class="lineno">21881</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l21882"></a><span class="lineno">21882</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ae937c299f347a9dcb7f31a8e57762b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae937c299f347a9dcb7f31a8e57762b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&amp; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<p>Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.</p>
<dl class="section note"><dt>Note</dt><dd>Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a <code>std::vector</code>. Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>container containing bytes to use as binary type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON binary array value</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Linear in the size of <em>init</em>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Strong</td><td>guarantee: if an exception is thrown, there are no changes to any JSON value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 3.8.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18669">18669</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18675"></a><span class="lineno">18675</span>&#160;            {</div>
<div class="line"><a name="l18676"></a><span class="lineno">18676</span>&#160;                <span class="comment">// check that passed value is valid</span></div>
<div class="line"><a name="l18677"></a><span class="lineno">18677</span>&#160;                other.assert_invariant();</div>
<div class="line"><a name="l18678"></a><span class="lineno">18678</span>&#160; </div>
<div class="line"><a name="l18679"></a><span class="lineno">18679</span>&#160;                <span class="keyword">using</span> <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>;</div>
<div class="line"><a name="l18680"></a><span class="lineno">18680</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">swap</a>(m_type, other.m_type);</div>
<div class="line"><a name="l18681"></a><span class="lineno">18681</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">swap</a>(m_value, other.m_value);</div>
<div class="line"><a name="l18682"></a><span class="lineno">18682</span>&#160; </div>
<div class="line"><a name="l18683"></a><span class="lineno">18683</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l18684"></a><span class="lineno">18684</span>&#160;                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l18685"></a><span class="lineno">18685</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a94295a06e0e7b3867fe83afbee4cb202"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a94295a06e0e7b3867fe83afbee4cb202">nlohmann::basic_json::swap</a></div><div class="ttdeci">void swap(reference other) noexcept(std::is_nothrow_move_constructible&lt; value_t &gt;::value &amp;&amp;std::is_nothrow_move_assignable&lt; value_t &gt;::value &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::value &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::value)</div><div class="ttdoc">add an object to an array</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l22366">json.hpp:22366</a></div></div>
<div class="ttc" id="anamespacestd_html_ad33a269e67f055aaa18f57f76b015387"><div class="ttname"><a href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a></div><div class="ttdeci">void swap(mpfr::mpreal &amp;x, mpfr::mpreal &amp;y)</div><div class="ttdef"><b>Definition:</b> <a href="mpreal_8h_source.html#l03151">mpreal.h:3151</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d3deaa73b3644b4da3f8ef3172cd8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3deaa73b3644b4da3f8ef3172cd8d2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24430">24430</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24431"></a><span class="lineno">24431</span>&#160;            {</div>
<div class="line"><a name="l24432"></a><span class="lineno">24432</span>&#160;                <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><a name="l24433"></a><span class="lineno">24433</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a691c29eb7c4acd91ccb498a79cd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a691c29eb7c4acd91ccb498a79cd3ee">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24458">24458</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24459"></a><span class="lineno">24459</span>&#160;            {</div>
<div class="line"><a name="l24460"></a><span class="lineno">24460</span>&#160;                <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><a name="l24461"></a><span class="lineno">24461</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f45f3820c456ad2e3f3df2926564151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f45f3820c456ad2e3f3df2926564151">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20079">20079</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20080"></a><span class="lineno">20080</span>&#160;            {</div>
<div class="line"><a name="l20081"></a><span class="lineno">20081</span>&#160;                <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><a name="l20082"></a><span class="lineno">20082</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l20083"></a><span class="lineno">20083</span>&#160;                {</div>
<div class="line"><a name="l20084"></a><span class="lineno">20084</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l20085"></a><span class="lineno">20085</span>&#160;                    m_value.object = create&lt;object_t&gt;();</div>
<div class="line"><a name="l20086"></a><span class="lineno">20086</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l20087"></a><span class="lineno">20087</span>&#160;                }</div>
<div class="line"><a name="l20088"></a><span class="lineno">20088</span>&#160; </div>
<div class="line"><a name="l20089"></a><span class="lineno">20089</span>&#160;                <span class="comment">// operator[] only works for objects</span></div>
<div class="line"><a name="l20090"></a><span class="lineno">20090</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20091"></a><span class="lineno">20091</span>&#160;                {</div>
<div class="line"><a name="l20092"></a><span class="lineno">20092</span>&#160;                    <span class="keywordflow">return</span> m_value.object-&gt;operator[](<a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a>);</div>
<div class="line"><a name="l20093"></a><span class="lineno">20093</span>&#160;                }</div>
<div class="line"><a name="l20094"></a><span class="lineno">20094</span>&#160; </div>
<div class="line"><a name="l20095"></a><span class="lineno">20095</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20096"></a><span class="lineno">20096</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acb5b489310f4e0ce2d5fb29b73fb59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5b489310f4e0ce2d5fb29b73fb59d3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20128">20128</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20129"></a><span class="lineno">20129</span>&#160;            {</div>
<div class="line"><a name="l20130"></a><span class="lineno">20130</span>&#160;                <span class="comment">// const operator[] only works for objects</span></div>
<div class="line"><a name="l20131"></a><span class="lineno">20131</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20132"></a><span class="lineno">20132</span>&#160;                {</div>
<div class="line"><a name="l20133"></a><span class="lineno">20133</span>&#160;                    <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(m_value.object-&gt;find(key) != m_value.object-&gt;end());</div>
<div class="line"><a name="l20134"></a><span class="lineno">20134</span>&#160;                    <span class="keywordflow">return</span> m_value.object-&gt;find(key)-&gt;second;</div>
<div class="line"><a name="l20135"></a><span class="lineno">20135</span>&#160;                }</div>
<div class="line"><a name="l20136"></a><span class="lineno">20136</span>&#160; </div>
<div class="line"><a name="l20137"></a><span class="lineno">20137</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20138"></a><span class="lineno">20138</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ea67fc1ef0ccc42e1d5388fe0416ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea67fc1ef0ccc42e1d5388fe0416ae5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19995">19995</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l19996"></a><span class="lineno">19996</span>&#160;            {</div>
<div class="line"><a name="l19997"></a><span class="lineno">19997</span>&#160;                <span class="comment">// implicitly convert null value to an empty array</span></div>
<div class="line"><a name="l19998"></a><span class="lineno">19998</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l19999"></a><span class="lineno">19999</span>&#160;                {</div>
<div class="line"><a name="l20000"></a><span class="lineno">20000</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l20001"></a><span class="lineno">20001</span>&#160;                    m_value.array = create&lt;array_t&gt;();</div>
<div class="line"><a name="l20002"></a><span class="lineno">20002</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l20003"></a><span class="lineno">20003</span>&#160;                }</div>
<div class="line"><a name="l20004"></a><span class="lineno">20004</span>&#160; </div>
<div class="line"><a name="l20005"></a><span class="lineno">20005</span>&#160;                <span class="comment">// operator[] only works for arrays</span></div>
<div class="line"><a name="l20006"></a><span class="lineno">20006</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l20007"></a><span class="lineno">20007</span>&#160;                {</div>
<div class="line"><a name="l20008"></a><span class="lineno">20008</span>&#160;                    <span class="comment">// fill up array with null values if given idx is outside range</span></div>
<div class="line"><a name="l20009"></a><span class="lineno">20009</span>&#160;                    <span class="keywordflow">if</span> (idx &gt;= m_value.array-&gt;size())</div>
<div class="line"><a name="l20010"></a><span class="lineno">20010</span>&#160;                    {</div>
<div class="line"><a name="l20011"></a><span class="lineno">20011</span>&#160;                        m_value.array-&gt;insert(m_value.array-&gt;end(),</div>
<div class="line"><a name="l20012"></a><span class="lineno">20012</span>&#160;                                              idx - m_value.array-&gt;size() + 1,</div>
<div class="line"><a name="l20013"></a><span class="lineno">20013</span>&#160;                                              <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>());</div>
<div class="line"><a name="l20014"></a><span class="lineno">20014</span>&#160;                    }</div>
<div class="line"><a name="l20015"></a><span class="lineno">20015</span>&#160; </div>
<div class="line"><a name="l20016"></a><span class="lineno">20016</span>&#160;                    <span class="keywordflow">return</span> m_value.array-&gt;operator[](idx);</div>
<div class="line"><a name="l20017"></a><span class="lineno">20017</span>&#160;                }</div>
<div class="line"><a name="l20018"></a><span class="lineno">20018</span>&#160; </div>
<div class="line"><a name="l20019"></a><span class="lineno">20019</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a numeric argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20020"></a><span class="lineno">20020</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad21d96f490fa1aa8605fba8dadcce319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21d96f490fa1aa8605fba8dadcce319">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20041">20041</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20042"></a><span class="lineno">20042</span>&#160;            {</div>
<div class="line"><a name="l20043"></a><span class="lineno">20043</span>&#160;                <span class="comment">// const operator[] only works for arrays</span></div>
<div class="line"><a name="l20044"></a><span class="lineno">20044</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l20045"></a><span class="lineno">20045</span>&#160;                {</div>
<div class="line"><a name="l20046"></a><span class="lineno">20046</span>&#160;                    <span class="keywordflow">return</span> m_value.array-&gt;operator[](idx);</div>
<div class="line"><a name="l20047"></a><span class="lineno">20047</span>&#160;                }</div>
<div class="line"><a name="l20048"></a><span class="lineno">20048</span>&#160; </div>
<div class="line"><a name="l20049"></a><span class="lineno">20049</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a numeric argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20050"></a><span class="lineno">20050</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc94831476f7b4d3efe6f2e9036c7188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc94831476f7b4d3efe6f2e9036c7188">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20169">20169</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20170"></a><span class="lineno">20170</span>&#160;            {</div>
<div class="line"><a name="l20171"></a><span class="lineno">20171</span>&#160;                <span class="comment">// implicitly convert null to object</span></div>
<div class="line"><a name="l20172"></a><span class="lineno">20172</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l20173"></a><span class="lineno">20173</span>&#160;                {</div>
<div class="line"><a name="l20174"></a><span class="lineno">20174</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l20175"></a><span class="lineno">20175</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l20176"></a><span class="lineno">20176</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l20177"></a><span class="lineno">20177</span>&#160;                }</div>
<div class="line"><a name="l20178"></a><span class="lineno">20178</span>&#160; </div>
<div class="line"><a name="l20179"></a><span class="lineno">20179</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l20180"></a><span class="lineno">20180</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20181"></a><span class="lineno">20181</span>&#160;                {</div>
<div class="line"><a name="l20182"></a><span class="lineno">20182</span>&#160;                    <span class="keywordflow">return</span> m_value.object-&gt;operator[](<a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a>);</div>
<div class="line"><a name="l20183"></a><span class="lineno">20183</span>&#160;                }</div>
<div class="line"><a name="l20184"></a><span class="lineno">20184</span>&#160; </div>
<div class="line"><a name="l20185"></a><span class="lineno">20185</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20186"></a><span class="lineno">20186</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11bbe874496eb7b29a5549e0637de59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bbe874496eb7b29a5549e0637de59e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20220">20220</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20221"></a><span class="lineno">20221</span>&#160;            {</div>
<div class="line"><a name="l20222"></a><span class="lineno">20222</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l20223"></a><span class="lineno">20223</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20224"></a><span class="lineno">20224</span>&#160;                {</div>
<div class="line"><a name="l20225"></a><span class="lineno">20225</span>&#160;                    <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(m_value.object-&gt;find(key) != m_value.object-&gt;end());</div>
<div class="line"><a name="l20226"></a><span class="lineno">20226</span>&#160;                    <span class="keywordflow">return</span> m_value.object-&gt;find(key)-&gt;second;</div>
<div class="line"><a name="l20227"></a><span class="lineno">20227</span>&#160;                }</div>
<div class="line"><a name="l20228"></a><span class="lineno">20228</span>&#160; </div>
<div class="line"><a name="l20229"></a><span class="lineno">20229</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(305, <span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20230"></a><span class="lineno">20230</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a73cf15644f04fa569f50291049d1bafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cf15644f04fa569f50291049d1bafd">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23194">23194</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23198"></a><span class="lineno">23198</span>&#160;            {</div>
<div class="line"><a name="l23199"></a><span class="lineno">23199</span>&#160;                                           <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l23200"></a><span class="lineno">23200</span>&#160;                                           parser(i.get(), cb, allow_exceptions, ignore_comments).parse(<span class="keyword">true</span>, result);</div>
<div class="line"><a name="l23201"></a><span class="lineno">23201</span>&#160;                                           <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23202"></a><span class="lineno">23202</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15018ade392a844ea32d5188d1a0b9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15018ade392a844ea32d5188d1a0b9c6">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23143">23143</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23147"></a><span class="lineno">23147</span>&#160;            {</div>
<div class="line"><a name="l23148"></a><span class="lineno">23148</span>&#160;                                           <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l23149"></a><span class="lineno">23149</span>&#160;                                           parser(<a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i)), cb, allow_exceptions, ignore_comments).parse(<span class="keyword">true</span>, result);</div>
<div class="line"><a name="l23150"></a><span class="lineno">23150</span>&#160;                                           <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23151"></a><span class="lineno">23151</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad832c70af0989389a9a104c21d2d1c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad832c70af0989389a9a104c21d2d1c5c">&#9670;&nbsp;</a></span>parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="json_8hpp.html#a28d7e3b2d26bd5b8a3806da3db7dea03">JSON_HEDLEY_WARN_UNUSED_RESULT</a> <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from a pair of character iterators </p>
<p>The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to start of character range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator to end of character range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>a parser callback function of type <a class="el" href="classnlohmann_1_1basic__json.html#a0273d074462644e5d5a7ff313ad0d742">parser_callback_t</a> which is used to control the deserialization by filtering unwanted values (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_exceptions</td><td>whether to throw exceptions in case of a parse error (optional, true by default) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_comments</td><td>whether comments should be ignored and treated like whitespace (true) or yield a parse error (true); (optional, false by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deserialized JSON value; in case of a parse error and <em>allow_exceptions</em> set to <code>false</code>, the return value will be <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46" title="discarded by the parser callback function">value_t::discarded</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">parse_error.101</td><td>if a parse error occurs; example: <code>""unexpected end of input; expected string literal""</code> </td></tr>
    <tr><td class="paramname">parse_error.102</td><td>if to_unicode fails or surrogate error </td></tr>
    <tr><td class="paramname">parse_error.103</td><td>if to_unicode fails </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23181">23181</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23186"></a><span class="lineno">23186</span>&#160;            {</div>
<div class="line"><a name="l23187"></a><span class="lineno">23187</span>&#160;                                           <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result;</div>
<div class="line"><a name="l23188"></a><span class="lineno">23188</span>&#160;                                           parser(<a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(<span class="keyword">true</span>, result);</div>
<div class="line"><a name="l23189"></a><span class="lineno">23189</span>&#160;                                           <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23190"></a><span class="lineno">23190</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adcc786998f220a5b3083ee8a37c4553e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc786998f220a5b3083ee8a37c4553e">&#9670;&nbsp;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24669">24669</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24670"></a><span class="lineno">24670</span>&#160;            {</div>
<div class="line"><a name="l24671"></a><span class="lineno">24671</span>&#160;                <span class="comment">// make a working copy to apply the patch to</span></div>
<div class="line"><a name="l24672"></a><span class="lineno">24672</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> result = *<span class="keyword">this</span>;</div>
<div class="line"><a name="l24673"></a><span class="lineno">24673</span>&#160; </div>
<div class="line"><a name="l24674"></a><span class="lineno">24674</span>&#160;                <span class="comment">// the valid JSON Patch operations</span></div>
<div class="line"><a name="l24675"></a><span class="lineno">24675</span>&#160;                <span class="keyword">enum class</span> patch_operations {add, remove, <a class="code" href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967dfa9dde360102c103867bd2f45872f1129c">replace</a>, move, copy, test, invalid};</div>
<div class="line"><a name="l24676"></a><span class="lineno">24676</span>&#160; </div>
<div class="line"><a name="l24677"></a><span class="lineno">24677</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> get_op = [](<span class="keyword">const</span> std::string &amp; op)</div>
<div class="line"><a name="l24678"></a><span class="lineno">24678</span>&#160;                {</div>
<div class="line"><a name="l24679"></a><span class="lineno">24679</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;add&quot;</span>)</div>
<div class="line"><a name="l24680"></a><span class="lineno">24680</span>&#160;                    {</div>
<div class="line"><a name="l24681"></a><span class="lineno">24681</span>&#160;                        <span class="keywordflow">return</span> patch_operations::add;</div>
<div class="line"><a name="l24682"></a><span class="lineno">24682</span>&#160;                    }</div>
<div class="line"><a name="l24683"></a><span class="lineno">24683</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;remove&quot;</span>)</div>
<div class="line"><a name="l24684"></a><span class="lineno">24684</span>&#160;                    {</div>
<div class="line"><a name="l24685"></a><span class="lineno">24685</span>&#160;                        <span class="keywordflow">return</span> patch_operations::remove;</div>
<div class="line"><a name="l24686"></a><span class="lineno">24686</span>&#160;                    }</div>
<div class="line"><a name="l24687"></a><span class="lineno">24687</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;replace&quot;</span>)</div>
<div class="line"><a name="l24688"></a><span class="lineno">24688</span>&#160;                    {</div>
<div class="line"><a name="l24689"></a><span class="lineno">24689</span>&#160;                        <span class="keywordflow">return</span> patch_operations::replace;</div>
<div class="line"><a name="l24690"></a><span class="lineno">24690</span>&#160;                    }</div>
<div class="line"><a name="l24691"></a><span class="lineno">24691</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;move&quot;</span>)</div>
<div class="line"><a name="l24692"></a><span class="lineno">24692</span>&#160;                    {</div>
<div class="line"><a name="l24693"></a><span class="lineno">24693</span>&#160;                        <span class="keywordflow">return</span> patch_operations::move;</div>
<div class="line"><a name="l24694"></a><span class="lineno">24694</span>&#160;                    }</div>
<div class="line"><a name="l24695"></a><span class="lineno">24695</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;copy&quot;</span>)</div>
<div class="line"><a name="l24696"></a><span class="lineno">24696</span>&#160;                    {</div>
<div class="line"><a name="l24697"></a><span class="lineno">24697</span>&#160;                        <span class="keywordflow">return</span> patch_operations::copy;</div>
<div class="line"><a name="l24698"></a><span class="lineno">24698</span>&#160;                    }</div>
<div class="line"><a name="l24699"></a><span class="lineno">24699</span>&#160;                    <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;test&quot;</span>)</div>
<div class="line"><a name="l24700"></a><span class="lineno">24700</span>&#160;                    {</div>
<div class="line"><a name="l24701"></a><span class="lineno">24701</span>&#160;                        <span class="keywordflow">return</span> patch_operations::test;</div>
<div class="line"><a name="l24702"></a><span class="lineno">24702</span>&#160;                    }</div>
<div class="line"><a name="l24703"></a><span class="lineno">24703</span>&#160; </div>
<div class="line"><a name="l24704"></a><span class="lineno">24704</span>&#160;                    <span class="keywordflow">return</span> patch_operations::invalid;</div>
<div class="line"><a name="l24705"></a><span class="lineno">24705</span>&#160;                };</div>
<div class="line"><a name="l24706"></a><span class="lineno">24706</span>&#160; </div>
<div class="line"><a name="l24707"></a><span class="lineno">24707</span>&#160;                <span class="comment">// wrapper for &quot;add&quot; operation; add value at ptr</span></div>
<div class="line"><a name="l24708"></a><span class="lineno">24708</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> operation_add = [&amp;result](<a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp; ptr, <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> val)</div>
<div class="line"><a name="l24709"></a><span class="lineno">24709</span>&#160;                {</div>
<div class="line"><a name="l24710"></a><span class="lineno">24710</span>&#160;                    <span class="comment">// adding to the root of the target document means replacing it</span></div>
<div class="line"><a name="l24711"></a><span class="lineno">24711</span>&#160;                    <span class="keywordflow">if</span> (ptr.empty())</div>
<div class="line"><a name="l24712"></a><span class="lineno">24712</span>&#160;                    {</div>
<div class="line"><a name="l24713"></a><span class="lineno">24713</span>&#160;                        result = val;</div>
<div class="line"><a name="l24714"></a><span class="lineno">24714</span>&#160;                        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l24715"></a><span class="lineno">24715</span>&#160;                    }</div>
<div class="line"><a name="l24716"></a><span class="lineno">24716</span>&#160; </div>
<div class="line"><a name="l24717"></a><span class="lineno">24717</span>&#160;                    <span class="comment">// make sure the top element of the pointer exists</span></div>
<div class="line"><a name="l24718"></a><span class="lineno">24718</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> top_pointer = ptr.top();</div>
<div class="line"><a name="l24719"></a><span class="lineno">24719</span>&#160;                    <span class="keywordflow">if</span> (top_pointer != ptr)</div>
<div class="line"><a name="l24720"></a><span class="lineno">24720</span>&#160;                    {</div>
<div class="line"><a name="l24721"></a><span class="lineno">24721</span>&#160;                        result.at(top_pointer);</div>
<div class="line"><a name="l24722"></a><span class="lineno">24722</span>&#160;                    }</div>
<div class="line"><a name="l24723"></a><span class="lineno">24723</span>&#160; </div>
<div class="line"><a name="l24724"></a><span class="lineno">24724</span>&#160;                    <span class="comment">// get reference to parent of JSON pointer ptr</span></div>
<div class="line"><a name="l24725"></a><span class="lineno">24725</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> last_path = ptr.back();</div>
<div class="line"><a name="l24726"></a><span class="lineno">24726</span>&#160;                    ptr.pop_back();</div>
<div class="line"><a name="l24727"></a><span class="lineno">24727</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>&amp; parent = result[ptr];</div>
<div class="line"><a name="l24728"></a><span class="lineno">24728</span>&#160; </div>
<div class="line"><a name="l24729"></a><span class="lineno">24729</span>&#160;                    <span class="keywordflow">switch</span> (parent.m_type)</div>
<div class="line"><a name="l24730"></a><span class="lineno">24730</span>&#160;                    {</div>
<div class="line"><a name="l24731"></a><span class="lineno">24731</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l24732"></a><span class="lineno">24732</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l24733"></a><span class="lineno">24733</span>&#160;                        {</div>
<div class="line"><a name="l24734"></a><span class="lineno">24734</span>&#160;                            <span class="comment">// use operator[] to add value</span></div>
<div class="line"><a name="l24735"></a><span class="lineno">24735</span>&#160;                            parent[last_path] = val;</div>
<div class="line"><a name="l24736"></a><span class="lineno">24736</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24737"></a><span class="lineno">24737</span>&#160;                        }</div>
<div class="line"><a name="l24738"></a><span class="lineno">24738</span>&#160; </div>
<div class="line"><a name="l24739"></a><span class="lineno">24739</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l24740"></a><span class="lineno">24740</span>&#160;                        {</div>
<div class="line"><a name="l24741"></a><span class="lineno">24741</span>&#160;                            <span class="keywordflow">if</span> (last_path == <span class="stringliteral">&quot;-&quot;</span>)</div>
<div class="line"><a name="l24742"></a><span class="lineno">24742</span>&#160;                            {</div>
<div class="line"><a name="l24743"></a><span class="lineno">24743</span>&#160;                                <span class="comment">// special case: append to back</span></div>
<div class="line"><a name="l24744"></a><span class="lineno">24744</span>&#160;                                parent.push_back(val);</div>
<div class="line"><a name="l24745"></a><span class="lineno">24745</span>&#160;                            }</div>
<div class="line"><a name="l24746"></a><span class="lineno">24746</span>&#160;                            <span class="keywordflow">else</span></div>
<div class="line"><a name="l24747"></a><span class="lineno">24747</span>&#160;                            {</div>
<div class="line"><a name="l24748"></a><span class="lineno">24748</span>&#160;                                <span class="keyword">const</span> <span class="keyword">auto</span> idx = json_pointer::array_index(last_path);</div>
<div class="line"><a name="l24749"></a><span class="lineno">24749</span>&#160;                                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(idx &gt; parent.size()))</div>
<div class="line"><a name="l24750"></a><span class="lineno">24750</span>&#160;                                {</div>
<div class="line"><a name="l24751"></a><span class="lineno">24751</span>&#160;                                    <span class="comment">// avoid undefined behavior</span></div>
<div class="line"><a name="l24752"></a><span class="lineno">24752</span>&#160;                                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(401, <span class="stringliteral">&quot;array index &quot;</span> + <a class="code" href="namespacenlohmann.html#a6ce645a0b8717757e096a5b5773b7a16">std::to_string</a>(idx) + <span class="stringliteral">&quot; is out of range&quot;</span>));</div>
<div class="line"><a name="l24753"></a><span class="lineno">24753</span>&#160;                                }</div>
<div class="line"><a name="l24754"></a><span class="lineno">24754</span>&#160; </div>
<div class="line"><a name="l24755"></a><span class="lineno">24755</span>&#160;                                <span class="comment">// default case: insert add offset</span></div>
<div class="line"><a name="l24756"></a><span class="lineno">24756</span>&#160;                                parent.insert(parent.begin() + <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a3d20d11e5dfe95084a76f62eca54fadd">difference_type</a><span class="keyword">&gt;</span>(idx), val);</div>
<div class="line"><a name="l24757"></a><span class="lineno">24757</span>&#160;                            }</div>
<div class="line"><a name="l24758"></a><span class="lineno">24758</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24759"></a><span class="lineno">24759</span>&#160;                        }</div>
<div class="line"><a name="l24760"></a><span class="lineno">24760</span>&#160; </div>
<div class="line"><a name="l24761"></a><span class="lineno">24761</span>&#160;                            <span class="comment">// if there exists a parent it cannot be primitive</span></div>
<div class="line"><a name="l24762"></a><span class="lineno">24762</span>&#160;                        <span class="keywordflow">default</span>:            <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><a name="l24763"></a><span class="lineno">24763</span>&#160;                            <a class="code" href="json_8hpp.html#a69f131cff49da1989667220173fbeae6">JSON_ASSERT</a>(<span class="keyword">false</span>);  <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><a name="l24764"></a><span class="lineno">24764</span>&#160;                    }</div>
<div class="line"><a name="l24765"></a><span class="lineno">24765</span>&#160;                };</div>
<div class="line"><a name="l24766"></a><span class="lineno">24766</span>&#160; </div>
<div class="line"><a name="l24767"></a><span class="lineno">24767</span>&#160;                <span class="comment">// wrapper for &quot;remove&quot; operation; remove value at ptr</span></div>
<div class="line"><a name="l24768"></a><span class="lineno">24768</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> operation_remove = [&amp;result](<a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp; ptr)</div>
<div class="line"><a name="l24769"></a><span class="lineno">24769</span>&#160;                {</div>
<div class="line"><a name="l24770"></a><span class="lineno">24770</span>&#160;                    <span class="comment">// get reference to parent of JSON pointer ptr</span></div>
<div class="line"><a name="l24771"></a><span class="lineno">24771</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> last_path = ptr.back();</div>
<div class="line"><a name="l24772"></a><span class="lineno">24772</span>&#160;                    ptr.pop_back();</div>
<div class="line"><a name="l24773"></a><span class="lineno">24773</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>&amp; parent = result.at(ptr);</div>
<div class="line"><a name="l24774"></a><span class="lineno">24774</span>&#160; </div>
<div class="line"><a name="l24775"></a><span class="lineno">24775</span>&#160;                    <span class="comment">// remove child</span></div>
<div class="line"><a name="l24776"></a><span class="lineno">24776</span>&#160;                    <span class="keywordflow">if</span> (parent.is_object())</div>
<div class="line"><a name="l24777"></a><span class="lineno">24777</span>&#160;                    {</div>
<div class="line"><a name="l24778"></a><span class="lineno">24778</span>&#160;                        <span class="comment">// perform range check</span></div>
<div class="line"><a name="l24779"></a><span class="lineno">24779</span>&#160;                        <span class="keyword">auto</span> it = parent.find(last_path);</div>
<div class="line"><a name="l24780"></a><span class="lineno">24780</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(it != parent.end()))</div>
<div class="line"><a name="l24781"></a><span class="lineno">24781</span>&#160;                        {</div>
<div class="line"><a name="l24782"></a><span class="lineno">24782</span>&#160;                            parent.erase(it);</div>
<div class="line"><a name="l24783"></a><span class="lineno">24783</span>&#160;                        }</div>
<div class="line"><a name="l24784"></a><span class="lineno">24784</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l24785"></a><span class="lineno">24785</span>&#160;                        {</div>
<div class="line"><a name="l24786"></a><span class="lineno">24786</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1out__of__range.html#a3f6d82a6f967c4728a1ec735a7867073">out_of_range::create</a>(403, <span class="stringliteral">&quot;key &#39;&quot;</span> + last_path + <span class="stringliteral">&quot;&#39; not found&quot;</span>));</div>
<div class="line"><a name="l24787"></a><span class="lineno">24787</span>&#160;                        }</div>
<div class="line"><a name="l24788"></a><span class="lineno">24788</span>&#160;                    }</div>
<div class="line"><a name="l24789"></a><span class="lineno">24789</span>&#160;                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent.is_array())</div>
<div class="line"><a name="l24790"></a><span class="lineno">24790</span>&#160;                    {</div>
<div class="line"><a name="l24791"></a><span class="lineno">24791</span>&#160;                        <span class="comment">// note erase performs range check</span></div>
<div class="line"><a name="l24792"></a><span class="lineno">24792</span>&#160;                        parent.erase(json_pointer::array_index(last_path));</div>
<div class="line"><a name="l24793"></a><span class="lineno">24793</span>&#160;                    }</div>
<div class="line"><a name="l24794"></a><span class="lineno">24794</span>&#160;                };</div>
<div class="line"><a name="l24795"></a><span class="lineno">24795</span>&#160; </div>
<div class="line"><a name="l24796"></a><span class="lineno">24796</span>&#160;                <span class="comment">// type check: top level value must be an array</span></div>
<div class="line"><a name="l24797"></a><span class="lineno">24797</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!json_patch.is_array()))</div>
<div class="line"><a name="l24798"></a><span class="lineno">24798</span>&#160;                {</div>
<div class="line"><a name="l24799"></a><span class="lineno">24799</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">parse_error::create</a>(104, 0, <span class="stringliteral">&quot;JSON patch must be an array of objects&quot;</span>));</div>
<div class="line"><a name="l24800"></a><span class="lineno">24800</span>&#160;                }</div>
<div class="line"><a name="l24801"></a><span class="lineno">24801</span>&#160; </div>
<div class="line"><a name="l24802"></a><span class="lineno">24802</span>&#160;                <span class="comment">// iterate and apply the operations</span></div>
<div class="line"><a name="l24803"></a><span class="lineno">24803</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val : json_patch)</div>
<div class="line"><a name="l24804"></a><span class="lineno">24804</span>&#160;                {</div>
<div class="line"><a name="l24805"></a><span class="lineno">24805</span>&#160;                    <span class="comment">// wrapper to get a value for an operation</span></div>
<div class="line"><a name="l24806"></a><span class="lineno">24806</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> get_value = [&amp;val](<span class="keyword">const</span> std::string &amp; op,</div>
<div class="line"><a name="l24807"></a><span class="lineno">24807</span>&#160;                            <span class="keyword">const</span> std::string &amp; member,</div>
<div class="line"><a name="l24808"></a><span class="lineno">24808</span>&#160;                            <span class="keywordtype">bool</span> string_type) -&gt; <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> &amp;</div>
<div class="line"><a name="l24809"></a><span class="lineno">24809</span>&#160;                    {</div>
<div class="line"><a name="l24810"></a><span class="lineno">24810</span>&#160;                        <span class="comment">// find value</span></div>
<div class="line"><a name="l24811"></a><span class="lineno">24811</span>&#160;                        <span class="keyword">auto</span> it = val.m_value.object-&gt;find(member);</div>
<div class="line"><a name="l24812"></a><span class="lineno">24812</span>&#160; </div>
<div class="line"><a name="l24813"></a><span class="lineno">24813</span>&#160;                        <span class="comment">// context-sensitive error message</span></div>
<div class="line"><a name="l24814"></a><span class="lineno">24814</span>&#160;                        <span class="keyword">const</span> <span class="keyword">auto</span> error_msg = (op == <span class="stringliteral">&quot;op&quot;</span>) ? <span class="stringliteral">&quot;operation&quot;</span> : <span class="stringliteral">&quot;operation &#39;&quot;</span> + op + <span class="stringliteral">&quot;&#39;&quot;</span>;</div>
<div class="line"><a name="l24815"></a><span class="lineno">24815</span>&#160; </div>
<div class="line"><a name="l24816"></a><span class="lineno">24816</span>&#160;                        <span class="comment">// check if desired value is present</span></div>
<div class="line"><a name="l24817"></a><span class="lineno">24817</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(it == val.m_value.object-&gt;end()))</div>
<div class="line"><a name="l24818"></a><span class="lineno">24818</span>&#160;                        {</div>
<div class="line"><a name="l24819"></a><span class="lineno">24819</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">parse_error::create</a>(105, 0, error_msg + <span class="stringliteral">&quot; must have member &#39;&quot;</span> + member + <span class="stringliteral">&quot;&#39;&quot;</span>));</div>
<div class="line"><a name="l24820"></a><span class="lineno">24820</span>&#160;                        }</div>
<div class="line"><a name="l24821"></a><span class="lineno">24821</span>&#160; </div>
<div class="line"><a name="l24822"></a><span class="lineno">24822</span>&#160;                        <span class="comment">// check if result is of type string</span></div>
<div class="line"><a name="l24823"></a><span class="lineno">24823</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(string_type &amp;&amp; !it-&gt;second.is_string()))</div>
<div class="line"><a name="l24824"></a><span class="lineno">24824</span>&#160;                        {</div>
<div class="line"><a name="l24825"></a><span class="lineno">24825</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">parse_error::create</a>(105, 0, error_msg + <span class="stringliteral">&quot; must have string member &#39;&quot;</span> + member + <span class="stringliteral">&quot;&#39;&quot;</span>));</div>
<div class="line"><a name="l24826"></a><span class="lineno">24826</span>&#160;                        }</div>
<div class="line"><a name="l24827"></a><span class="lineno">24827</span>&#160; </div>
<div class="line"><a name="l24828"></a><span class="lineno">24828</span>&#160;                        <span class="comment">// no error: return value</span></div>
<div class="line"><a name="l24829"></a><span class="lineno">24829</span>&#160;                        <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><a name="l24830"></a><span class="lineno">24830</span>&#160;                    };</div>
<div class="line"><a name="l24831"></a><span class="lineno">24831</span>&#160; </div>
<div class="line"><a name="l24832"></a><span class="lineno">24832</span>&#160;                    <span class="comment">// type check: every element of the array must be an object</span></div>
<div class="line"><a name="l24833"></a><span class="lineno">24833</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!val.is_object()))</div>
<div class="line"><a name="l24834"></a><span class="lineno">24834</span>&#160;                    {</div>
<div class="line"><a name="l24835"></a><span class="lineno">24835</span>&#160;                        <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">parse_error::create</a>(104, 0, <span class="stringliteral">&quot;JSON patch must be an array of objects&quot;</span>));</div>
<div class="line"><a name="l24836"></a><span class="lineno">24836</span>&#160;                    }</div>
<div class="line"><a name="l24837"></a><span class="lineno">24837</span>&#160; </div>
<div class="line"><a name="l24838"></a><span class="lineno">24838</span>&#160;                    <span class="comment">// collect mandatory members</span></div>
<div class="line"><a name="l24839"></a><span class="lineno">24839</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> op = get_value(<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;op&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><a name="l24840"></a><span class="lineno">24840</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> path = get_value(op, <span class="stringliteral">&quot;path&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><a name="l24841"></a><span class="lineno">24841</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> ptr(path);</div>
<div class="line"><a name="l24842"></a><span class="lineno">24842</span>&#160; </div>
<div class="line"><a name="l24843"></a><span class="lineno">24843</span>&#160;                    <span class="keywordflow">switch</span> (get_op(op))</div>
<div class="line"><a name="l24844"></a><span class="lineno">24844</span>&#160;                    {</div>
<div class="line"><a name="l24845"></a><span class="lineno">24845</span>&#160;                        <span class="keywordflow">case</span> patch_operations::add:</div>
<div class="line"><a name="l24846"></a><span class="lineno">24846</span>&#160;                        {</div>
<div class="line"><a name="l24847"></a><span class="lineno">24847</span>&#160;                            operation_add(ptr, get_value(<span class="stringliteral">&quot;add&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>));</div>
<div class="line"><a name="l24848"></a><span class="lineno">24848</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24849"></a><span class="lineno">24849</span>&#160;                        }</div>
<div class="line"><a name="l24850"></a><span class="lineno">24850</span>&#160; </div>
<div class="line"><a name="l24851"></a><span class="lineno">24851</span>&#160;                        <span class="keywordflow">case</span> patch_operations::remove:</div>
<div class="line"><a name="l24852"></a><span class="lineno">24852</span>&#160;                        {</div>
<div class="line"><a name="l24853"></a><span class="lineno">24853</span>&#160;                            operation_remove(ptr);</div>
<div class="line"><a name="l24854"></a><span class="lineno">24854</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24855"></a><span class="lineno">24855</span>&#160;                        }</div>
<div class="line"><a name="l24856"></a><span class="lineno">24856</span>&#160; </div>
<div class="line"><a name="l24857"></a><span class="lineno">24857</span>&#160;                        <span class="keywordflow">case</span> patch_operations::replace:</div>
<div class="line"><a name="l24858"></a><span class="lineno">24858</span>&#160;                        {</div>
<div class="line"><a name="l24859"></a><span class="lineno">24859</span>&#160;                            <span class="comment">// the &quot;path&quot; location must exist - use at()</span></div>
<div class="line"><a name="l24860"></a><span class="lineno">24860</span>&#160;                            result.at(ptr) = get_value(<span class="stringliteral">&quot;replace&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l24861"></a><span class="lineno">24861</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24862"></a><span class="lineno">24862</span>&#160;                        }</div>
<div class="line"><a name="l24863"></a><span class="lineno">24863</span>&#160; </div>
<div class="line"><a name="l24864"></a><span class="lineno">24864</span>&#160;                        <span class="keywordflow">case</span> patch_operations::move:</div>
<div class="line"><a name="l24865"></a><span class="lineno">24865</span>&#160;                        {</div>
<div class="line"><a name="l24866"></a><span class="lineno">24866</span>&#160;                            <span class="keyword">const</span> <span class="keyword">auto</span> from_path = get_value(<span class="stringliteral">&quot;move&quot;</span>, <span class="stringliteral">&quot;from&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><a name="l24867"></a><span class="lineno">24867</span>&#160;                            <a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> from_ptr(from_path);</div>
<div class="line"><a name="l24868"></a><span class="lineno">24868</span>&#160; </div>
<div class="line"><a name="l24869"></a><span class="lineno">24869</span>&#160;                            <span class="comment">// the &quot;from&quot; location must exist - use at()</span></div>
<div class="line"><a name="l24870"></a><span class="lineno">24870</span>&#160;                            <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> v = result.at(from_ptr);</div>
<div class="line"><a name="l24871"></a><span class="lineno">24871</span>&#160; </div>
<div class="line"><a name="l24872"></a><span class="lineno">24872</span>&#160;                            <span class="comment">// The move operation is functionally identical to a</span></div>
<div class="line"><a name="l24873"></a><span class="lineno">24873</span>&#160;                            <span class="comment">// &quot;remove&quot; operation on the &quot;from&quot; location, followed</span></div>
<div class="line"><a name="l24874"></a><span class="lineno">24874</span>&#160;                            <span class="comment">// immediately by an &quot;add&quot; operation at the target</span></div>
<div class="line"><a name="l24875"></a><span class="lineno">24875</span>&#160;                            <span class="comment">// location with the value that was just removed.</span></div>
<div class="line"><a name="l24876"></a><span class="lineno">24876</span>&#160;                            operation_remove(from_ptr);</div>
<div class="line"><a name="l24877"></a><span class="lineno">24877</span>&#160;                            operation_add(ptr, v);</div>
<div class="line"><a name="l24878"></a><span class="lineno">24878</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24879"></a><span class="lineno">24879</span>&#160;                        }</div>
<div class="line"><a name="l24880"></a><span class="lineno">24880</span>&#160; </div>
<div class="line"><a name="l24881"></a><span class="lineno">24881</span>&#160;                        <span class="keywordflow">case</span> patch_operations::copy:</div>
<div class="line"><a name="l24882"></a><span class="lineno">24882</span>&#160;                        {</div>
<div class="line"><a name="l24883"></a><span class="lineno">24883</span>&#160;                            <span class="keyword">const</span> <span class="keyword">auto</span> from_path = get_value(<span class="stringliteral">&quot;copy&quot;</span>, <span class="stringliteral">&quot;from&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><a name="l24884"></a><span class="lineno">24884</span>&#160;                            <span class="keyword">const</span> <a class="code" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> from_ptr(from_path);</div>
<div class="line"><a name="l24885"></a><span class="lineno">24885</span>&#160; </div>
<div class="line"><a name="l24886"></a><span class="lineno">24886</span>&#160;                            <span class="comment">// the &quot;from&quot; location must exist - use at()</span></div>
<div class="line"><a name="l24887"></a><span class="lineno">24887</span>&#160;                            <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a> v = result.at(from_ptr);</div>
<div class="line"><a name="l24888"></a><span class="lineno">24888</span>&#160; </div>
<div class="line"><a name="l24889"></a><span class="lineno">24889</span>&#160;                            <span class="comment">// The copy is functionally identical to an &quot;add&quot;</span></div>
<div class="line"><a name="l24890"></a><span class="lineno">24890</span>&#160;                            <span class="comment">// operation at the target location using the value</span></div>
<div class="line"><a name="l24891"></a><span class="lineno">24891</span>&#160;                            <span class="comment">// specified in the &quot;from&quot; member.</span></div>
<div class="line"><a name="l24892"></a><span class="lineno">24892</span>&#160;                            operation_add(ptr, v);</div>
<div class="line"><a name="l24893"></a><span class="lineno">24893</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24894"></a><span class="lineno">24894</span>&#160;                        }</div>
<div class="line"><a name="l24895"></a><span class="lineno">24895</span>&#160; </div>
<div class="line"><a name="l24896"></a><span class="lineno">24896</span>&#160;                        <span class="keywordflow">case</span> patch_operations::test:</div>
<div class="line"><a name="l24897"></a><span class="lineno">24897</span>&#160;                        {</div>
<div class="line"><a name="l24898"></a><span class="lineno">24898</span>&#160;                            <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;</div>
<div class="line"><a name="l24899"></a><span class="lineno">24899</span>&#160;                            <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l24900"></a><span class="lineno">24900</span>&#160;                            {</div>
<div class="line"><a name="l24901"></a><span class="lineno">24901</span>&#160;                                <span class="comment">// check if &quot;value&quot; matches the one at &quot;path&quot;</span></div>
<div class="line"><a name="l24902"></a><span class="lineno">24902</span>&#160;                                <span class="comment">// the &quot;path&quot; location must exist - use at()</span></div>
<div class="line"><a name="l24903"></a><span class="lineno">24903</span>&#160;                                success = (result.at(ptr) == get_value(<span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>));</div>
<div class="line"><a name="l24904"></a><span class="lineno">24904</span>&#160;                            }</div>
<div class="line"><a name="l24905"></a><span class="lineno">24905</span>&#160;                            <a class="code" href="json_8hpp.html#a5478b7564e65634cc69432ed3cb6490e">JSON_INTERNAL_CATCH</a> (<a class="code" href="classnlohmann_1_1basic__json.html#a2251d8523fa6d16c0fba6388ffa2ef8c">out_of_range</a>&amp;)</div>
<div class="line"><a name="l24906"></a><span class="lineno">24906</span>&#160;                            {</div>
<div class="line"><a name="l24907"></a><span class="lineno">24907</span>&#160;                                <span class="comment">// ignore out of range errors: success remains false</span></div>
<div class="line"><a name="l24908"></a><span class="lineno">24908</span>&#160;                            }</div>
<div class="line"><a name="l24909"></a><span class="lineno">24909</span>&#160; </div>
<div class="line"><a name="l24910"></a><span class="lineno">24910</span>&#160;                            <span class="comment">// throw an exception if test fails</span></div>
<div class="line"><a name="l24911"></a><span class="lineno">24911</span>&#160;                            <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!success))</div>
<div class="line"><a name="l24912"></a><span class="lineno">24912</span>&#160;                            {</div>
<div class="line"><a name="l24913"></a><span class="lineno">24913</span>&#160;                                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1other__error.html#a87e8ab894e8c85c0d97a0919782d3683">other_error::create</a>(501, <span class="stringliteral">&quot;unsuccessful: &quot;</span> + val.dump()));</div>
<div class="line"><a name="l24914"></a><span class="lineno">24914</span>&#160;                            }</div>
<div class="line"><a name="l24915"></a><span class="lineno">24915</span>&#160; </div>
<div class="line"><a name="l24916"></a><span class="lineno">24916</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l24917"></a><span class="lineno">24917</span>&#160;                        }</div>
<div class="line"><a name="l24918"></a><span class="lineno">24918</span>&#160; </div>
<div class="line"><a name="l24919"></a><span class="lineno">24919</span>&#160;                        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l24920"></a><span class="lineno">24920</span>&#160;                        {</div>
<div class="line"><a name="l24921"></a><span class="lineno">24921</span>&#160;                            <span class="comment">// op must be &quot;add&quot;, &quot;remove&quot;, &quot;replace&quot;, &quot;move&quot;, &quot;copy&quot;, or</span></div>
<div class="line"><a name="l24922"></a><span class="lineno">24922</span>&#160;                            <span class="comment">// &quot;test&quot;</span></div>
<div class="line"><a name="l24923"></a><span class="lineno">24923</span>&#160;                            <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">parse_error::create</a>(105, 0, <span class="stringliteral">&quot;operation value &#39;&quot;</span> + op + <span class="stringliteral">&quot;&#39; is invalid&quot;</span>));</div>
<div class="line"><a name="l24924"></a><span class="lineno">24924</span>&#160;                        }</div>
<div class="line"><a name="l24925"></a><span class="lineno">24925</span>&#160;                    }</div>
<div class="line"><a name="l24926"></a><span class="lineno">24926</span>&#160;                }</div>
<div class="line"><a name="l24927"></a><span class="lineno">24927</span>&#160; </div>
<div class="line"><a name="l24928"></a><span class="lineno">24928</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l24929"></a><span class="lineno">24929</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a2251d8523fa6d16c0fba6388ffa2ef8c"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a2251d8523fa6d16c0fba6388ffa2ef8c">nlohmann::basic_json::out_of_range</a></div><div class="ttdeci">detail::out_of_range out_of_range</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16754">json.hpp:16754</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aa8f1f93b32da01b42413643be32b2c27"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">nlohmann::basic_json::json_pointer</a></div><div class="ttdeci">::nlohmann::json_pointer&lt; basic_json &gt; json_pointer</div><div class="ttdoc">JSON Pointer, see nlohmann::json_pointer.</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16723">json.hpp:16723</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1detail_1_1other__error_html_a87e8ab894e8c85c0d97a0919782d3683"><div class="ttname"><a href="classnlohmann_1_1detail_1_1other__error.html#a87e8ab894e8c85c0d97a0919782d3683">nlohmann::detail::other_error::create</a></div><div class="ttdeci">static other_error create(int id_, const std::string &amp;what_arg)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02655">json.hpp:2655</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1detail_1_1parse__error_html_a137ea4d27de45d8a844fd13451d40f3d"><div class="ttname"><a href="classnlohmann_1_1detail_1_1parse__error.html#a137ea4d27de45d8a844fd13451d40f3d">nlohmann::detail::parse_error::create</a></div><div class="ttdeci">static parse_error create(int id_, const position_t &amp;pos, const std::string &amp;what_arg)</div><div class="ttdoc">create a parse error exception</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02439">json.hpp:2439</a></div></div>
<div class="ttc" id="ajson_8hpp_html_a5478b7564e65634cc69432ed3cb6490e"><div class="ttname"><a href="json_8hpp.html#a5478b7564e65634cc69432ed3cb6490e">JSON_INTERNAL_CATCH</a></div><div class="ttdeci">#define JSON_INTERNAL_CATCH(exception)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02077">json.hpp:2077</a></div></div>
<div class="ttc" id="anamespacenlohmann_1_1detail_html_a5a76b60b26dc8c47256a996d18d967dfa9dde360102c103867bd2f45872f1129c"><div class="ttname"><a href="namespacenlohmann_1_1detail.html#a5a76b60b26dc8c47256a996d18d967dfa9dde360102c103867bd2f45872f1129c">nlohmann::detail::error_handler_t::replace</a></div><div class="ttdeci">@ replace</div><div class="ttdoc">replace invalid UTF-8 sequences with U+FFFD</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9e0253c92736db021840105d374c4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e0253c92736db021840105d374c4c4">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21720">21720</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21721"></a><span class="lineno">21721</span>&#160;            {</div>
<div class="line"><a name="l21722"></a><span class="lineno">21722</span>&#160;                <span class="comment">// push_back only works for null objects or arrays</span></div>
<div class="line"><a name="l21723"></a><span class="lineno">21723</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!(<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>())))</div>
<div class="line"><a name="l21724"></a><span class="lineno">21724</span>&#160;                {</div>
<div class="line"><a name="l21725"></a><span class="lineno">21725</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(308, <span class="stringliteral">&quot;cannot use push_back() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l21726"></a><span class="lineno">21726</span>&#160;                }</div>
<div class="line"><a name="l21727"></a><span class="lineno">21727</span>&#160; </div>
<div class="line"><a name="l21728"></a><span class="lineno">21728</span>&#160;                <span class="comment">// transform null object into an array</span></div>
<div class="line"><a name="l21729"></a><span class="lineno">21729</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l21730"></a><span class="lineno">21730</span>&#160;                {</div>
<div class="line"><a name="l21731"></a><span class="lineno">21731</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21732"></a><span class="lineno">21732</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21733"></a><span class="lineno">21733</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l21734"></a><span class="lineno">21734</span>&#160;                }</div>
<div class="line"><a name="l21735"></a><span class="lineno">21735</span>&#160; </div>
<div class="line"><a name="l21736"></a><span class="lineno">21736</span>&#160;                <span class="comment">// add element to array (move semantics)</span></div>
<div class="line"><a name="l21737"></a><span class="lineno">21737</span>&#160;                m_value.array-&gt;push_back(std::move(val));</div>
<div class="line"><a name="l21738"></a><span class="lineno">21738</span>&#160;                <span class="comment">// if val is moved from, basic_json move constructor marks it null so we do not call the destructor</span></div>
<div class="line"><a name="l21739"></a><span class="lineno">21739</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3405d38087e13994a5a4556065b0be6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3405d38087e13994a5a4556065b0be6d">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21755">21755</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21756"></a><span class="lineno">21756</span>&#160;            {</div>
<div class="line"><a name="l21757"></a><span class="lineno">21757</span>&#160;                <span class="comment">// push_back only works for null objects or arrays</span></div>
<div class="line"><a name="l21758"></a><span class="lineno">21758</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!(<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>())))</div>
<div class="line"><a name="l21759"></a><span class="lineno">21759</span>&#160;                {</div>
<div class="line"><a name="l21760"></a><span class="lineno">21760</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(308, <span class="stringliteral">&quot;cannot use push_back() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l21761"></a><span class="lineno">21761</span>&#160;                }</div>
<div class="line"><a name="l21762"></a><span class="lineno">21762</span>&#160; </div>
<div class="line"><a name="l21763"></a><span class="lineno">21763</span>&#160;                <span class="comment">// transform null object into an array</span></div>
<div class="line"><a name="l21764"></a><span class="lineno">21764</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l21765"></a><span class="lineno">21765</span>&#160;                {</div>
<div class="line"><a name="l21766"></a><span class="lineno">21766</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21767"></a><span class="lineno">21767</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>;</div>
<div class="line"><a name="l21768"></a><span class="lineno">21768</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l21769"></a><span class="lineno">21769</span>&#160;                }</div>
<div class="line"><a name="l21770"></a><span class="lineno">21770</span>&#160; </div>
<div class="line"><a name="l21771"></a><span class="lineno">21771</span>&#160;                <span class="comment">// add element to array</span></div>
<div class="line"><a name="l21772"></a><span class="lineno">21772</span>&#160;                m_value.array-&gt;push_back(val);</div>
<div class="line"><a name="l21773"></a><span class="lineno">21773</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad704839e6a5195e3b76f22e2b9aa63ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad704839e6a5195e3b76f22e2b9aa63ee">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21805">21805</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21806"></a><span class="lineno">21806</span>&#160;            {</div>
<div class="line"><a name="l21807"></a><span class="lineno">21807</span>&#160;                <span class="comment">// push_back only works for null objects or objects</span></div>
<div class="line"><a name="l21808"></a><span class="lineno">21808</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!(<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>() || <a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>())))</div>
<div class="line"><a name="l21809"></a><span class="lineno">21809</span>&#160;                {</div>
<div class="line"><a name="l21810"></a><span class="lineno">21810</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(308, <span class="stringliteral">&quot;cannot use push_back() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l21811"></a><span class="lineno">21811</span>&#160;                }</div>
<div class="line"><a name="l21812"></a><span class="lineno">21812</span>&#160; </div>
<div class="line"><a name="l21813"></a><span class="lineno">21813</span>&#160;                <span class="comment">// transform null object into an object</span></div>
<div class="line"><a name="l21814"></a><span class="lineno">21814</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l21815"></a><span class="lineno">21815</span>&#160;                {</div>
<div class="line"><a name="l21816"></a><span class="lineno">21816</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l21817"></a><span class="lineno">21817</span>&#160;                    m_value = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l21818"></a><span class="lineno">21818</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l21819"></a><span class="lineno">21819</span>&#160;                }</div>
<div class="line"><a name="l21820"></a><span class="lineno">21820</span>&#160; </div>
<div class="line"><a name="l21821"></a><span class="lineno">21821</span>&#160;                <span class="comment">// add element to array</span></div>
<div class="line"><a name="l21822"></a><span class="lineno">21822</span>&#160;                m_value.object-&gt;insert(val);</div>
<div class="line"><a name="l21823"></a><span class="lineno">21823</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4567cf75f19b1efca090f75d7a8a350a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4567cf75f19b1efca090f75d7a8a350a">&#9670;&nbsp;</a></span>push_back() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ac569f292a070dfd2f6b69c16e746095a">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21860">21860</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21861"></a><span class="lineno">21861</span>&#160;            {</div>
<div class="line"><a name="l21862"></a><span class="lineno">21862</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>() &amp;&amp; init.size() == 2 &amp;&amp; (*init.begin())-&gt;is_string())</div>
<div class="line"><a name="l21863"></a><span class="lineno">21863</span>&#160;                {</div>
<div class="line"><a name="l21864"></a><span class="lineno">21864</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>&amp;&amp; <a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a> = init.begin()-&gt;moved_or_copied();</div>
<div class="line"><a name="l21865"></a><span class="lineno">21865</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(<span class="keyword">typename</span> object_t::value_type(</div>
<div class="line"><a name="l21866"></a><span class="lineno">21866</span>&#160;                                  std::move(<a class="code" href="namespacenlohmann_1_1detail.html#a2fb6dae6578e06ae73ca0d7cc8512b1aa3c6e0b8a9c15224a8228b9a98ca1531d">key</a>.get_ref&lt;<a class="code" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>&amp;&gt;()), (init.begin() + 1)-&gt;moved_or_copied()));</div>
<div class="line"><a name="l21867"></a><span class="lineno">21867</span>&#160;                }</div>
<div class="line"><a name="l21868"></a><span class="lineno">21868</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l21869"></a><span class="lineno">21869</span>&#160;                {</div>
<div class="line"><a name="l21870"></a><span class="lineno">21870</span>&#160;                    <a class="code" href="classnlohmann_1_1basic__json.html#ab9e0253c92736db021840105d374c4c4">push_back</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(init));</div>
<div class="line"><a name="l21871"></a><span class="lineno">21871</span>&#160;                }</div>
<div class="line"><a name="l21872"></a><span class="lineno">21872</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab1329f44c8301b7679962726a043549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1329f44c8301b7679962726a043549">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21122">21122</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21123"></a><span class="lineno">21123</span>&#160;            {</div>
<div class="line"><a name="l21124"></a><span class="lineno">21124</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a044298d189bdf7e4b36492de9811ddd6">crbegin</a>();</div>
<div class="line"><a name="l21125"></a><span class="lineno">21125</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a044298d189bdf7e4b36492de9811ddd6"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a044298d189bdf7e4b36492de9811ddd6">nlohmann::basic_json::crbegin</a></div><div class="ttdeci">const_reverse_iterator crbegin() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21188">json.hpp:21188</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aff8e38cd973bc94557fa8d36433c0e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8e38cd973bc94557fa8d36433c0e4c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21114">21114</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21115"></a><span class="lineno">21115</span>&#160;            {</div>
<div class="line"><a name="l21116"></a><span class="lineno">21116</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>());</div>
<div class="line"><a name="l21117"></a><span class="lineno">21117</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a5b8c0ebedd920b507f4f7ff4e19bf3c6"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">nlohmann::basic_json::reverse_iterator</a></div><div class="ttdeci">json_reverse_iterator&lt; typename basic_json::iterator &gt; reverse_iterator</div><div class="ttdoc">a reverse iterator for a basic_json container</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l16796">json.hpp:16796</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e4cbf41d593d41847b90aea55e5e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4cbf41d593d41847b90aea55e5e84d">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#aa7dba16ed9ee97380aeb17a207dd919a">const_reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21159">21159</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21160"></a><span class="lineno">21160</span>&#160;            {</div>
<div class="line"><a name="l21161"></a><span class="lineno">21161</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a223480466a0922267d680ec8f0722d58">crend</a>();</div>
<div class="line"><a name="l21162"></a><span class="lineno">21162</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a223480466a0922267d680ec8f0722d58"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a223480466a0922267d680ec8f0722d58">nlohmann::basic_json::crend</a></div><div class="ttdeci">const_reverse_iterator crend() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l21217">json.hpp:21217</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a328b29b290cc300345376c54f618cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a328b29b290cc300345376c54f618cb">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21151">21151</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21152"></a><span class="lineno">21152</span>&#160;            {</div>
<div class="line"><a name="l21153"></a><span class="lineno">21153</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a5b8c0ebedd920b507f4f7ff4e19bf3c6">reverse_iterator</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a23b495b4c282e4afacf382f5b49af7c7">begin</a>());</div>
<div class="line"><a name="l21154"></a><span class="lineno">21154</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aef9ef0a817ecde8bf270653e8706c150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9ef0a817ecde8bf270653e8706c150">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23325">23325</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23329"></a><span class="lineno">23329</span>&#160;            {</div>
<div class="line"><a name="l23330"></a><span class="lineno">23330</span>&#160;                <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><a name="l23331"></a><span class="lineno">23331</span>&#160;                <span class="keywordflow">return</span> format == <a class="code" href="namespacenlohmann.html#a2bfd99e845a2e5cd90aeaf1b1431f474">input_format_t::json</a></div>
<div class="line"><a name="l23332"></a><span class="lineno">23332</span>&#160;                        ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><a name="l23333"></a><span class="lineno">23333</span>&#160;                        : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);</div>
<div class="line"><a name="l23334"></a><span class="lineno">23334</span>&#160;            }</div>
<div class="ttc" id="anamespacenlohmann_html_a2bfd99e845a2e5cd90aeaf1b1431f474"><div class="ttname"><a href="namespacenlohmann.html#a2bfd99e845a2e5cd90aeaf1b1431f474">nlohmann::json</a></div><div class="ttdeci">basic_json&lt;&gt; json</div><div class="ttdoc">default JSON class</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l02936">json.hpp:2936</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a12b382c6407da5543827ce4b24bb5008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b382c6407da5543827ce4b24bb5008">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType , typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23298">23298</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23302"></a><span class="lineno">23302</span>&#160;            {</div>
<div class="line"><a name="l23303"></a><span class="lineno">23303</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><a name="l23304"></a><span class="lineno">23304</span>&#160;                <span class="keywordflow">return</span> format == <a class="code" href="namespacenlohmann.html#a2bfd99e845a2e5cd90aeaf1b1431f474">input_format_t::json</a></div>
<div class="line"><a name="l23305"></a><span class="lineno">23305</span>&#160;                        ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><a name="l23306"></a><span class="lineno">23306</span>&#160;                        : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);</div>
<div class="line"><a name="l23307"></a><span class="lineno">23307</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab62241c2694a054818edf2f66d72f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62241c2694a054818edf2f66d72f113">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , class SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenlohmann_1_1detail.html#aa554fc6a11519e4f347deb25a9f0db40">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23311">23311</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23315"></a><span class="lineno">23315</span>&#160;            {</div>
<div class="line"><a name="l23316"></a><span class="lineno">23316</span>&#160;                <span class="keyword">auto</span> ia = <a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(std::move(first), std::move(last));</div>
<div class="line"><a name="l23317"></a><span class="lineno">23317</span>&#160;                <span class="keywordflow">return</span> format == <a class="code" href="namespacenlohmann.html#a2bfd99e845a2e5cd90aeaf1b1431f474">input_format_t::json</a></div>
<div class="line"><a name="l23318"></a><span class="lineno">23318</span>&#160;                        ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><a name="l23319"></a><span class="lineno">23319</span>&#160;                        : detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;(std::move(ia)).sax_parse(format, sax, strict);</div>
<div class="line"><a name="l23320"></a><span class="lineno">23320</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33c7c8638bb0b12e6d1b69d8106dd2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c7c8638bb0b12e6d1b69d8106dd2e0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a3ada29bca70b4965f6fd37ec1c8f85f7">size_type</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21501">21501</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l21502"></a><span class="lineno">21502</span>&#160;            {</div>
<div class="line"><a name="l21503"></a><span class="lineno">21503</span>&#160;                <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l21504"></a><span class="lineno">21504</span>&#160;                {</div>
<div class="line"><a name="l21505"></a><span class="lineno">21505</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l21506"></a><span class="lineno">21506</span>&#160;                    {</div>
<div class="line"><a name="l21507"></a><span class="lineno">21507</span>&#160;                        <span class="comment">// null values are empty</span></div>
<div class="line"><a name="l21508"></a><span class="lineno">21508</span>&#160;                        <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l21509"></a><span class="lineno">21509</span>&#160;                    }</div>
<div class="line"><a name="l21510"></a><span class="lineno">21510</span>&#160; </div>
<div class="line"><a name="l21511"></a><span class="lineno">21511</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l21512"></a><span class="lineno">21512</span>&#160;                    {</div>
<div class="line"><a name="l21513"></a><span class="lineno">21513</span>&#160;                        <span class="comment">// delegate call to array_t::size()</span></div>
<div class="line"><a name="l21514"></a><span class="lineno">21514</span>&#160;                        <span class="keywordflow">return</span> m_value.array-&gt;size();</div>
<div class="line"><a name="l21515"></a><span class="lineno">21515</span>&#160;                    }</div>
<div class="line"><a name="l21516"></a><span class="lineno">21516</span>&#160; </div>
<div class="line"><a name="l21517"></a><span class="lineno">21517</span>&#160;                    <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l21518"></a><span class="lineno">21518</span>&#160;                    {</div>
<div class="line"><a name="l21519"></a><span class="lineno">21519</span>&#160;                        <span class="comment">// delegate call to object_t::size()</span></div>
<div class="line"><a name="l21520"></a><span class="lineno">21520</span>&#160;                        <span class="keywordflow">return</span> m_value.object-&gt;size();</div>
<div class="line"><a name="l21521"></a><span class="lineno">21521</span>&#160;                    }</div>
<div class="line"><a name="l21522"></a><span class="lineno">21522</span>&#160; </div>
<div class="line"><a name="l21523"></a><span class="lineno">21523</span>&#160;                    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l21524"></a><span class="lineno">21524</span>&#160;                    {</div>
<div class="line"><a name="l21525"></a><span class="lineno">21525</span>&#160;                        <span class="comment">// all other types have size 1</span></div>
<div class="line"><a name="l21526"></a><span class="lineno">21526</span>&#160;                        <span class="keywordflow">return</span> 1;</div>
<div class="line"><a name="l21527"></a><span class="lineno">21527</span>&#160;                    }</div>
<div class="line"><a name="l21528"></a><span class="lineno">21528</span>&#160;                }</div>
<div class="line"><a name="l21529"></a><span class="lineno">21529</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a76126242de262f6d38cadda19e0d13e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76126242de262f6d38cadda19e0d13e1">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a858c1cf8407bc06494e3a1114a3b73e7">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22426">22426</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22427"></a><span class="lineno">22427</span>&#160;            {</div>
<div class="line"><a name="l22428"></a><span class="lineno">22428</span>&#160;                <span class="comment">// swap only works for arrays</span></div>
<div class="line"><a name="l22429"></a><span class="lineno">22429</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab5b70d60a636b9c5e10f6c8caac60b9e">is_array</a>()))</div>
<div class="line"><a name="l22430"></a><span class="lineno">22430</span>&#160;                {</div>
<div class="line"><a name="l22431"></a><span class="lineno">22431</span>&#160;                    <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(*(m_value.array), other);</div>
<div class="line"><a name="l22432"></a><span class="lineno">22432</span>&#160;                }</div>
<div class="line"><a name="l22433"></a><span class="lineno">22433</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l22434"></a><span class="lineno">22434</span>&#160;                {</div>
<div class="line"><a name="l22435"></a><span class="lineno">22435</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(310, <span class="stringliteral">&quot;cannot use swap() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22436"></a><span class="lineno">22436</span>&#160;                }</div>
<div class="line"><a name="l22437"></a><span class="lineno">22437</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa242e339ebc7583e114f2167a83f8c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa242e339ebc7583e114f2167a83f8c90">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ad6c955145bebde84d93991ffed7cd389">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22525">22525</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22526"></a><span class="lineno">22526</span>&#160;            {</div>
<div class="line"><a name="l22527"></a><span class="lineno">22527</span>&#160;                <span class="comment">// swap only works for strings</span></div>
<div class="line"><a name="l22528"></a><span class="lineno">22528</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>()))</div>
<div class="line"><a name="l22529"></a><span class="lineno">22529</span>&#160;                {</div>
<div class="line"><a name="l22530"></a><span class="lineno">22530</span>&#160;                    <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(*(m_value.binary), other);</div>
<div class="line"><a name="l22531"></a><span class="lineno">22531</span>&#160;                }</div>
<div class="line"><a name="l22532"></a><span class="lineno">22532</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l22533"></a><span class="lineno">22533</span>&#160;                {</div>
<div class="line"><a name="l22534"></a><span class="lineno">22534</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(310, <span class="stringliteral">&quot;cannot use swap() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22535"></a><span class="lineno">22535</span>&#160;                }</div>
<div class="line"><a name="l22536"></a><span class="lineno">22536</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57b86bdcfc55557dacc36969adb0417e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b86bdcfc55557dacc36969adb0417e">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aef3ff5a73597850597d1d40db9edd376">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22459">22459</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22460"></a><span class="lineno">22460</span>&#160;            {</div>
<div class="line"><a name="l22461"></a><span class="lineno">22461</span>&#160;                <span class="comment">// swap only works for objects</span></div>
<div class="line"><a name="l22462"></a><span class="lineno">22462</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l22463"></a><span class="lineno">22463</span>&#160;                {</div>
<div class="line"><a name="l22464"></a><span class="lineno">22464</span>&#160;                    <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(*(m_value.object), other);</div>
<div class="line"><a name="l22465"></a><span class="lineno">22465</span>&#160;                }</div>
<div class="line"><a name="l22466"></a><span class="lineno">22466</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l22467"></a><span class="lineno">22467</span>&#160;                {</div>
<div class="line"><a name="l22468"></a><span class="lineno">22468</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(310, <span class="stringliteral">&quot;cannot use swap() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22469"></a><span class="lineno">22469</span>&#160;                }</div>
<div class="line"><a name="l22470"></a><span class="lineno">22470</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94295a06e0e7b3867fe83afbee4cb202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94295a06e0e7b3867fe83afbee4cb202">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22366">22366</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22372"></a><span class="lineno">22372</span>&#160;            {</div>
<div class="line"><a name="l22373"></a><span class="lineno">22373</span>&#160;                <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(m_type, other.m_type);</div>
<div class="line"><a name="l22374"></a><span class="lineno">22374</span>&#160;                <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(m_value, other.m_value);</div>
<div class="line"><a name="l22375"></a><span class="lineno">22375</span>&#160;                assert_invariant();</div>
<div class="line"><a name="l22376"></a><span class="lineno">22376</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac916df9561daf4eaf2372119fe91899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac916df9561daf4eaf2372119fe91899">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22492">22492</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22493"></a><span class="lineno">22493</span>&#160;            {</div>
<div class="line"><a name="l22494"></a><span class="lineno">22494</span>&#160;                <span class="comment">// swap only works for strings</span></div>
<div class="line"><a name="l22495"></a><span class="lineno">22495</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#ab303d17366c26fca12242c7f8def1bb7">is_string</a>()))</div>
<div class="line"><a name="l22496"></a><span class="lineno">22496</span>&#160;                {</div>
<div class="line"><a name="l22497"></a><span class="lineno">22497</span>&#160;                    <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(*(m_value.string), other);</div>
<div class="line"><a name="l22498"></a><span class="lineno">22498</span>&#160;                }</div>
<div class="line"><a name="l22499"></a><span class="lineno">22499</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l22500"></a><span class="lineno">22500</span>&#160;                {</div>
<div class="line"><a name="l22501"></a><span class="lineno">22501</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(310, <span class="stringliteral">&quot;cannot use swap() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22502"></a><span class="lineno">22502</span>&#160;                }</div>
<div class="line"><a name="l22503"></a><span class="lineno">22503</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a749a1f5091a5e63ccfe919e0aef986af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749a1f5091a5e63ccfe919e0aef986af">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classnlohmann_1_1byte__container__with__subtype.html#a4d27e8633c5a5e3b49dd4ccb06515713">binary_t::container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22539">22539</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22540"></a><span class="lineno">22540</span>&#160;            {</div>
<div class="line"><a name="l22541"></a><span class="lineno">22541</span>&#160;                <span class="comment">// swap only works for strings</span></div>
<div class="line"><a name="l22542"></a><span class="lineno">22542</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a9576224f7b3ff812a308e7c1e784ea80">is_binary</a>()))</div>
<div class="line"><a name="l22543"></a><span class="lineno">22543</span>&#160;                {</div>
<div class="line"><a name="l22544"></a><span class="lineno">22544</span>&#160;                    <a class="code" href="namespacestd.html#ad33a269e67f055aaa18f57f76b015387">std::swap</a>(*(m_value.binary), other);</div>
<div class="line"><a name="l22545"></a><span class="lineno">22545</span>&#160;                }</div>
<div class="line"><a name="l22546"></a><span class="lineno">22546</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l22547"></a><span class="lineno">22547</span>&#160;                {</div>
<div class="line"><a name="l22548"></a><span class="lineno">22548</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(310, <span class="stringliteral">&quot;cannot use swap() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22549"></a><span class="lineno">22549</span>&#160;                }</div>
<div class="line"><a name="l22550"></a><span class="lineno">22550</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa62d64781b217372225a0652047d8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62d64781b217372225a0652047d8cf3">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;uint8_t&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23834">23834</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23835"></a><span class="lineno">23835</span>&#160;            {</div>
<div class="line"><a name="l23836"></a><span class="lineno">23836</span>&#160;                std::vector&lt;uint8_t&gt; result;</div>
<div class="line"><a name="l23837"></a><span class="lineno">23837</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson</a>(j, result);</div>
<div class="line"><a name="l23838"></a><span class="lineno">23838</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23839"></a><span class="lineno">23839</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aa62d64781b217372225a0652047d8cf3"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">nlohmann::basic_json::to_bson</a></div><div class="ttdeci">static std::vector&lt; uint8_t &gt; to_bson(const basic_json &amp;j)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23834">json.hpp:23834</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ebed178fb7dad1a574bcb7c361fb1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebed178fb7dad1a574bcb7c361fb1b8">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23857">23857</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23858"></a><span class="lineno">23858</span>&#160;            {</div>
<div class="line"><a name="l23859"></a><span class="lineno">23859</span>&#160;                binary_writer&lt;char&gt;(o).write_bson(j);</div>
<div class="line"><a name="l23860"></a><span class="lineno">23860</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a668e4c2ad9808218a25879700f4aef2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e4c2ad9808218a25879700f4aef2b">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23849">23849</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23850"></a><span class="lineno">23850</span>&#160;            {</div>
<div class="line"><a name="l23851"></a><span class="lineno">23851</span>&#160;                binary_writer&lt;uint8_t&gt;(o).write_bson(j);</div>
<div class="line"><a name="l23852"></a><span class="lineno">23852</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adabcf74c9c868da3e04a5546b7705af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabcf74c9c868da3e04a5546b7705af4">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;uint8_t&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23558">23558</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23559"></a><span class="lineno">23559</span>&#160;            {</div>
<div class="line"><a name="l23560"></a><span class="lineno">23560</span>&#160;                std::vector&lt;uint8_t&gt; result;</div>
<div class="line"><a name="l23561"></a><span class="lineno">23561</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#adabcf74c9c868da3e04a5546b7705af4">to_cbor</a>(j, result);</div>
<div class="line"><a name="l23562"></a><span class="lineno">23562</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23563"></a><span class="lineno">23563</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_adabcf74c9c868da3e04a5546b7705af4"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#adabcf74c9c868da3e04a5546b7705af4">nlohmann::basic_json::to_cbor</a></div><div class="ttdeci">static std::vector&lt; uint8_t &gt; to_cbor(const basic_json &amp;j)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23558">json.hpp:23558</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5689672954fd3bc38f2f17e5607064c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5689672954fd3bc38f2f17e5607064c6">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23570">23570</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23571"></a><span class="lineno">23571</span>&#160;            {</div>
<div class="line"><a name="l23572"></a><span class="lineno">23572</span>&#160;                binary_writer&lt;char&gt;(o).write_cbor(j);</div>
<div class="line"><a name="l23573"></a><span class="lineno">23573</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2becf604016783e5644eaa7782a08683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2becf604016783e5644eaa7782a08683">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23565">23565</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23566"></a><span class="lineno">23566</span>&#160;            {</div>
<div class="line"><a name="l23567"></a><span class="lineno">23567</span>&#160;                binary_writer&lt;uint8_t&gt;(o).write_cbor(j);</div>
<div class="line"><a name="l23568"></a><span class="lineno">23568</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99b15bcaee410426b937eacc6e47d771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b15bcaee410426b937eacc6e47d771">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;uint8_t&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23653">23653</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23654"></a><span class="lineno">23654</span>&#160;            {</div>
<div class="line"><a name="l23655"></a><span class="lineno">23655</span>&#160;                std::vector&lt;uint8_t&gt; result;</div>
<div class="line"><a name="l23656"></a><span class="lineno">23656</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a99b15bcaee410426b937eacc6e47d771">to_msgpack</a>(j, result);</div>
<div class="line"><a name="l23657"></a><span class="lineno">23657</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23658"></a><span class="lineno">23658</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a99b15bcaee410426b937eacc6e47d771"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a99b15bcaee410426b937eacc6e47d771">nlohmann::basic_json::to_msgpack</a></div><div class="ttdeci">static std::vector&lt; uint8_t &gt; to_msgpack(const basic_json &amp;j)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23653">json.hpp:23653</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aca5dc0fca52131f3a634372120abfbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5dc0fca52131f3a634372120abfbe7">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23665">23665</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23666"></a><span class="lineno">23666</span>&#160;            {</div>
<div class="line"><a name="l23667"></a><span class="lineno">23667</span>&#160;                binary_writer&lt;char&gt;(o).write_msgpack(j);</div>
<div class="line"><a name="l23668"></a><span class="lineno">23668</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8fe46eda86f6f92c5599c20b6c81819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fe46eda86f6f92c5599c20b6c81819">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23660">23660</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23661"></a><span class="lineno">23661</span>&#160;            {</div>
<div class="line"><a name="l23662"></a><span class="lineno">23662</span>&#160;                binary_writer&lt;uint8_t&gt;(o).write_msgpack(j);</div>
<div class="line"><a name="l23663"></a><span class="lineno">23663</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a25355b9719db23b189fb5f6a8f4f16c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25355b9719db23b189fb5f6a8f4f16c4">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;uint8_t&gt; <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23756">23756</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23759"></a><span class="lineno">23759</span>&#160;            {</div>
<div class="line"><a name="l23760"></a><span class="lineno">23760</span>&#160;                std::vector&lt;uint8_t&gt; result;</div>
<div class="line"><a name="l23761"></a><span class="lineno">23761</span>&#160;                <a class="code" href="classnlohmann_1_1basic__json.html#a25355b9719db23b189fb5f6a8f4f16c4">to_ubjson</a>(j, result, use_size, use_type);</div>
<div class="line"><a name="l23762"></a><span class="lineno">23762</span>&#160;                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l23763"></a><span class="lineno">23763</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a25355b9719db23b189fb5f6a8f4f16c4"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a25355b9719db23b189fb5f6a8f4f16c4">nlohmann::basic_json::to_ubjson</a></div><div class="ttdeci">static std::vector&lt; uint8_t &gt; to_ubjson(const basic_json &amp;j, const bool use_size=false, const bool use_type=false)</div><div class="ttdoc">Serializes the given JSON object j to BSON and forwards the corresponding BSON-representation to the ...</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23756">json.hpp:23756</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d133cf7b2e729e9e215edeba5726116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d133cf7b2e729e9e215edeba5726116">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23771">23771</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23773"></a><span class="lineno">23773</span>&#160;            {</div>
<div class="line"><a name="l23774"></a><span class="lineno">23774</span>&#160;                binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type);</div>
<div class="line"><a name="l23775"></a><span class="lineno">23775</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19dad92c4fe9e6a289a93195e1230e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dad92c4fe9e6a289a93195e1230e97">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1detail_1_1output__adapter.html">detail::output_adapter</a>&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the given JSON object <code>j</code> to BSON and forwards the corresponding BSON-representation to the given output_adapter <code>o</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The JSON object to convert to BSON. </td></tr>
    <tr><td class="paramname">o</td><td>The output adapter that receives the binary BSON representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input <code>j</code> shall be an object: <code>j.is_object() == true</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnlohmann_1_1basic__json.html#aa62d64781b217372225a0652047d8cf3">to_bson(const basic_json&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23765">23765</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23767"></a><span class="lineno">23767</span>&#160;            {</div>
<div class="line"><a name="l23768"></a><span class="lineno">23768</span>&#160;                binary_writer&lt;uint8_t&gt;(o).write_ubjson(j, use_size, use_type);</div>
<div class="line"><a name="l23769"></a><span class="lineno">23769</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b7c4b35a0ad9f97474912a08965d7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7c4b35a0ad9f97474912a08965d7ad">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985">value_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l18819">18819</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l18820"></a><span class="lineno">18820</span>&#160;            {</div>
<div class="line"><a name="l18821"></a><span class="lineno">18821</span>&#160;                <span class="keywordflow">return</span> m_type;</div>
<div class="line"><a name="l18822"></a><span class="lineno">18822</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a459dbfcd47bd632ca82ca8ff8db278c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459dbfcd47bd632ca82ca8ff8db278c8">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="json_8hpp.html#a5f2aaec3b681d0a72f7d6e90b70cdcd1">JSON_HEDLEY_RETURNS_NON_NULL</a> const char* <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23419">23419</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23420"></a><span class="lineno">23420</span>&#160;            {</div>
<div class="line"><a name="l23421"></a><span class="lineno">23421</span>&#160;            {</div>
<div class="line"><a name="l23422"></a><span class="lineno">23422</span>&#160;                                           <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><a name="l23423"></a><span class="lineno">23423</span>&#160;            {</div>
<div class="line"><a name="l23424"></a><span class="lineno">23424</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l23425"></a><span class="lineno">23425</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;null&quot;</span>;</div>
<div class="line"><a name="l23426"></a><span class="lineno">23426</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l23427"></a><span class="lineno">23427</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;object&quot;</span>;</div>
<div class="line"><a name="l23428"></a><span class="lineno">23428</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l23429"></a><span class="lineno">23429</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;array&quot;</span>;</div>
<div class="line"><a name="l23430"></a><span class="lineno">23430</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l23431"></a><span class="lineno">23431</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;string&quot;</span>;</div>
<div class="line"><a name="l23432"></a><span class="lineno">23432</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l23433"></a><span class="lineno">23433</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;boolean&quot;</span>;</div>
<div class="line"><a name="l23434"></a><span class="lineno">23434</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l23435"></a><span class="lineno">23435</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;binary&quot;</span>;</div>
<div class="line"><a name="l23436"></a><span class="lineno">23436</span>&#160;                                           <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a94708897ec9db8647dfe695714c98e46">value_t::discarded</a>:</div>
<div class="line"><a name="l23437"></a><span class="lineno">23437</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;discarded&quot;</span>;</div>
<div class="line"><a name="l23438"></a><span class="lineno">23438</span>&#160;                                           <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l23439"></a><span class="lineno">23439</span>&#160;                                           <span class="keywordflow">return</span> <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line"><a name="l23440"></a><span class="lineno">23440</span>&#160;    }</div>
<div class="line"><a name="l23441"></a><span class="lineno">23441</span>&#160;    }</div>
<div class="line"><a name="l23442"></a><span class="lineno">23442</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adea158bff8642202420898f6322da479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea158bff8642202420898f6322da479">&#9670;&nbsp;</a></span>unflatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::unflatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24608">24608</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l24609"></a><span class="lineno">24609</span>&#160;            {</div>
<div class="line"><a name="l24610"></a><span class="lineno">24610</span>&#160;                <span class="keywordflow">return</span> json_pointer::unflatten(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l24611"></a><span class="lineno">24611</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f9e5f668474280acc9bd7f5410b9392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9e5f668474280acc9bd7f5410b9392">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#aebd2cfa7e4ded4e97cde9269bfeeea38">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22315">22315</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22316"></a><span class="lineno">22316</span>&#160;            {</div>
<div class="line"><a name="l22317"></a><span class="lineno">22317</span>&#160;                <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><a name="l22318"></a><span class="lineno">22318</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l22319"></a><span class="lineno">22319</span>&#160;                {</div>
<div class="line"><a name="l22320"></a><span class="lineno">22320</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l22321"></a><span class="lineno">22321</span>&#160;                    m_value.object = create&lt;object_t&gt;();</div>
<div class="line"><a name="l22322"></a><span class="lineno">22322</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l22323"></a><span class="lineno">22323</span>&#160;                }</div>
<div class="line"><a name="l22324"></a><span class="lineno">22324</span>&#160; </div>
<div class="line"><a name="l22325"></a><span class="lineno">22325</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l22326"></a><span class="lineno">22326</span>&#160;                {</div>
<div class="line"><a name="l22327"></a><span class="lineno">22327</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(312, <span class="stringliteral">&quot;cannot use update() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22328"></a><span class="lineno">22328</span>&#160;                }</div>
<div class="line"><a name="l22329"></a><span class="lineno">22329</span>&#160; </div>
<div class="line"><a name="l22330"></a><span class="lineno">22330</span>&#160;                <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><a name="l22331"></a><span class="lineno">22331</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(first.m_object != last.m_object))</div>
<div class="line"><a name="l22332"></a><span class="lineno">22332</span>&#160;                {</div>
<div class="line"><a name="l22333"></a><span class="lineno">22333</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>));</div>
<div class="line"><a name="l22334"></a><span class="lineno">22334</span>&#160;                }</div>
<div class="line"><a name="l22335"></a><span class="lineno">22335</span>&#160; </div>
<div class="line"><a name="l22336"></a><span class="lineno">22336</span>&#160;                <span class="comment">// passed iterators must belong to objects</span></div>
<div class="line"><a name="l22337"></a><span class="lineno">22337</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!first.m_object-&gt;is_object()</div>
<div class="line"><a name="l22338"></a><span class="lineno">22338</span>&#160;                                         || !last.m_object-&gt;is_object()))</div>
<div class="line"><a name="l22339"></a><span class="lineno">22339</span>&#160;                {</div>
<div class="line"><a name="l22340"></a><span class="lineno">22340</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1invalid__iterator.html#a4e849260a3caa1b288c7e619130c6c09">invalid_iterator::create</a>(202, <span class="stringliteral">&quot;iterators first and last must point to objects&quot;</span>));</div>
<div class="line"><a name="l22341"></a><span class="lineno">22341</span>&#160;                }</div>
<div class="line"><a name="l22342"></a><span class="lineno">22342</span>&#160; </div>
<div class="line"><a name="l22343"></a><span class="lineno">22343</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it)</div>
<div class="line"><a name="l22344"></a><span class="lineno">22344</span>&#160;                {</div>
<div class="line"><a name="l22345"></a><span class="lineno">22345</span>&#160;                    m_value.object-&gt;operator[](it.key()) = it.value();</div>
<div class="line"><a name="l22346"></a><span class="lineno">22346</span>&#160;                }</div>
<div class="line"><a name="l22347"></a><span class="lineno">22347</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a377819905d567f6f523dcbc592cb6356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377819905d567f6f523dcbc592cb6356">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22264">22264</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22265"></a><span class="lineno">22265</span>&#160;            {</div>
<div class="line"><a name="l22266"></a><span class="lineno">22266</span>&#160;                <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><a name="l22267"></a><span class="lineno">22267</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classnlohmann_1_1basic__json.html#aedc7afad96292b5ab61a2e0ad3067f5f">is_null</a>())</div>
<div class="line"><a name="l22268"></a><span class="lineno">22268</span>&#160;                {</div>
<div class="line"><a name="l22269"></a><span class="lineno">22269</span>&#160;                    m_type = <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>;</div>
<div class="line"><a name="l22270"></a><span class="lineno">22270</span>&#160;                    m_value.object = create&lt;object_t&gt;();</div>
<div class="line"><a name="l22271"></a><span class="lineno">22271</span>&#160;                    assert_invariant();</div>
<div class="line"><a name="l22272"></a><span class="lineno">22272</span>&#160;                }</div>
<div class="line"><a name="l22273"></a><span class="lineno">22273</span>&#160; </div>
<div class="line"><a name="l22274"></a><span class="lineno">22274</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l22275"></a><span class="lineno">22275</span>&#160;                {</div>
<div class="line"><a name="l22276"></a><span class="lineno">22276</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(312, <span class="stringliteral">&quot;cannot use update() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l22277"></a><span class="lineno">22277</span>&#160;                }</div>
<div class="line"><a name="l22278"></a><span class="lineno">22278</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a8df7de76ab3c9445f46f6994ec205bcd">JSON_HEDLEY_UNLIKELY</a>(!j.is_object()))</div>
<div class="line"><a name="l22279"></a><span class="lineno">22279</span>&#160;                {</div>
<div class="line"><a name="l22280"></a><span class="lineno">22280</span>&#160;                    <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(312, <span class="stringliteral">&quot;cannot use update() with &quot;</span> + std::string(j.type_name())));</div>
<div class="line"><a name="l22281"></a><span class="lineno">22281</span>&#160;                }</div>
<div class="line"><a name="l22282"></a><span class="lineno">22282</span>&#160; </div>
<div class="line"><a name="l22283"></a><span class="lineno">22283</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = j.cbegin(); it != j.cend(); ++it)</div>
<div class="line"><a name="l22284"></a><span class="lineno">22284</span>&#160;                {</div>
<div class="line"><a name="l22285"></a><span class="lineno">22285</span>&#160;                    m_value.object-&gt;operator[](it.key()) = it.value();</div>
<div class="line"><a name="l22286"></a><span class="lineno">22286</span>&#160;                }</div>
<div class="line"><a name="l22287"></a><span class="lineno">22287</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4658a584571c4180656f5268969ed0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4658a584571c4180656f5268969ed0a1">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20382">20382</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20383"></a><span class="lineno">20383</span>&#160;            {</div>
<div class="line"><a name="l20384"></a><span class="lineno">20384</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a>(ptr, <a class="code" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>(default_value));</div>
<div class="line"><a name="l20385"></a><span class="lineno">20385</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a11641b35219676b225d9bd15c7677659"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">nlohmann::basic_json::value</a></div><div class="ttdeci">ValueType value(const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</div><div class="ttdoc">overload for a default value of type const char*</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l20286">json.hpp:20286</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36bd6765ccd8aeeeb4e49a766ba639df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bd6765ccd8aeeeb4e49a766ba639df">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , typename std::enable_if&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html#aa8f1f93b32da01b42413643be32b2c27">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20358">20358</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20359"></a><span class="lineno">20359</span>&#160;            {</div>
<div class="line"><a name="l20360"></a><span class="lineno">20360</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l20361"></a><span class="lineno">20361</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20362"></a><span class="lineno">20362</span>&#160;                {</div>
<div class="line"><a name="l20363"></a><span class="lineno">20363</span>&#160;                    <span class="comment">// if pointer resolves a value, return it or use default value</span></div>
<div class="line"><a name="l20364"></a><span class="lineno">20364</span>&#160;                    <a class="code" href="json_8hpp.html#a985d3b82445302c57257f6432f261fe9">JSON_TRY</a></div>
<div class="line"><a name="l20365"></a><span class="lineno">20365</span>&#160;                    {</div>
<div class="line"><a name="l20366"></a><span class="lineno">20366</span>&#160;                        <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>).template get&lt;ValueType&gt;();</div>
<div class="line"><a name="l20367"></a><span class="lineno">20367</span>&#160;                    }</div>
<div class="line"><a name="l20368"></a><span class="lineno">20368</span>&#160;                    <a class="code" href="json_8hpp.html#a5478b7564e65634cc69432ed3cb6490e">JSON_INTERNAL_CATCH</a> (<a class="code" href="classnlohmann_1_1basic__json.html#a2251d8523fa6d16c0fba6388ffa2ef8c">out_of_range</a>&amp;)</div>
<div class="line"><a name="l20369"></a><span class="lineno">20369</span>&#160;                    {</div>
<div class="line"><a name="l20370"></a><span class="lineno">20370</span>&#160;                        <span class="keywordflow">return</span> default_value;</div>
<div class="line"><a name="l20371"></a><span class="lineno">20371</span>&#160;                    }</div>
<div class="line"><a name="l20372"></a><span class="lineno">20372</span>&#160;                }</div>
<div class="line"><a name="l20373"></a><span class="lineno">20373</span>&#160; </div>
<div class="line"><a name="l20374"></a><span class="lineno">20374</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(306, <span class="stringliteral">&quot;cannot use value() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20375"></a><span class="lineno">20375</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adcfdefe95d5c2471a5c97e911d46ee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfdefe95d5c2471a5c97e911d46ee88">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a> <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20308">20308</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20309"></a><span class="lineno">20309</span>&#160;            {</div>
<div class="line"><a name="l20310"></a><span class="lineno">20310</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a11641b35219676b225d9bd15c7677659">value</a>(key, <a class="code" href="classnlohmann_1_1basic__json.html#a33593865ffb1860323dcbd52425b90c8">string_t</a>(default_value));</div>
<div class="line"><a name="l20311"></a><span class="lineno">20311</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11641b35219676b225d9bd15c7677659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11641b35219676b225d9bd15c7677659">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , typename std::enable_if&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, ValueType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classnlohmann_1_1basic__json.html">nlohmann::basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload for a default value of type const char* </p>
<p>overload for a default value of type const char*</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20286">20286</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l20287"></a><span class="lineno">20287</span>&#160;            {</div>
<div class="line"><a name="l20288"></a><span class="lineno">20288</span>&#160;                <span class="comment">// at only works for objects</span></div>
<div class="line"><a name="l20289"></a><span class="lineno">20289</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="json_8hpp.html#a355f2770653ff7bdd5c74b204b5a3ad0">JSON_HEDLEY_LIKELY</a>(<a class="code" href="classnlohmann_1_1basic__json.html#a57e8411a770a6263d6d8f2116c37f3aa">is_object</a>()))</div>
<div class="line"><a name="l20290"></a><span class="lineno">20290</span>&#160;                {</div>
<div class="line"><a name="l20291"></a><span class="lineno">20291</span>&#160;                    <span class="comment">// if key is found, return value and given default value otherwise</span></div>
<div class="line"><a name="l20292"></a><span class="lineno">20292</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code" href="classnlohmann_1_1basic__json.html#acdf9b3aab82dcf443dd91ca5ec06b80c">find</a>(key);</div>
<div class="line"><a name="l20293"></a><span class="lineno">20293</span>&#160;                    <span class="keywordflow">if</span> (it != <a class="code" href="classnlohmann_1_1basic__json.html#a931267ec3f09eb67e4382f321b2c52bc">end</a>())</div>
<div class="line"><a name="l20294"></a><span class="lineno">20294</span>&#160;                    {</div>
<div class="line"><a name="l20295"></a><span class="lineno">20295</span>&#160;                        <span class="keywordflow">return</span> it-&gt;template get&lt;ValueType&gt;();</div>
<div class="line"><a name="l20296"></a><span class="lineno">20296</span>&#160;                    }</div>
<div class="line"><a name="l20297"></a><span class="lineno">20297</span>&#160; </div>
<div class="line"><a name="l20298"></a><span class="lineno">20298</span>&#160;                    <span class="keywordflow">return</span> default_value;</div>
<div class="line"><a name="l20299"></a><span class="lineno">20299</span>&#160;                }</div>
<div class="line"><a name="l20300"></a><span class="lineno">20300</span>&#160; </div>
<div class="line"><a name="l20301"></a><span class="lineno">20301</span>&#160;                <a class="code" href="json_8hpp.html#a6c274f6db2e65c1b66c7d41b06ad690f">JSON_THROW</a>(<a class="code" href="classnlohmann_1_1detail_1_1type__error.html#aecc083aea4b698c33d042670ba50c10f">type_error::create</a>(306, <span class="stringliteral">&quot;cannot use value() with &quot;</span> + std::string(<a class="code" href="classnlohmann_1_1basic__json.html#a459dbfcd47bd632ca82ca8ff8db278c8">type_name</a>())));</div>
<div class="line"><a name="l20302"></a><span class="lineno">20302</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_acdf9b3aab82dcf443dd91ca5ec06b80c"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#acdf9b3aab82dcf443dd91ca5ec06b80c">nlohmann::basic_json::find</a></div><div class="ttdeci">iterator find(KeyT &amp;&amp;key)</div><div class="ttdoc">find an element in a JSON object</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l20819">json.hpp:20819</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa226ed5103dfd10e27e562d35a3a106b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa226ed5103dfd10e27e562d35a3a106b">&#9670;&nbsp;</a></span>::nlohmann::detail::binary_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1binary__reader.html">nlohmann::detail::binary_reader</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16678">16678</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a69d491bbda88ade6d3c7a2b11309e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d491bbda88ade6d3c7a2b11309e8bf">&#9670;&nbsp;</a></span>::nlohmann::detail::binary_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1binary__writer.html">nlohmann::detail::binary_writer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16676">16676</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a842e5c7ca096025c18b11e715d3401f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842e5c7ca096025c18b11e715d3401f4">&#9670;&nbsp;</a></span>::nlohmann::detail::iter_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1iter__impl.html">nlohmann::detail::iter_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16674">16674</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a95574da8d12905ea99dc348934c837da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95574da8d12905ea99dc348934c837da">&#9670;&nbsp;</a></span>::nlohmann::detail::json_sax_dom_callback_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1json__sax__dom__callback__parser.html">nlohmann::detail::json_sax_dom_callback_parser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16682">16682</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a47aabb1eceae32e8a6e8e7f0ff34be60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aabb1eceae32e8a6e8e7f0ff34be60">&#9670;&nbsp;</a></span>::nlohmann::detail::json_sax_dom_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1json__sax__dom__parser.html">nlohmann::detail::json_sax_dom_parser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16680">16680</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8f3125911eb018ef4ab00d879487baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f3125911eb018ef4ab00d879487baf">&#9670;&nbsp;</a></span>::nlohmann::detail::parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classnlohmann_1_1detail_1_1parser.html">nlohmann::detail::parser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16671">16671</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6275ed57bae6866cdf5db5370a7ad47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6275ed57bae6866cdf5db5370a7ad47c">&#9670;&nbsp;</a></span>detail::external_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;detail::value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structnlohmann_1_1detail_1_1external__constructor.html">detail::external_constructor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l16667">16667</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab0e886db6e9fa91ff9fd853333fed05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e886db6e9fa91ff9fd853333fed05b">&#9670;&nbsp;</a></span>operator!= <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: not equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22747">22747</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22748"></a><span class="lineno">22748</span>&#160;            {</div>
<div class="line"><a name="l22749"></a><span class="lineno">22749</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) != rhs;</div>
<div class="line"><a name="l22750"></a><span class="lineno">22750</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afefc38fc08bdb7a9a7474b5ab4a1140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefc38fc08bdb7a9a7474b5ab4a1140f">&#9670;&nbsp;</a></span>operator!= <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: not equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22736">22736</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22737"></a><span class="lineno">22737</span>&#160;            {</div>
<div class="line"><a name="l22738"></a><span class="lineno">22738</span>&#160;                <span class="keywordflow">return</span> lhs != <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22739"></a><span class="lineno">22739</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e2e21da48f5d9471716cd868a068327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2e21da48f5d9471716cd868a068327">&#9670;&nbsp;</a></span>operator!= <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22725">22725</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22726"></a><span class="lineno">22726</span>&#160;            {</div>
<div class="line"><a name="l22727"></a><span class="lineno">22727</span>&#160;                <span class="keywordflow">return</span> !(lhs == rhs);</div>
<div class="line"><a name="l22728"></a><span class="lineno">22728</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abed3e9b4ab75f5bcbd3cd20f5af5cdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed3e9b4ab75f5bcbd3cd20f5af5cdab">&#9670;&nbsp;</a></span>operator&lt; <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: less than </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22868">22868</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22869"></a><span class="lineno">22869</span>&#160;            {</div>
<div class="line"><a name="l22870"></a><span class="lineno">22870</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) &lt; rhs;</div>
<div class="line"><a name="l22871"></a><span class="lineno">22871</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7999ee3a69a4979d92e98ab1e88c8759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7999ee3a69a4979d92e98ab1e88c8759">&#9670;&nbsp;</a></span>operator&lt; <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: less than </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22857">22857</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22858"></a><span class="lineno">22858</span>&#160;            {</div>
<div class="line"><a name="l22859"></a><span class="lineno">22859</span>&#160;                <span class="keywordflow">return</span> lhs &lt; <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22860"></a><span class="lineno">22860</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacd442b66140c764c594ac8ad7dfd5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd442b66140c764c594ac8ad7dfd5b3">&#9670;&nbsp;</a></span>operator&lt; <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22778">22778</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22779"></a><span class="lineno">22779</span>&#160;            {</div>
<div class="line"><a name="l22780"></a><span class="lineno">22780</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> lhs_type = lhs.type();</div>
<div class="line"><a name="l22781"></a><span class="lineno">22781</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> rhs_type = rhs.type();</div>
<div class="line"><a name="l22782"></a><span class="lineno">22782</span>&#160; </div>
<div class="line"><a name="l22783"></a><span class="lineno">22783</span>&#160;                <span class="keywordflow">if</span> (lhs_type == rhs_type)</div>
<div class="line"><a name="l22784"></a><span class="lineno">22784</span>&#160;                {</div>
<div class="line"><a name="l22785"></a><span class="lineno">22785</span>&#160;                    <span class="keywordflow">switch</span> (lhs_type)</div>
<div class="line"><a name="l22786"></a><span class="lineno">22786</span>&#160;                    {</div>
<div class="line"><a name="l22787"></a><span class="lineno">22787</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l22788"></a><span class="lineno">22788</span>&#160;                            <span class="comment">// note parentheses are necessary, see</span></div>
<div class="line"><a name="l22789"></a><span class="lineno">22789</span>&#160;                            <span class="comment">// https://github.com/nlohmann/json/issues/1530</span></div>
<div class="line"><a name="l22790"></a><span class="lineno">22790</span>&#160;                            <span class="keywordflow">return</span> (*lhs.m_value.array) &lt; (*rhs.m_value.array);</div>
<div class="line"><a name="l22791"></a><span class="lineno">22791</span>&#160; </div>
<div class="line"><a name="l22792"></a><span class="lineno">22792</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l22793"></a><span class="lineno">22793</span>&#160;                            <span class="keywordflow">return</span> (*lhs.m_value.object) &lt; (*rhs.m_value.object);</div>
<div class="line"><a name="l22794"></a><span class="lineno">22794</span>&#160; </div>
<div class="line"><a name="l22795"></a><span class="lineno">22795</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l22796"></a><span class="lineno">22796</span>&#160;                            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l22797"></a><span class="lineno">22797</span>&#160; </div>
<div class="line"><a name="l22798"></a><span class="lineno">22798</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l22799"></a><span class="lineno">22799</span>&#160;                            <span class="keywordflow">return</span> (*lhs.m_value.string) &lt; (*rhs.m_value.string);</div>
<div class="line"><a name="l22800"></a><span class="lineno">22800</span>&#160; </div>
<div class="line"><a name="l22801"></a><span class="lineno">22801</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l22802"></a><span class="lineno">22802</span>&#160;                            <span class="keywordflow">return</span> (lhs.m_value.boolean) &lt; (rhs.m_value.boolean);</div>
<div class="line"><a name="l22803"></a><span class="lineno">22803</span>&#160; </div>
<div class="line"><a name="l22804"></a><span class="lineno">22804</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l22805"></a><span class="lineno">22805</span>&#160;                            <span class="keywordflow">return</span> (lhs.m_value.number_integer) &lt; (rhs.m_value.number_integer);</div>
<div class="line"><a name="l22806"></a><span class="lineno">22806</span>&#160; </div>
<div class="line"><a name="l22807"></a><span class="lineno">22807</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l22808"></a><span class="lineno">22808</span>&#160;                            <span class="keywordflow">return</span> (lhs.m_value.number_unsigned) &lt; (rhs.m_value.number_unsigned);</div>
<div class="line"><a name="l22809"></a><span class="lineno">22809</span>&#160; </div>
<div class="line"><a name="l22810"></a><span class="lineno">22810</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l22811"></a><span class="lineno">22811</span>&#160;                            <span class="keywordflow">return</span> (lhs.m_value.number_float) &lt; (rhs.m_value.number_float);</div>
<div class="line"><a name="l22812"></a><span class="lineno">22812</span>&#160; </div>
<div class="line"><a name="l22813"></a><span class="lineno">22813</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l22814"></a><span class="lineno">22814</span>&#160;                            <span class="keywordflow">return</span> (*lhs.m_value.binary) &lt; (*rhs.m_value.binary);</div>
<div class="line"><a name="l22815"></a><span class="lineno">22815</span>&#160; </div>
<div class="line"><a name="l22816"></a><span class="lineno">22816</span>&#160;                        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l22817"></a><span class="lineno">22817</span>&#160;                            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l22818"></a><span class="lineno">22818</span>&#160;                    }</div>
<div class="line"><a name="l22819"></a><span class="lineno">22819</span>&#160;                }</div>
<div class="line"><a name="l22820"></a><span class="lineno">22820</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>)</div>
<div class="line"><a name="l22821"></a><span class="lineno">22821</span>&#160;                {</div>
<div class="line"><a name="l22822"></a><span class="lineno">22822</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_integer) &lt; rhs.m_value.number_float;</div>
<div class="line"><a name="l22823"></a><span class="lineno">22823</span>&#160;                }</div>
<div class="line"><a name="l22824"></a><span class="lineno">22824</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>)</div>
<div class="line"><a name="l22825"></a><span class="lineno">22825</span>&#160;                {</div>
<div class="line"><a name="l22826"></a><span class="lineno">22826</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_float &lt; <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_integer);</div>
<div class="line"><a name="l22827"></a><span class="lineno">22827</span>&#160;                }</div>
<div class="line"><a name="l22828"></a><span class="lineno">22828</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>)</div>
<div class="line"><a name="l22829"></a><span class="lineno">22829</span>&#160;                {</div>
<div class="line"><a name="l22830"></a><span class="lineno">22830</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_float;</div>
<div class="line"><a name="l22831"></a><span class="lineno">22831</span>&#160;                }</div>
<div class="line"><a name="l22832"></a><span class="lineno">22832</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>)</div>
<div class="line"><a name="l22833"></a><span class="lineno">22833</span>&#160;                {</div>
<div class="line"><a name="l22834"></a><span class="lineno">22834</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_float &lt; <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_unsigned);</div>
<div class="line"><a name="l22835"></a><span class="lineno">22835</span>&#160;                }</div>
<div class="line"><a name="l22836"></a><span class="lineno">22836</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>)</div>
<div class="line"><a name="l22837"></a><span class="lineno">22837</span>&#160;                {</div>
<div class="line"><a name="l22838"></a><span class="lineno">22838</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_integer &lt; <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_unsigned);</div>
<div class="line"><a name="l22839"></a><span class="lineno">22839</span>&#160;                }</div>
<div class="line"><a name="l22840"></a><span class="lineno">22840</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>)</div>
<div class="line"><a name="l22841"></a><span class="lineno">22841</span>&#160;                {</div>
<div class="line"><a name="l22842"></a><span class="lineno">22842</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_unsigned) &lt; rhs.m_value.number_integer;</div>
<div class="line"><a name="l22843"></a><span class="lineno">22843</span>&#160;                }</div>
<div class="line"><a name="l22844"></a><span class="lineno">22844</span>&#160; </div>
<div class="line"><a name="l22845"></a><span class="lineno">22845</span>&#160;                <span class="comment">// We only reach this line if we cannot compare values. In that case,</span></div>
<div class="line"><a name="l22846"></a><span class="lineno">22846</span>&#160;                <span class="comment">// we compare types. Note we have to call the operator explicitly,</span></div>
<div class="line"><a name="l22847"></a><span class="lineno">22847</span>&#160;                <span class="comment">// because MSVC has problems otherwise.</span></div>
<div class="line"><a name="l22848"></a><span class="lineno">22848</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#aacd442b66140c764c594ac8ad7dfd5b3">operator&lt;</a>(lhs_type, rhs_type);</div>
<div class="line"><a name="l22849"></a><span class="lineno">22849</span>&#160;            }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a11e390944da90db83089eb2426a749d3"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">nlohmann::basic_json::number_integer_t</a></div><div class="ttdeci">NumberIntegerType number_integer_t</div><div class="ttdoc">a type for a number (integer)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l17195">json.hpp:17195</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a5b8abaebd922d82d69756327c0c347e6"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">nlohmann::basic_json::number_float_t</a></div><div class="ttdeci">NumberFloatType number_float_t</div><div class="ttdoc">a type for a number (floating-point)</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l17334">json.hpp:17334</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_aacd442b66140c764c594ac8ad7dfd5b3"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#aacd442b66140c764c594ac8ad7dfd5b3">nlohmann::basic_json::operator&lt;</a></div><div class="ttdeci">friend bool operator&lt;(const_reference lhs, const_reference rhs) noexcept</div><div class="ttdoc">comparison: equal</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l22778">json.hpp:22778</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a60ca396028b8d9714c6e10efbf475af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ca396028b8d9714c6e10efbf475af6">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23345">23345</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23346"></a><span class="lineno">23346</span>&#160;            {</div>
<div class="line"><a name="l23347"></a><span class="lineno">23347</span>&#160;                                           <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a34d6a60dd99e9f33b8273a1c8db5669b">operator&gt;&gt;</a>(i, j);</div>
<div class="line"><a name="l23348"></a><span class="lineno">23348</span>&#160;    }</div>
<div class="ttc" id="aclassnlohmann_1_1basic__json_html_a34d6a60dd99e9f33b8273a1c8db5669b"><div class="ttname"><a href="classnlohmann_1_1basic__json.html#a34d6a60dd99e9f33b8273a1c8db5669b">nlohmann::basic_json::operator&gt;&gt;</a></div><div class="ttdeci">friend std::ostream &amp; operator&gt;&gt;(const basic_json &amp;j, std::ostream &amp;o)</div><div class="ttdoc">serialize to stream</div><div class="ttdef"><b>Definition:</b> <a href="json_8hpp_source.html#l23075">json.hpp:23075</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e34c5435e557d0bf666bd7311211405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e34c5435e557d0bf666bd7311211405">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize to stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#a5e34c5435e557d0bf666bd7311211405">operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</a> instead; that is, replace calls like <code>j &gt;&gt; o;</code> with <code>o &lt;&lt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23051">23051</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23052"></a><span class="lineno">23052</span>&#160;            {</div>
<div class="line"><a name="l23053"></a><span class="lineno">23053</span>&#160;                <span class="comment">// read width member and use it as indentation parameter if nonzero</span></div>
<div class="line"><a name="l23054"></a><span class="lineno">23054</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">bool</span> pretty_print = o.width() &gt; 0;</div>
<div class="line"><a name="l23055"></a><span class="lineno">23055</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> indentation = pretty_print ? o.width() : 0;</div>
<div class="line"><a name="l23056"></a><span class="lineno">23056</span>&#160; </div>
<div class="line"><a name="l23057"></a><span class="lineno">23057</span>&#160;                <span class="comment">// reset width to 0 for subsequent calls to this stream</span></div>
<div class="line"><a name="l23058"></a><span class="lineno">23058</span>&#160;                o.width(0);</div>
<div class="line"><a name="l23059"></a><span class="lineno">23059</span>&#160; </div>
<div class="line"><a name="l23060"></a><span class="lineno">23060</span>&#160;                <span class="comment">// do the actual serialization</span></div>
<div class="line"><a name="l23061"></a><span class="lineno">23061</span>&#160;                serializer s(detail::output_adapter&lt;char&gt;(o), o.fill());</div>
<div class="line"><a name="l23062"></a><span class="lineno">23062</span>&#160;                s.dump(j, pretty_print, <span class="keyword">false</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(indentation));</div>
<div class="line"><a name="l23063"></a><span class="lineno">23063</span>&#160;                <span class="keywordflow">return</span> o;</div>
<div class="line"><a name="l23064"></a><span class="lineno">23064</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad73f88f70fe5acfa521750a8cd710026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73f88f70fe5acfa521750a8cd710026">&#9670;&nbsp;</a></span>operator&lt;= <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: less than or equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22914">22914</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22915"></a><span class="lineno">22915</span>&#160;            {</div>
<div class="line"><a name="l22916"></a><span class="lineno">22916</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) &lt;= rhs;</div>
<div class="line"><a name="l22917"></a><span class="lineno">22917</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e368211047f725f333696aefdf39ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e368211047f725f333696aefdf39ffd">&#9670;&nbsp;</a></span>operator&lt;= <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: less than or equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22903">22903</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22904"></a><span class="lineno">22904</span>&#160;            {</div>
<div class="line"><a name="l22905"></a><span class="lineno">22905</span>&#160;                <span class="keywordflow">return</span> lhs &lt;= <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22906"></a><span class="lineno">22906</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c8bb5200f5eac10d31e26be46e5b1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8bb5200f5eac10d31e26be46e5b1ac">&#9670;&nbsp;</a></span>operator&lt;= <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22892">22892</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22893"></a><span class="lineno">22893</span>&#160;            {</div>
<div class="line"><a name="l22894"></a><span class="lineno">22894</span>&#160;                <span class="keywordflow">return</span> !(rhs &lt; lhs);</div>
<div class="line"><a name="l22895"></a><span class="lineno">22895</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aef302e3ae215e46e5035d0e4fdf47235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef302e3ae215e46e5035d0e4fdf47235">&#9670;&nbsp;</a></span>operator== <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22702">22702</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22703"></a><span class="lineno">22703</span>&#160;            {</div>
<div class="line"><a name="l22704"></a><span class="lineno">22704</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) == rhs;</div>
<div class="line"><a name="l22705"></a><span class="lineno">22705</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba21440ea1aff44f718285ed7d6d20d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba21440ea1aff44f718285ed7d6d20d9">&#9670;&nbsp;</a></span>operator== <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22691">22691</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22692"></a><span class="lineno">22692</span>&#160;            {</div>
<div class="line"><a name="l22693"></a><span class="lineno">22693</span>&#160;                <span class="keywordflow">return</span> lhs == <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22694"></a><span class="lineno">22694</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a122640e7e2db1814fc7bbb3c122ec76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122640e7e2db1814fc7bbb3c122ec76e">&#9670;&nbsp;</a></span>operator== <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22617">22617</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22618"></a><span class="lineno">22618</span>&#160;            {</div>
<div class="line"><a name="l22619"></a><span class="lineno">22619</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> lhs_type = lhs.type();</div>
<div class="line"><a name="l22620"></a><span class="lineno">22620</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> rhs_type = rhs.type();</div>
<div class="line"><a name="l22621"></a><span class="lineno">22621</span>&#160; </div>
<div class="line"><a name="l22622"></a><span class="lineno">22622</span>&#160;                <span class="keywordflow">if</span> (lhs_type == rhs_type)</div>
<div class="line"><a name="l22623"></a><span class="lineno">22623</span>&#160;                {</div>
<div class="line"><a name="l22624"></a><span class="lineno">22624</span>&#160;                    <span class="keywordflow">switch</span> (lhs_type)</div>
<div class="line"><a name="l22625"></a><span class="lineno">22625</span>&#160;                    {</div>
<div class="line"><a name="l22626"></a><span class="lineno">22626</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>:</div>
<div class="line"><a name="l22627"></a><span class="lineno">22627</span>&#160;                            <span class="keywordflow">return</span> *lhs.m_value.array == *rhs.m_value.array;</div>
<div class="line"><a name="l22628"></a><span class="lineno">22628</span>&#160; </div>
<div class="line"><a name="l22629"></a><span class="lineno">22629</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985aa8cfde6331bd59eb2ac96f8911c4b666">value_t::object</a>:</div>
<div class="line"><a name="l22630"></a><span class="lineno">22630</span>&#160;                            <span class="keywordflow">return</span> *lhs.m_value.object == *rhs.m_value.object;</div>
<div class="line"><a name="l22631"></a><span class="lineno">22631</span>&#160; </div>
<div class="line"><a name="l22632"></a><span class="lineno">22632</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a>:</div>
<div class="line"><a name="l22633"></a><span class="lineno">22633</span>&#160;                            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l22634"></a><span class="lineno">22634</span>&#160; </div>
<div class="line"><a name="l22635"></a><span class="lineno">22635</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ab45cffe084dd3d20d928bee85e7b0f21">value_t::string</a>:</div>
<div class="line"><a name="l22636"></a><span class="lineno">22636</span>&#160;                            <span class="keywordflow">return</span> *lhs.m_value.string == *rhs.m_value.string;</div>
<div class="line"><a name="l22637"></a><span class="lineno">22637</span>&#160; </div>
<div class="line"><a name="l22638"></a><span class="lineno">22638</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a84e2c64f38f78ba3ea5c905ab5a2da27">value_t::boolean</a>:</div>
<div class="line"><a name="l22639"></a><span class="lineno">22639</span>&#160;                            <span class="keywordflow">return</span> lhs.m_value.boolean == rhs.m_value.boolean;</div>
<div class="line"><a name="l22640"></a><span class="lineno">22640</span>&#160; </div>
<div class="line"><a name="l22641"></a><span class="lineno">22641</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>:</div>
<div class="line"><a name="l22642"></a><span class="lineno">22642</span>&#160;                            <span class="keywordflow">return</span> lhs.m_value.number_integer == rhs.m_value.number_integer;</div>
<div class="line"><a name="l22643"></a><span class="lineno">22643</span>&#160; </div>
<div class="line"><a name="l22644"></a><span class="lineno">22644</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>:</div>
<div class="line"><a name="l22645"></a><span class="lineno">22645</span>&#160;                            <span class="keywordflow">return</span> lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;</div>
<div class="line"><a name="l22646"></a><span class="lineno">22646</span>&#160; </div>
<div class="line"><a name="l22647"></a><span class="lineno">22647</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>:</div>
<div class="line"><a name="l22648"></a><span class="lineno">22648</span>&#160;                            <span class="keywordflow">return</span> lhs.m_value.number_float == rhs.m_value.number_float;</div>
<div class="line"><a name="l22649"></a><span class="lineno">22649</span>&#160; </div>
<div class="line"><a name="l22650"></a><span class="lineno">22650</span>&#160;                        <span class="keywordflow">case</span> <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a9d7183f16acce70658f686ae7f1a4d20">value_t::binary</a>:</div>
<div class="line"><a name="l22651"></a><span class="lineno">22651</span>&#160;                            <span class="keywordflow">return</span> *lhs.m_value.binary == *rhs.m_value.binary;</div>
<div class="line"><a name="l22652"></a><span class="lineno">22652</span>&#160; </div>
<div class="line"><a name="l22653"></a><span class="lineno">22653</span>&#160;                        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l22654"></a><span class="lineno">22654</span>&#160;                            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l22655"></a><span class="lineno">22655</span>&#160;                    }</div>
<div class="line"><a name="l22656"></a><span class="lineno">22656</span>&#160;                }</div>
<div class="line"><a name="l22657"></a><span class="lineno">22657</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>)</div>
<div class="line"><a name="l22658"></a><span class="lineno">22658</span>&#160;                {</div>
<div class="line"><a name="l22659"></a><span class="lineno">22659</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_integer) == rhs.m_value.number_float;</div>
<div class="line"><a name="l22660"></a><span class="lineno">22660</span>&#160;                }</div>
<div class="line"><a name="l22661"></a><span class="lineno">22661</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>)</div>
<div class="line"><a name="l22662"></a><span class="lineno">22662</span>&#160;                {</div>
<div class="line"><a name="l22663"></a><span class="lineno">22663</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_float == <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_integer);</div>
<div class="line"><a name="l22664"></a><span class="lineno">22664</span>&#160;                }</div>
<div class="line"><a name="l22665"></a><span class="lineno">22665</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a>)</div>
<div class="line"><a name="l22666"></a><span class="lineno">22666</span>&#160;                {</div>
<div class="line"><a name="l22667"></a><span class="lineno">22667</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_unsigned) == rhs.m_value.number_float;</div>
<div class="line"><a name="l22668"></a><span class="lineno">22668</span>&#160;                }</div>
<div class="line"><a name="l22669"></a><span class="lineno">22669</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985ad9966ecb59667235a57b4b999a649eef">value_t::number_float</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>)</div>
<div class="line"><a name="l22670"></a><span class="lineno">22670</span>&#160;                {</div>
<div class="line"><a name="l22671"></a><span class="lineno">22671</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_float == <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a5b8abaebd922d82d69756327c0c347e6">number_float_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_unsigned);</div>
<div class="line"><a name="l22672"></a><span class="lineno">22672</span>&#160;                }</div>
<div class="line"><a name="l22673"></a><span class="lineno">22673</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a>)</div>
<div class="line"><a name="l22674"></a><span class="lineno">22674</span>&#160;                {</div>
<div class="line"><a name="l22675"></a><span class="lineno">22675</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a><span class="keyword">&gt;</span>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;</div>
<div class="line"><a name="l22676"></a><span class="lineno">22676</span>&#160;                }</div>
<div class="line"><a name="l22677"></a><span class="lineno">22677</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985a5763da164f8659d94a56e29df64b4bcc">value_t::number_integer</a> &amp;&amp; rhs_type == <a class="code" href="namespacenlohmann_1_1detail.html#a1ed8fc6239da25abcaf681d30ace4985adce7cc8ec29055c4158828921f2f265e">value_t::number_unsigned</a>)</div>
<div class="line"><a name="l22678"></a><span class="lineno">22678</span>&#160;                {</div>
<div class="line"><a name="l22679"></a><span class="lineno">22679</span>&#160;                    <span class="keywordflow">return</span> lhs.m_value.number_integer == <span class="keyword">static_cast&lt;</span><a class="code" href="classnlohmann_1_1basic__json.html#a11e390944da90db83089eb2426a749d3">number_integer_t</a><span class="keyword">&gt;</span>(rhs.m_value.number_unsigned);</div>
<div class="line"><a name="l22680"></a><span class="lineno">22680</span>&#160;                }</div>
<div class="line"><a name="l22681"></a><span class="lineno">22681</span>&#160; </div>
<div class="line"><a name="l22682"></a><span class="lineno">22682</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l22683"></a><span class="lineno">22683</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a124c319566198d9f092c5bebea46ce77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124c319566198d9f092c5bebea46ce77">&#9670;&nbsp;</a></span>operator&gt; <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: greater than </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22960">22960</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22961"></a><span class="lineno">22961</span>&#160;            {</div>
<div class="line"><a name="l22962"></a><span class="lineno">22962</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) &gt; rhs;</div>
<div class="line"><a name="l22963"></a><span class="lineno">22963</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a412895af9a582869a4d369a64fb1b6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412895af9a582869a4d369a64fb1b6d6">&#9670;&nbsp;</a></span>operator&gt; <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: greater than </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22949">22949</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22950"></a><span class="lineno">22950</span>&#160;            {</div>
<div class="line"><a name="l22951"></a><span class="lineno">22951</span>&#160;                <span class="keywordflow">return</span> lhs &gt; <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22952"></a><span class="lineno">22952</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87db51b6b936fb2ea293cdbc8702dcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87db51b6b936fb2ea293cdbc8702dcb8">&#9670;&nbsp;</a></span>operator&gt; <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22938">22938</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22939"></a><span class="lineno">22939</span>&#160;            {</div>
<div class="line"><a name="l22940"></a><span class="lineno">22940</span>&#160;                <span class="keywordflow">return</span> !(lhs &lt;= rhs);</div>
<div class="line"><a name="l22941"></a><span class="lineno">22941</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ee0e3e8afc7cbd932d6ed66418fa80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee0e3e8afc7cbd932d6ed66418fa80a">&#9670;&nbsp;</a></span>operator&gt;= <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: greater than or equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23006">23006</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23007"></a><span class="lineno">23007</span>&#160;            {</div>
<div class="line"><a name="l23008"></a><span class="lineno">23008</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(lhs) &gt;= rhs;</div>
<div class="line"><a name="l23009"></a><span class="lineno">23009</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a68e3a92b3d9be1faa05c92d096299189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e3a92b3d9be1faa05c92d096299189">&#9670;&nbsp;</a></span>operator&gt;= <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ScalarType , typename std::enable_if&lt; std::is_scalar&lt; ScalarType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: greater than or equal </p>
<p>comparison: equal comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22995">22995</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22996"></a><span class="lineno">22996</span>&#160;            {</div>
<div class="line"><a name="l22997"></a><span class="lineno">22997</span>&#160;                <span class="keywordflow">return</span> lhs &gt;= <a class="code" href="classnlohmann_1_1basic__json.html#a19734fbc9c97d536832892ddacd6b62a">basic_json</a>(rhs);</div>
<div class="line"><a name="l22998"></a><span class="lineno">22998</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74a943800c7f103d0990d7eef82c6453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a943800c7f103d0990d7eef82c6453">&#9670;&nbsp;</a></span>operator&gt;= <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#ab8a1c33ee7b154fc41ca2545aa9724e6">const_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>comparison: equal </p>
<p>comparison: equal</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22984">22984</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22985"></a><span class="lineno">22985</span>&#160;            {</div>
<div class="line"><a name="l22986"></a><span class="lineno">22986</span>&#160;                <span class="keywordflow">return</span> !(lhs &lt; rhs);</div>
<div class="line"><a name="l22987"></a><span class="lineno">22987</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34d6a60dd99e9f33b8273a1c8db5669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d6a60dd99e9f33b8273a1c8db5669b">&#9670;&nbsp;</a></span>operator&gt;&gt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize to stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#a5e34c5435e557d0bf666bd7311211405">operator&lt;&lt;(std::ostream&amp;, const basic_json&amp;)</a> instead; that is, replace calls like <code>j &gt;&gt; o;</code> with <code>o &lt;&lt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23075">23075</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23076"></a><span class="lineno">23076</span>&#160;            {</div>
<div class="line"><a name="l23077"></a><span class="lineno">23077</span>&#160;                                           <span class="keywordflow">return</span> o &lt;&lt; j;</div>
<div class="line"><a name="l23078"></a><span class="lineno">23078</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf363408931d76472ded14017e59c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf363408931d76472ded14017e59c9e8">&#9670;&nbsp;</a></span>operator&gt;&gt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classnlohmann_1_1basic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0; deprecated since version 3.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23375">23375</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l23376"></a><span class="lineno">23376</span>&#160;            {</div>
<div class="line"><a name="l23377"></a><span class="lineno">23377</span>&#160;                                           parser(<a class="code" href="namespacenlohmann_1_1detail.html#ad11a087dbe66eade5af4056aef9600bf">detail::input_adapter</a>(i)).parse(<span class="keyword">false</span>, j);</div>
<div class="line"><a name="l23378"></a><span class="lineno">23378</span>&#160;                                           <span class="keywordflow">return</span> i;</div>
<div class="line"><a name="l23379"></a><span class="lineno">23379</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aee0ae36cbfb0336832ebc0374c3c7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0ae36cbfb0336832ebc0374c3c7679">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnlohmann_1_1basic__json.html#a220ae98554a76205fb7f8822d36b2d5a">reference</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<p>add an object to an array</p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22396">22396</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l22402"></a><span class="lineno">22402</span>&#160;            {</div>
<div class="line"><a name="l22403"></a><span class="lineno">22403</span>&#160;                left.swap(right);</div>
<div class="line"><a name="l22404"></a><span class="lineno">22404</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/3rdparty/extern/<a class="el" href="json_8hpp_source.html">json.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenlohmann.html">nlohmann</a></li><li class="navelem"><a class="el" href="classnlohmann_1_1basic__json.html">basic_json</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
